/*
gpe_editor.cpp
This file is part of:
GAME PENCI ENGINE
https://create.pawbyte.com
Copyright (c) 2014-2017 Nathan Hurde, Chase Lee.

Copyright (c) 2014-2017 PawByte.
Copyright (c) 2014-2017 Game Pencil Engine contributors ( Contributors Page )

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the �Software�), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED �AS IS�, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-Game Pencil Engine <https://create.pawbyte.com>


*/

#include "gpe_editor.h"

int lastResTypeRendered = -1;
bool GPE_VERSION_COMMERCIAL_LICENSE = false;
int POPUP_FONT_SIZE_WIDTH = 12;
int POPUP_FONT_SIZE_HEIGHT = 12;
int POPUP_MENU_VALUE = -1;
GPE_ProjectFolder * CURRENT_PROJECT = NULL;
GPE_Sprite * GPE_RadioButton_GFX = NULL;

GPE_Template * GPE_MAIN_TEMPLATE = NULL;

GPE_Template * GPE_CUSTOM_TEMPLATE = NULL;
GPE_Template * GPE_DEFAULT_TEMPLATE = NULL;

GPE_Template * GPE_DARK_TEMPLATE = NULL;
GPE_Template * GPE_LIGHT_TEMPLATE = NULL;
GPE_Template * GPE_RED_TEMPLATE = NULL;
GPE_Template * GPE_GREEN_TEMPLATE = NULL;
GPE_Template * GPE_BLUE_TEMPLATE = NULL;

GPE_Gui_Engine * GPE_MAIN_GUI = NULL;

gamePencilEditorSettingsResource * MAIN_EDITOR_SETTINGS = NULL;
gamePencilAboutPageResource * MAIN_ABOUT_PAGE = NULL;
gamePencilHelpPageResource * MAIN_HELP_PAGE = NULL;
gamePencilStartPageResource * MAIN_START_PAGE = NULL;
gamePencilProjectBrowserResource * PROJECT_BROWSER_PAGE = NULL;

GPE_Gui_Engine_MiniCompiler * GPE_MINI_COMPILER = NULL;
GPE_PopUpMenu_Option * MAIN_CONTEXT_MENU = NULL;
GPE_PopUpMenu_Option * MAIN_TOOLBAR_RECENT_PROJECTS = NULL;
GPE_StatusBar * GPE_Main_Statusbar = NULL;
GPE_TabManager * GPE_Main_TabManager = NULL;
GPE_LogManager * GPE_Main_Logs = NULL;
GPE_Font * font = NULL;
GPE_Font * textboxFont = NULL;
GPE_Font * FONT_CATEGORY_BAR = NULL;
//
GPE_Font * DEFAULT_FONT = NULL;
GPE_Font * FONT_POPUP = NULL;
GPE_Font * FONT_TOOLBAR = NULL;
GPE_Font * FONT_RESOURCEBAR = NULL;
GPE_Font * FONT_TEXTINPUT = NULL;
GPE_Font * FONT_TEXTINPUT_COMMENT = NULL;
GPE_Font * FONT_TEXTINPUT_KEYWORD = NULL;
GPE_Font * FONT_TEXTINPUT_FUNCTION = NULL;
GPE_Font * FONT_TEXTINPUT_NUMBER = NULL;
GPE_Font * FONT_TEXTINPUT_QUOTE = NULL;
GPE_Font * FONT_TEXTINPUT_BOLD = NULL;
GPE_Font * FONT_TEXTINPUT_SYMBOL = NULL;
GPE_Font * FONT_TEXTINPUT_PROJECT_FUNCTION = NULL;
GPE_Font * FONT_TEXTINPUT_PROJECT_KEYWORD = NULL;

GPE_Font * FONT_TERM_NAME = NULL;
GPE_Font * FONT_TERM_DESCRIPTION = NULL;
GPE_Font * FONT_TERM_SCOPE = NULL;
GPE_Font * FONT_TOOLTIP = NULL;

GPE_Font * FONT_DEFAULT_PROMPT = NULL;
GPE_Font * FONT_CHECKBOX = NULL;
GPE_Font * FONT_PARAGRAGH = NULL;
GPE_Font * FONT_LABEL = NULL;
GPE_Font * FONT_LABEL_ANCHOR = NULL;
GPE_Font * FONT_LABEL_PARAGRAPH = NULL;
GPE_Font * FONT_STATUSBAR = NULL;
GPE_Font * FONT_HEADER = NULL;
GPE_Font * FONT_LABEL_TITLE = NULL;
std::string GPE_Action_Message = "";
int GPE_Action_ID = -1;
bool GPE_ACTION_IS_CONTEXT = false;

generalGameResource * SELECTED_GENERAL_RESOUCE = NULL;
GPE_ResourceContainer * RESOURCE_TO_DRAG = NULL;
GPE_ResourceContainer * LAST_CLICKED_RESOURCE = NULL;
bool RESOURCEMENU_WAS_RIGHTCLICKED = false;
GPE_ResourceContainer * RESOURCE_BEINGRENAMED = NULL;

int LAST_CLICKED_RESTYPE = -1;
int DRAGGED_RESTYPE = -1;

std::string CURRENT_PROJECT_NAME = "";

GPE_Texture * GPE_LOGO = NULL;
GPE_Texture * GPE_TEXTURE_TRANSPARENT_BG = NULL;
GPE_Texture * GPE_TEXTURE_COLOR_PICKER_GRADIENT = NULL;
SDL_Surface * GPE_SURFACE_COLOR_PICKER_GRADIENT = NULL;
GPE_Texture * GPE_CHECKMARK_IMAGE = NULL;
GPE_Sprite  * GPE_TRIANGLE = NULL;

std::string PROJECT_LANGUAGE_NAMES[PROJECT_LANGUAGE_MAX];
std::string RESOURCE_TYPE_NAMES[res_type_count];
std::string GPE_BUILD_NAMES[GPE_BUILD_OPTIONS];

std::string spriteDataLabels[SPRITE_DATA_FIELD_COUNT];
int spriteDataLabelWidth;

std::string tsDataLabels[TILESHEET_DATA_FIELD_COUNT];
int tsDataLabelWidth;

std::string SUPPORTED_AUDIO_EXT[SUPPORTED_AUDIO_FORMAT_COUNT];
std::string SUPPORTED_VIDEO_EXT[SUPPORTED_VIDEO_FORMAT_COUNT];
std::string SUPPORTED_FONT_EXT[FONT_FILE_TYPES];

std::string DEFAULT_OBJECT_FUNCTIONS_NAMES[DEFAULT_OBJECT_FUNCTIONS_COUNT];

std::string DEFAULT_OBJECT_SPECIALS_NAMES[DEFAULT_SPECIAL_FUNCTIONS_COUNT];

std::string DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[DEFAULT_OBJECT_FUNCTIONS_COUNT];
std::string DEFAULT_OBJECT_SPECIALS_HTML5_NAMES[DEFAULT_SPECIAL_FUNCTIONS_COUNT];

std::string DEFAULT_SCENE_SUBEDITOR_NAMES[5];
SDL_Cursor * GPE_Cursor = NULL;
SDL_Cursor * GPE_LoadingCursor = NULL;
SDL_Cursor * GPE_HoverCursor = NULL;
bool GPE_IS_LOADING = false;

SDL_SystemCursor GPE_PreviousCursor = SDL_SYSTEM_CURSOR_WAIT;
SDL_SystemCursor GPE_CurrentCursor = SDL_SYSTEM_CURSOR_ARROW;

std::string displayMessageTitle = "";
std::string displayMessageSubtitle = "";
std::string displayMessageString = "";

void GPE_change_cursor(SDL_SystemCursor id)
{
    GPE_CurrentCursor = id;
}

bool load_fonts()
{
    std::string mainGuiFontLocation = APP_DIRECTORY_NAME+"resources/fonts/dejavu_sans_mono/DejaVuSansMono.ttf";
    std::string textEditorFontLocation = APP_DIRECTORY_NAME+"resources/fonts/dejavu_sans_mono/DejaVuSansMono.ttf";
    bool fontIsMonoSpaced = true;

    if( file_exists("C:/Windows/Fonts/Arial.ttf") )
    {
        mainGuiFontLocation = "C:/Windows/Fonts/Arial.ttf";
        fontIsMonoSpaced = false;
    }
    else if( file_exists("C:/Windows/Fonts/Carlito.ttf") )
    {
        mainGuiFontLocation = "C:/Windows/Fonts/Carlito.ttf";
        fontIsMonoSpaced = false;
    }
    else if( file_exists("C:/Windows/Fonts/Candara.ttf") )
    {
        mainGuiFontLocation = "C:/Windows/Fonts/Candara.ttf";
        fontIsMonoSpaced = false;
    }

    //Open the fonts
    font = GPE_OpenFont( mainGuiFontLocation, 24,fontIsMonoSpaced, "Generic Font");
    textboxFont = GPE_OpenFont( mainGuiFontLocation, 24,fontIsMonoSpaced, "textboxFont");
    FONT_CATEGORY_BAR = GPE_OpenFont( mainGuiFontLocation, 14,fontIsMonoSpaced , "FONT_CATEGORY_BAR");

    LAST_USED_FONT = GPE_OpenFont(mainGuiFontLocation,24,fontIsMonoSpaced, "LAST_USED_FONT");
    DEFAULT_FONT = GPE_OpenFont(mainGuiFontLocation,14,fontIsMonoSpaced, "DEFAULT_FONT");

    FONT_POPUP = GPE_OpenFont(mainGuiFontLocation,14,fontIsMonoSpaced, "FONT_POPUP");
    FONT_TOOLBAR = GPE_OpenFont(mainGuiFontLocation,14,fontIsMonoSpaced, "FONT_TOOLBAR");
    FONT_RESOURCEBAR = GPE_OpenFont(textEditorFontLocation,12,fontIsMonoSpaced, "FONT_RESOURCEBAR");

    FONT_TEXTINPUT = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_GENERAL");
    FONT_TEXTINPUT_COMMENT = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_COMMENT");
    FONT_TEXTINPUT_KEYWORD = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_KEYWORD");
    FONT_TEXTINPUT_FUNCTION = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_FUNCTION");
    FONT_TEXTINPUT_NUMBER = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_NUMBER");
    FONT_TEXTINPUT_QUOTE = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_QUOTE");
    FONT_TEXTINPUT_SYMBOL = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_SYMBOL");
    FONT_TEXTINPUT_PROJECT_FUNCTION = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_PROJECT_FUNCTION");
    FONT_TEXTINPUT_PROJECT_KEYWORD = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TEXTINPUT_PROJECT_KEYWORD");

    FONT_TERM_NAME = GPE_OpenFont(textEditorFontLocation,11,true, "FONT_TERM_NAME");
    FONT_TERM_DESCRIPTION = GPE_OpenFont(textEditorFontLocation,11,true, "FONT_TERM_DESCRIPTION");
    FONT_TERM_SCOPE = GPE_OpenFont(textEditorFontLocation,11,true, "FONT_TERM_SCOPE");
    FONT_TOOLTIP = GPE_OpenFont(textEditorFontLocation,12,true, "FONT_TOOLTIP");

    FONT_DEFAULT_PROMPT = GPE_OpenFont(textEditorFontLocation,16,true, "FONT_DEFAULT_PROMPT");
    FONT_CHECKBOX = GPE_OpenFont(mainGuiFontLocation,12,fontIsMonoSpaced, "FONT_CHECKBOX");

    FONT_HEADER = GPE_OpenFont( mainGuiFontLocation, 18,fontIsMonoSpaced , "FONT_HEADER");
    FONT_LABEL = GPE_OpenFont( mainGuiFontLocation, 14,fontIsMonoSpaced , "FONT_LABEL");
    FONT_LABEL_ANCHOR = GPE_OpenFont( mainGuiFontLocation, 14,fontIsMonoSpaced , "FONT_LABEL_ANCHOR");
    FONT_LABEL_TITLE = GPE_OpenFont( mainGuiFontLocation, 24,fontIsMonoSpaced , "FONT_LABEL_TITLE");
    FONT_PARAGRAGH = GPE_OpenFont( textEditorFontLocation, 14,true, "FONT_PARAGRAGH" );
    FONT_STATUSBAR = GPE_OpenFont( textEditorFontLocation, 12,true, "FONT_STATUSBAR" );

    if(DEFAULT_FONT==NULL || LAST_USED_FONT==NULL)
    {
        record_error("Unable to load default fonts");
        return false;
    }

    if(FONT_TOOLBAR==NULL)
    {
        record_error("Unable to load TOOLLBAR font");
        return false;

    }

    if(FONT_TEXTINPUT==NULL)
    {
        record_error("Unable to load INPUT-FIELD font");
        return false;
    }
    return true;
}

void cleanup_fonts()
{
    //Close the fonts that was used
    if( font!=NULL)
    {
        GPE_CloseFont(font);
        font = NULL;
    }

    if( textboxFont!=NULL)
    {
        GPE_CloseFont( textboxFont );
        textboxFont = NULL;
    }

    if( FONT_CATEGORY_BAR!=NULL)
    {
        GPE_CloseFont( FONT_CATEGORY_BAR );
        FONT_CATEGORY_BAR = NULL;
    }
    //
    if( DEFAULT_FONT!=NULL)
    {
        GPE_CloseFont(DEFAULT_FONT);
        DEFAULT_FONT = NULL;
    }

    if( FONT_POPUP!=NULL)
    {
        GPE_CloseFont( FONT_POPUP );
        FONT_POPUP = NULL;
    }

    if( FONT_TOOLBAR!=NULL)
    {
        GPE_CloseFont( FONT_TOOLBAR );
        FONT_TOOLBAR = NULL;
    }
    if( FONT_RESOURCEBAR!=NULL)
    {
        GPE_CloseFont( FONT_RESOURCEBAR );
        FONT_RESOURCEBAR = NULL;
    }
    //
    if( FONT_TEXTINPUT!=NULL)
    {
        GPE_CloseFont(FONT_TEXTINPUT);
        FONT_TEXTINPUT = NULL;
    }

    if( FONT_TERM_NAME!=NULL)
    {
        GPE_CloseFont(FONT_TERM_NAME);
        FONT_TERM_NAME = NULL;
    }

    if( FONT_TERM_DESCRIPTION!=NULL)
    {
        GPE_CloseFont(FONT_TERM_DESCRIPTION);
        FONT_TERM_DESCRIPTION = NULL;
    }

    if( FONT_TERM_SCOPE!=NULL)
    {
        GPE_CloseFont(FONT_TERM_SCOPE);
        FONT_TERM_SCOPE = NULL;
    }
    if( FONT_DEFAULT_PROMPT!=NULL)
    {
        GPE_CloseFont(FONT_DEFAULT_PROMPT);
        FONT_DEFAULT_PROMPT = NULL;
    }

    if( FONT_CHECKBOX!=NULL)
    {
        GPE_CloseFont( FONT_CHECKBOX );
        FONT_CHECKBOX = NULL;
    }
    //
    if( FONT_HEADER!=NULL)
    {
        GPE_CloseFont( FONT_HEADER );
        FONT_HEADER = NULL;
    }

    if( FONT_LABEL!=NULL)
    {
        GPE_CloseFont( FONT_LABEL );
        FONT_LABEL = NULL;
    }
    if( FONT_LABEL_ANCHOR!=NULL)
    {
        GPE_CloseFont( FONT_LABEL_ANCHOR );
        FONT_LABEL_ANCHOR = NULL;
    }

    if( FONT_LABEL_PARAGRAPH!=NULL)
    {
        GPE_CloseFont( FONT_LABEL_PARAGRAPH );
        FONT_LABEL_PARAGRAPH = NULL;
    }

    if( FONT_LABEL_TITLE!=NULL)
    {
        GPE_CloseFont( FONT_LABEL_TITLE );
        FONT_LABEL_TITLE = NULL;
    }

    if( FONT_PARAGRAGH!=NULL)
    {
        GPE_CloseFont( FONT_PARAGRAGH );
        FONT_PARAGRAGH = NULL;
    }
}

GPE_Color * GPE_Get_Color_PopUp(std::string popUpCaption ,GPE_Color * currColor)
{
    RESOURCE_TO_DRAG = NULL;
    if( (int)popUpCaption.size() ==0)
    {
        popUpCaption = "Select a Color";
    }
    GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);

    int promptBoxWidth = 500;
    int promptBoxHeight = 400;
    SDL_Rect barBox;
    SDL_Rect colorShadeBox;
    colorShadeBox.w = 32;
    colorShadeBox.h = 200;

    bool exitOperation = false;
    bool operationCancelled = false;
    userInput->reset_all_input();
    GPE_Color * returnedColor = NULL, *colorShadeTempColor = NULL;
    colorShadeTempColor = new GPE_Color();
    int rV = 0,  gV = 0,  bV = 0;
    Uint8 rU8 = 0, gU8 = 0, bU8 = 0;
    Uint32 foundPixelColor = 0;
    int foundColorPickerX = 0, foundColorPickerY = 0;
    int colorPickerShaderI = 0;
    //float colorShadeDifference = 0;
    float colorShadeDivision = 0;
    int selectedColorShade = colorShadeBox.h/2;
    GPE_TextInputNumber * newColorRValue = new GPE_TextInputNumber("",true,0,255);
    newColorRValue->set_label("Red");
    GPE_TextInputNumber * newColorGValue = new GPE_TextInputNumber("",true,0,255);
    newColorGValue->set_label("Green");
    GPE_TextInputNumber * newColorBValue = new GPE_TextInputNumber("",true,0,255);
    newColorBValue->set_label("Blue");

    GPE_TextInputNumber * newColorHValue = new GPE_TextInputNumber("",true,0,240);
    newColorHValue->set_label("Hue");
    GPE_TextInputNumber * newColorSValue = new GPE_TextInputNumber("",true,0,240);
    newColorSValue->set_label("Sat");
    GPE_TextInputNumber * newColorLValue = new GPE_TextInputNumber("",true,0,240);
    newColorLValue->set_label("Lum");


    GPE_TextInputBasic * newColorHexValue = new GPE_TextInputBasic("#FFFFFF");
    newColorHexValue->set_label("Hex: #");

    if(currColor!=NULL)
    {
        returnedColor = new GPE_Color(currColor->get_r(),currColor->get_g(),currColor->get_b() );
        newColorRValue->set_string( int_to_string( currColor->get_r() ) );
        newColorGValue->set_string( int_to_string( currColor->get_g() ) );
        newColorBValue->set_string( int_to_string( currColor->get_b() ) );
        newColorHexValue->set_string( RGBtoHEX(currColor->get_r(),currColor->get_g(),currColor->get_b() ) ); //Convert RGB to Hex here
    }
    else
    {
        returnedColor = new GPE_Color(0,0,0);
        newColorHexValue->set_string("#000000");
    }
    GPE_ToolLabelButton * yesButton = new GPE_ToolLabelButton(0,16,"Okay","Confirm Color Change");
    GPE_ToolLabelButton * cancelButton = new GPE_ToolLabelButton(0,16,"Cancel","Cancel Color Request");

    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
    //currentState->render();
    MAIN_RENDERER->update_renderer();
    while(exitOperation==false)
    {
        //Start the frame timer
        capTimer->start();
        //gets user input
        userInput->handle(true,true);
        GPE_MAIN_GUI->reset_gui_info();

        barBox.x = (SCREEN_WIDTH-promptBoxWidth)/2;
        barBox.y = (SCREEN_HEIGHT-promptBoxHeight)/2;
        barBox.w = promptBoxWidth;
        barBox.h = promptBoxHeight;

        colorShadeBox.x = barBox.x+GENERAL_GPE_PADDING*2+200;
        colorShadeBox.y = barBox.y+GENERAL_GPE_PADDING+32;

        GPE_MAIN_GUI->reset_gui_info();
        yesButton->set_coords( barBox.x+GENERAL_GPE_PADDING, barBox.y+barBox.h-32);
        cancelButton->set_coords( yesButton->get_xpos()+yesButton->get_width()+GENERAL_GPE_PADDING,yesButton->get_ypos() );

        newColorRValue->set_coords(colorShadeBox.x+colorShadeBox.w+GENERAL_GPE_PADDING,barBox.y+GENERAL_GPE_PADDING+48);
        newColorRValue->set_width(128);

        newColorGValue->set_coords(colorShadeBox.x+colorShadeBox.w+GENERAL_GPE_PADDING,newColorRValue->get_ypos()+newColorRValue->get_height()+GENERAL_GPE_PADDING);
        newColorGValue->set_width(128);

        newColorBValue->set_coords(colorShadeBox.x+colorShadeBox.w+GENERAL_GPE_PADDING,newColorGValue->get_ypos()+newColorGValue->get_height()+GENERAL_GPE_PADDING);
        newColorBValue->set_width(128);

        newColorHexValue->set_coords(colorShadeBox.x+colorShadeBox.w+GENERAL_GPE_PADDING,newColorBValue->get_ypos()+newColorBValue->get_height()+GENERAL_GPE_PADDING);
        newColorHexValue->set_width(128);

        yesButton->process_self(&camera,&camera);
        cancelButton->process_self(&camera,&camera);
        newColorRValue->process_self(&camera,&camera);
        newColorGValue->process_self(&camera,&camera);
        newColorBValue->process_self(&camera,&camera);
        newColorHexValue->process_self(&camera, &camera);
        if( newColorRValue->is_inuse() || newColorGValue->is_inuse() || newColorBValue->is_inuse() )
        {
            returnedColor->change_rgba(newColorRValue->get_held_number(),newColorGValue->get_held_number(),newColorBValue->get_held_number(),255 );
            newColorHexValue->set_string( RGBtoHEX(returnedColor->get_r(),returnedColor->get_g(),returnedColor->get_b() ) ); //Convert RGB to Hex here
        }
        else if( newColorHexValue->is_inuse() )
        {
            //convert hex to rgb is possibre
            HEXtoRGB(newColorHexValue->get_string(),rV,gV,bV);
            newColorRValue->set_number(rV);
            newColorGValue->set_number(gV);
            newColorBValue->set_number(bV);
            returnedColor->change_rgba(newColorRValue->get_held_number(),newColorGValue->get_held_number(),newColorBValue->get_held_number(),255 );
            //newColorHexValue->set_string( RGBtoHEX(currColor->get_r(),currColor->get_g(),currColor->get_b() ) ); //Convert RGB to Hex here
        }
        if( userInput->check_keyboard_released(kb_esc) || cancelButton->is_clicked() || WINDOW_WAS_JUST_RESIZED )
        {
            exitOperation = true;
            operationCancelled = true;
        }
        else if( userInput->check_keyboard_released(kb_enter) || yesButton->is_clicked() )
        {
            exitOperation = true;
        }
        else if( userInput->check_mouse_down(0) )
        {
            if( point_within(userInput->mouse_x,userInput->mouse_y,
                             barBox.x+GENERAL_GPE_PADDING,barBox.y+032+GENERAL_GPE_PADDING,
                             barBox.x+200+GENERAL_GPE_PADDING,barBox.y+232+GENERAL_GPE_PADDING) )
            {
                //Gets "clicked color"
                foundColorPickerX = userInput->mouse_x-barBox.x-GENERAL_GPE_PADDING;
                foundColorPickerY = userInput->mouse_y-barBox.y-32-GENERAL_GPE_PADDING;
                foundPixelColor = get_pixel32(GPE_SURFACE_COLOR_PICKER_GRADIENT,foundColorPickerX , foundColorPickerY );

                SDL_GetRGB(foundPixelColor,GPE_SURFACE_COLOR_PICKER_GRADIENT->format,&rU8,&gU8,&bU8);
                //sets new color to picked color
                rV = (int)rU8;
                gV = (int)gU8;
                bV = (int)bU8;
                //rV = foundPixelColor & 0xff;
                //gV =(foundPixelColor >> 8) & 0xff;
                //bV =(foundPixelColor >> 16) & 0xff;
                /*
                newColorRValue->set_number(rV);
                newColorGValue->set_number(gV);
                newColorBValue->set_number(bV);*/

                colorShadeDivision = (float)selectedColorShade/(float)colorShadeBox.h;

                newColorRValue->set_number( merge_channel(rV ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );
                newColorGValue->set_number( merge_channel(gV ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );
                newColorBValue->set_number( merge_channel(bV ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );
                returnedColor->change_rgba(newColorRValue->get_held_number(),newColorGValue->get_held_number(),newColorBValue->get_held_number(),255 );
                newColorHexValue->set_string( RGBtoHEX(returnedColor->get_r(),returnedColor->get_g(),returnedColor->get_b() ) ); //Convert RGB to Hex here
            }

        }
        else if( userInput->check_mouse_released(0) )
        {
            if( point_within_rect(userInput->mouse_x,userInput->mouse_y,&colorShadeBox) )
            {
                selectedColorShade = userInput->mouse_y - colorShadeBox.y;

                colorShadeDivision = (float)selectedColorShade/(float)colorShadeBox.h;

                newColorRValue->set_number( merge_channel(returnedColor->get_r() ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );
                newColorGValue->set_number( merge_channel(returnedColor->get_g() ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );
                newColorBValue->set_number( merge_channel(returnedColor->get_b() ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );

                returnedColor->change_rgba(newColorRValue->get_held_number(),newColorGValue->get_held_number(),newColorBValue->get_held_number(),255 );
                newColorHexValue->set_string( RGBtoHEX(returnedColor->get_r(),returnedColor->get_g(),returnedColor->get_b() ) ); //Convert RGB to Hex here

            }
        }

        calculate_avg_fps();
        if( !WINDOW_WAS_JUST_RESIZED)
        {
            GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);

            //Update screen
            render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);
            render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
            if( GPE_TEXTURE_COLOR_PICKER_GRADIENT!=NULL)
            {
                render_texture_resized(MAIN_RENDERER,GPE_TEXTURE_COLOR_PICKER_GRADIENT,barBox.x+GENERAL_GPE_PADDING,barBox.y+32+GENERAL_GPE_PADDING,200,200);
            }
            int preiewColorYPos = yesButton->get_ypos()-GENERAL_GPE_PADDING-64;

            render_rect(MAIN_RENDERER,&colorShadeBox,GPE_MAIN_TEMPLATE->Program_Color,false);
            render_rect(MAIN_RENDERER,&colorShadeBox,GPE_MAIN_TEMPLATE->Main_Border_Color,true);

            for( colorPickerShaderI = 0; colorPickerShaderI <= colorShadeBox.h; colorPickerShaderI++)
            {
                colorShadeDivision = (float)colorPickerShaderI/(float)colorShadeBox.h;
                colorShadeTempColor->change_r( merge_channel(returnedColor->get_r() ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );
                colorShadeTempColor->change_g( merge_channel(returnedColor->get_g() ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );
                colorShadeTempColor->change_b( merge_channel(returnedColor->get_b() ,(float)( -colorShadeDivision+1.f)*255.f,(float) fabs( colorShadeDivision-0.5f)+0.5 ) );

                render_horizontal_line_color(MAIN_RENDERER,colorShadeBox.y+colorPickerShaderI,colorShadeBox.x,colorShadeBox.x+colorShadeBox.w,colorShadeTempColor);
            }
            render_horizontal_line_color(MAIN_RENDERER,colorShadeBox.y+selectedColorShade,colorShadeBox.x-4,colorShadeBox.x+colorShadeBox.w+4,GPE_MAIN_TEMPLATE->Main_Border_Color );


            if( currColor!=NULL)
            {
                preiewColorYPos = yesButton->get_ypos()-GENERAL_GPE_PADDING-40;
                render_new_text(MAIN_RENDERER,barBox.x+GENERAL_GPE_PADDING,preiewColorYPos,"Older Color:",GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP);
                render_rectangle(MAIN_RENDERER,barBox.x+128,preiewColorYPos,barBox.x+256,preiewColorYPos+32,currColor,false);

                preiewColorYPos = yesButton->get_ypos()-GENERAL_GPE_PADDING-80;
                render_new_text(MAIN_RENDERER,barBox.x+GENERAL_GPE_PADDING,preiewColorYPos,"New Color:",GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP);
                render_rectangle(MAIN_RENDERER,barBox.x+128,preiewColorYPos,barBox.x+256,preiewColorYPos+32,returnedColor,false);
            }
            else
            {
                preiewColorYPos = yesButton->get_ypos()-GENERAL_GPE_PADDING-40;
                render_new_text(MAIN_RENDERER,barBox.x+GENERAL_GPE_PADDING,preiewColorYPos,"New Color:",GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP);
                render_rectangle(MAIN_RENDERER,barBox.x+128,preiewColorYPos,barBox.x+256,preiewColorYPos+32,returnedColor,false);
            }
            render_rectangle(MAIN_RENDERER,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+32,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);
            render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
            render_new_text(MAIN_RENDERER,barBox.x+barBox.w/2,barBox.y+GENERAL_GPE_PADDING,popUpCaption,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,DEFAULT_FONT,FA_CENTER,FA_TOP);
            yesButton->render_self(MAIN_RENDERER,&camera,&camera);
            cancelButton->render_self(MAIN_RENDERER,&camera,&camera);
            newColorRValue->render_self(MAIN_RENDERER,&camera, &camera);
            newColorGValue->render_self(MAIN_RENDERER,&camera, &camera);
            newColorBValue->render_self(MAIN_RENDERER,&camera, &camera);
            newColorHexValue->render_self(MAIN_RENDERER,&camera, &camera);
            //GPE_MAIN_GUI->render_tooltip(MAIN_RENDERER);
            GPE_MAIN_GUI->process_cursor();
            GPE_MAIN_GUI->render_gui_info(MAIN_RENDERER, true);
            MAIN_RENDERER->update_renderer();
        }
        cap_fps();
    }
    if( yesButton!=NULL)
    {
        delete yesButton;
        yesButton = NULL;
    }
    if( cancelButton!=NULL)
    {
        delete cancelButton;
        cancelButton = NULL;
    }
    if( newColorRValue!=NULL)
    {
        delete newColorRValue;
        newColorRValue = NULL;
    }
    if( newColorGValue!=NULL)
    {
        delete newColorGValue;
        newColorGValue = NULL;
    }
    if( newColorBValue!=NULL)
    {
        delete newColorBValue;
        newColorBValue = NULL;
    }
    if( newColorHexValue!=NULL)
    {
        delete newColorHexValue;
        newColorHexValue = NULL;
    }
    if( colorShadeTempColor!=NULL)
    {
        delete colorShadeTempColor;
        colorShadeTempColor = NULL;
    }
    if( operationCancelled)
    {
        if( returnedColor!=NULL)
        {
            delete returnedColor;
            returnedColor = NULL;
            return NULL;
        }
    }
    else
    {
        return returnedColor;
    }
    return NULL;
}

void GPE_Show_Tip_Of_Day()
{
    RESOURCE_TO_DRAG = NULL;
    if( GPE_MAIN_GUI!=NULL && MAIN_RENDERER!=NULL)
    {
        record_error("Showing tip of the day");
        std::string popUpCaption = "Tip of the Day";
        GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
        GPE_MAIN_GUI->process_cursor();
        GPE_MAIN_GUI->reset_gui_info();
        GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);

        int promptBoxWidth = 544;
        int promptBoxHeight = 384;
        SDL_Rect barBox;

        bool exitOperation = false;
        userInput->reset_all_input();
        int currentTipId = GPE_MAIN_GUI->get_random_tip();
        if( currentTipId < 0 || currentTipId > GPE_MAIN_GUI->get_tip_count() )
        {
            currentTipId = 0;
        }
        std::string currentTipString = GPE_MAIN_GUI->get_tip(currentTipId);

        GPE_Label_Title * doYouKnowLabel = new GPE_Label_Title("Do you know?","Do you know?");
        GPE_GuiElementList * showTipList = new GPE_GuiElementList();
        GPE_ToolLabelButton * closeButton = new GPE_ToolLabelButton(0,16,"Close","");
        GPE_ToolLabelButton * nextTipButton = new GPE_ToolLabelButton(0,16,"Next Tip","");
        GPE_ToolLabelButton * previousTipButton = new GPE_ToolLabelButton(0,16,"Previous Tip","");
        GPE_CheckBoxBasic * showAtStartUpButton = new GPE_CheckBoxBasic("Show tips at startup","Unclick to not see this popup automatically on start");
        showAtStartUpButton->set_clicked( GPE_MAIN_GUI->showTipsAtStartUp);
        GPE_ToolLabelButton * randomTipButton = new GPE_ToolLabelButton(0,16,"Random Tip","");
        GPE_WrappedTextArea * tipParagraph = new GPE_WrappedTextArea();
        tipParagraph->set_string(currentTipString);
        tipParagraph->set_width(512-GENERAL_GPE_PADDING*2);
        tipParagraph->set_height(96);
        SDL_RenderSetViewport(MAIN_RENDERER->get_renderer() ,NULL);
        //GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
        while(exitOperation==false)
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
            //record_error("Processing tip of the day");
            //Start the frame timer
            capTimer->start();
            //gets user input
            userInput->handle(true,true);

            barBox.x = (SCREEN_WIDTH-promptBoxWidth)/2;
            barBox.y = (SCREEN_HEIGHT-promptBoxHeight)/2;
            barBox.w = promptBoxWidth;
            barBox.h = promptBoxHeight;
            showTipList->set_coords(barBox.x, barBox.y+32);
            showTipList->set_width(barBox.w);
            showTipList->set_height(barBox.h-32);
            showTipList->barXMargin = GENERAL_GPE_PADDING;
            showTipList->barYMargin = GENERAL_GPE_PADDING;
            showTipList->barXPadding = GENERAL_GPE_PADDING*2;
            showTipList->barYPadding = GENERAL_GPE_PADDING*2;

            GPE_MAIN_GUI->reset_gui_info();
            showTipList->clear_list();
            showTipList->add_gui_element(doYouKnowLabel,true);
            showTipList->add_gui_element(tipParagraph,true);
            showTipList->add_gui_element(showAtStartUpButton, true);
            showTipList->add_gui_element(previousTipButton,false);
            showTipList->add_gui_element(nextTipButton,true);
            showTipList->add_gui_element(randomTipButton,false);
            showTipList->add_gui_element(closeButton,false);
            showTipList->process_self(&camera,&camera);
            if( userInput->check_keyboard_released(kb_esc) || closeButton->is_clicked() || WINDOW_WAS_JUST_RESIZED )
            {
                exitOperation = true;
            }
            else if( nextTipButton->is_clicked() )
            {
                currentTipId = GPE_MAIN_GUI->get_next_tip(currentTipId);
                currentTipString = GPE_MAIN_GUI->get_tip(currentTipId);
                tipParagraph->set_string(currentTipString);
            }
            else if( previousTipButton->is_clicked() )
            {
                currentTipId = GPE_MAIN_GUI->get_previous_tip(currentTipId);
                currentTipString = GPE_MAIN_GUI->get_tip(currentTipId);
                tipParagraph->set_string(currentTipString);
            }
            else if( randomTipButton->is_clicked() )
            {
                currentTipId = GPE_MAIN_GUI->get_random_tip();
                currentTipString = GPE_MAIN_GUI->get_tip(currentTipId);
                tipParagraph->set_string(currentTipString);
            }

            calculate_avg_fps();
            //record_error("Rendering tip of the day");
            SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
            if( !WINDOW_WAS_JUST_RESIZED)
            {
                //if( userInput->windowEventHappendInFrame )
                {
                    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
                }
                //Update screen
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);

                render_rectangle(MAIN_RENDERER,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+32,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,true);
                render_new_text(MAIN_RENDERER,barBox.x+barBox.w/2,barBox.y+GENERAL_GPE_PADDING,popUpCaption,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,DEFAULT_FONT,FA_CENTER,FA_TOP);
                showTipList->render_self(MAIN_RENDERER,&camera, &camera);
                //GPE_MAIN_GUI-render_gui_info(MAIN_RENDERER, true);

                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
                GPE_MAIN_GUI->process_cursor();
                GPE_MAIN_GUI->render_gui_info(MAIN_RENDERER, true);
                MAIN_RENDERER->update_renderer();
            }
            cap_fps();
        }
        if( showTipList!=NULL)
        {
            delete showTipList;
            showTipList = NULL;
        }

        if( doYouKnowLabel!=NULL)
        {
            delete doYouKnowLabel;
            doYouKnowLabel = NULL;
        }
        if( closeButton!=NULL)
        {
            delete closeButton;
            closeButton = NULL;
        }
        if( nextTipButton!=NULL)
        {
            delete nextTipButton;
            nextTipButton = NULL;
        }
        if( previousTipButton!=NULL)
        {
            delete previousTipButton;
            previousTipButton = NULL;
        }
        if( randomTipButton!=NULL)
        {
            delete randomTipButton;
            randomTipButton = NULL;
        }
        if( showAtStartUpButton!=NULL)
        {
            GPE_MAIN_GUI->showTipsAtStartUp = showAtStartUpButton->is_clicked();
            GPE_MAIN_GUI->save_settings();
            delete showAtStartUpButton;
            showAtStartUpButton = NULL;
        }
        if( tipParagraph!=NULL)
        {
            delete tipParagraph;
            tipParagraph = NULL;
        }
    }
    userInput->reset_all_input();
    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
    MAIN_RENDERER->update_renderer();
}

bool GPE_Open_Support_Center()
{
    RESOURCE_TO_DRAG = NULL;
    bool requestSubmitted = false;
    if( GPE_MAIN_GUI!=NULL && MAIN_RENDERER!=NULL)
    {
        record_error("Starting GPE Support Center");
        std::string popUpCaption = "GPE Support Center";
        GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
        GPE_MAIN_GUI->process_cursor();
        GPE_MAIN_GUI->reset_gui_info();
        GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);

        int promptBoxWidth = 544;
        int promptBoxHeight = 512;
        SDL_Rect barBox;

        bool exitOperation = false;
        bool validInputFound = false;
        userInput->reset_all_input();
        int currentTipId = GPE_MAIN_GUI->get_random_tip();
        if( currentTipId < 0 || currentTipId > GPE_MAIN_GUI->get_tip_count() )
        {
            currentTipId = 0;
        }
        std::string currentTipString = GPE_MAIN_GUI->get_tip(currentTipId);

        GPE_Label_Error * errorlabel = new GPE_Label_Error("Please fill out all forms.","Please fill out all forms.");
        GPE_TextInputBasic * nameField = new GPE_TextInputBasic("","Name");
        nameField->set_label("Your Name:");

        GPE_TextInputBasic * titleField = new GPE_TextInputBasic("","Bug Title");
        titleField->set_label("Bug Title:");

        GPE_TextInputBasic * emailField = new GPE_TextInputBasic("","Email");
        emailField->set_label("Your Email:");

        GPE_TextURL * gitLabLink = new GPE_TextURL("Open Issues On Gitlab","Visit our Gitlab Report area","https://gitlab.com/pawbyte/Game-Pencil-Engine");
        GPE_GuiElementList * mainList = new GPE_GuiElementList();
        GPE_ToolLabelButton * closeButton = new GPE_ToolLabelButton(0,16,"Close","");
        GPE_ToolLabelButton * submitButton = new GPE_ToolLabelButton(0,16,"Submit","");
        //GPE_CheckBoxBasic * showAtStartUpButton = new GPE_CheckBoxBasic("Show tips at startup","Unclick to not see this popup automatically on start");
        GPE_ToolLabelButton * randomTipButton = new GPE_ToolLabelButton(0,16,"Random Tip","");
        GPE_TextAreaInputBasic * reportTextArea = new GPE_TextAreaInputBasic();
        GPE_DropDown_Menu * reportType = new GPE_DropDown_Menu(0,0,"Issue",true);
        reportType->add_menu_option("Editor Issue");
        reportType->add_menu_option("HTML5 Engine Issue");
        reportType->add_menu_option("Windows Engine Issue");
        reportType->add_menu_option("OSX Engine Issue");
        reportType->add_menu_option("Linux Engine Issue");
        if( GPE_MAIN_GUI!=NULL)
        {
            if( GPE_MAIN_GUI->includeNintendoWiiUExport )
            {
                reportType->add_menu_option("Nintendo Wii U Engine Issue");
            }
            if( GPE_MAIN_GUI->includeNintendoSwitchExport )
            {
                reportType->add_menu_option("Nintendo Switch Engine Issue");
            }
            if( GPE_MAIN_GUI->includePlaystation4Export )
            {
                reportType->add_menu_option("PlayStation 4 Engine Issue");
            }
            if( GPE_MAIN_GUI->includeXboxOneExport )
            {
                reportType->add_menu_option("Xbox One Engine Issue");
            }
        }

        GPE_CheckBoxBasic * crashReportButton = new GPE_CheckBoxBasic("Crash Report","Is this a crash report?",0,0,false);

        reportTextArea->set_width(512-GENERAL_GPE_PADDING*2);
        reportTextArea->set_height(192);
        reportTextArea->isCodeEditor = false;
        SDL_RenderSetViewport(MAIN_RENDERER->get_renderer() ,NULL);

        std::string foundName = "";
        std::string foundTitle= "";
        std::string foundEmail = "";
        int atCharacterCount = 0;
        int atCharacterPos = 0;
        int lastDotCharacterPos = 0;
        //GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
        while(exitOperation==false && mainList!=NULL)
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
            //record_error("Processing tip of the day");
            //Start the frame timer
            capTimer->start();
            //gets user input
            userInput->handle(true,true);

            barBox.x = (SCREEN_WIDTH-promptBoxWidth)/2;
            barBox.y = (SCREEN_HEIGHT-promptBoxHeight)/2;
            barBox.w = promptBoxWidth;
            barBox.h = promptBoxHeight;
            mainList->set_coords(barBox.x, barBox.y+32);
            mainList->set_width(barBox.w);
            mainList->set_height(barBox.h-32);
            mainList->barXMargin = GENERAL_GPE_PADDING;
            mainList->barYMargin = GENERAL_GPE_PADDING;
            mainList->barXPadding = GENERAL_GPE_PADDING*2;
            mainList->barYPadding = GENERAL_GPE_PADDING*2;

            GPE_MAIN_GUI->reset_gui_info();
            mainList->clear_list();
            mainList->add_gui_element(errorlabel,true);
            mainList->add_gui_element(gitLabLink,true);
            mainList->add_gui_element(nameField,false);
            mainList->add_gui_element(emailField,true);
            mainList->add_gui_element(titleField,true);
            mainList->add_gui_element(reportTextArea,true);
            mainList->add_gui_element(crashReportButton,false);
            mainList->add_gui_element(reportType,true);
            mainList->add_gui_element(submitButton,false);
            mainList->add_gui_element(closeButton,false);
            mainList->process_self(&camera,&camera);
            if( userInput->check_keyboard_released(kb_esc) || closeButton->is_clicked() || WINDOW_WAS_JUST_RESIZED )
            {
                exitOperation = true;
            }
            else if( submitButton!=NULL && submitButton->is_clicked() )
            {
                if( nameField!=NULL &&  nameField->has_content() )
                {
                    foundName = trim_string( nameField->get_string(),' ' );
                    if( (int)foundName.size() > 0)
                    {
                        if( titleField!=NULL &&  titleField->has_content() )
                        {
                            foundTitle = trim_string( titleField->get_string(),' ' );
                            if( (int)foundTitle.size() > 0)
                            {
                                if( emailField!=NULL && emailField->has_content() )
                                {
                                    foundEmail = trim_string( emailField->get_string(),' ' );
                                    if( (int)foundEmail.size() > 5 )
                                    {
                                        atCharacterCount = string_count(foundEmail,"@");
                                        if( atCharacterCount ==1)
                                        {
                                            atCharacterPos = foundEmail.find('@');
                                            lastDotCharacterPos = foundEmail.find_last_of('.');
                                            if( atCharacterPos < lastDotCharacterPos-1 && lastDotCharacterPos < (int)foundEmail.size()-2 )
                                            {
                                                if( reportTextArea!=NULL)
                                                {
                                                    if( reportTextArea->has_content() )
                                                    {
                                                        validInputFound = true;
                                                    }
                                                    else
                                                    {
                                                        errorlabel->set_name("Empty report!");
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                errorlabel->set_name("Invalid email format detected!");
                                            }
                                        }
                                        else
                                        {
                                            errorlabel->set_name("Email missing @ symbol!");
                                        }
                                    }
                                    else
                                    {
                                        errorlabel->set_name("Email inputted is too short!");
                                    }
                                }
                                else
                                {
                                    errorlabel->set_name("Invalid email!");
                                }
                            }
                            else
                            {
                                errorlabel->set_name("Empty TITLE detected!");
                            }
                        }
                        else
                        {
                            errorlabel->set_name("Invalid TITLE!");
                        }
                    }
                    else
                    {
                        errorlabel->set_name("Empty name detected!");
                    }
                }
                else
                {
                    errorlabel->set_name("Invalid name!");
                }
                if( validInputFound)
                {
                    //Submit data
                    GPE_OpenURL("http://bugs.pawbyte.com/submit?title='"+foundTitle+"'&version="+double_to_string(GPE_VERSION_DOUBLE_NUMBER)+"&name='"+foundName+"'&email='"+foundEmail+"'&tags="+reportType->get_selected_name()+"&message='"+reportTextArea->get_string_spaces()+"'" );
                    errorlabel->set_name("Form Submitted to bugs.pawbyte.com");
                    requestSubmitted = true;
                }
                else
                {
                    foundName = "";
                    foundEmail = "";
                }
            }

            calculate_avg_fps();
            //record_error("Rendering tip of the day");
            SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
            if( !WINDOW_WAS_JUST_RESIZED)
            {
                //if( userInput->windowEventHappendInFrame )
                {
                    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
                }
                //Update screen
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);

                render_rectangle(MAIN_RENDERER,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+32,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,true);
                render_new_text(MAIN_RENDERER,barBox.x+barBox.w/2,barBox.y+GENERAL_GPE_PADDING,popUpCaption,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,DEFAULT_FONT,FA_CENTER,FA_TOP);
                mainList->render_self(MAIN_RENDERER,&camera, &camera);
                //GPE_MAIN_GUI-render_gui_info(MAIN_RENDERER, true);

                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
                GPE_MAIN_GUI->process_cursor();
                GPE_MAIN_GUI->render_gui_info(MAIN_RENDERER, true);
                MAIN_RENDERER->update_renderer();
            }
            cap_fps();
        }
        if( mainList!=NULL)
        {
            delete mainList;
            mainList = NULL;
        }
        if( errorlabel!=NULL)
        {
            delete errorlabel;
            errorlabel = NULL;
        }
        if( gitLabLink!=NULL)
        {
            delete gitLabLink;
            gitLabLink = NULL;
        }
        if( reportType!=NULL)
        {
            delete reportType;
            reportType = NULL;
        }
        if( crashReportButton!=NULL)
        {
            delete crashReportButton;
            crashReportButton = NULL;
        }
        if( closeButton!=NULL)
        {
            delete closeButton;
            closeButton = NULL;
        }
        if( nameField!=NULL)
        {
            delete nameField;
            nameField = NULL;
        }
        if( titleField!=NULL)
        {
            delete titleField;
            titleField = NULL;
        }
        if( emailField!=NULL)
        {
            delete emailField;
            emailField = NULL;
        }
        if( reportTextArea!=NULL)
        {
            delete reportTextArea;
            reportTextArea = NULL;
        }
    }
    userInput->reset_all_input();
    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
    MAIN_RENDERER->update_renderer();
    return requestSubmitted;
}

SDL_Rect * GPE_find_camera(SDL_Rect * rectIn)
{
    if(rectIn==NULL)
    {
        return &camera;
    }
    return rectIn;
}

std::string generate_filters(const std::vector<GPE_FileFilter *> filters)
{
	std::string result ="";
    GPE_FileFilter * tempFilter = NULL;
	for(int i = 0; i < (int)filters.size(); i++)
    {
        tempFilter = filters[i];
        if( tempFilter!=NULL)
        {
            result += tempFilter->desc;
            result += '\0';
            result += tempFilter->exts;
            result += '\0';
        }
	}
	return result + '\0';
}

std::string parse_file_types(std::string allowedFileTypes,std::vector <std::string> &fileTypeVector)
{
    fileTypeVector.clear();
    std::string returnFileFilterString = "All types(*.*)\0*.*\0";
    std::vector<GPE_FileFilter *> filters;
    GPE_FileFilter * tempNewFilter = NULL;
	if( (int)allowedFileTypes.size() > 0)
    {
        if( allowedFileTypes=="All types(*.*)" ||  allowedFileTypes=="All Files" || allowedFileTypes=="None" ||  allowedFileTypes=="All Files*")
        {
            fileTypeVector.clear();
        }
        else if( allowedFileTypes=="Image Only" || allowedFileTypes=="Image" || allowedFileTypes=="Images" || allowedFileTypes=="Photos")
        {
            tempNewFilter = new GPE_FileFilter("Images (*.bmp | *.png | *.jpg)", "*.bmp;*.png;*.jpg");
            filters.push_back(tempNewFilter );
            fileTypeVector.push_back("bmp");
            fileTypeVector.push_back("BMP");
            fileTypeVector.push_back("gif");
            fileTypeVector.push_back("GIF");
            fileTypeVector.push_back("jpg");
            fileTypeVector.push_back("JPG");
            fileTypeVector.push_back("jpeg");
            fileTypeVector.push_back("JPEG");
            fileTypeVector.push_back("png");
            fileTypeVector.push_back("PNG");
        }
        else if( allowedFileTypes=="Audio Only" || allowedFileTypes=="Audio")
        {
            fileTypeVector.push_back("aac");
            fileTypeVector.push_back("AAC");
            fileTypeVector.push_back("mp3");
            fileTypeVector.push_back("MP3");
            fileTypeVector.push_back("ogg");
            fileTypeVector.push_back("OGG");
            fileTypeVector.push_back("wav");
            fileTypeVector.push_back("WAV");

            tempNewFilter = new GPE_FileFilter("Audio (*.aac | *.mp3 | *.ogg| *.wav)", "*.aac;*.mp3;*.ogg;*.wav");
            filters.push_back(tempNewFilter );
        }
        else if( allowedFileTypes=="Video Only" || allowedFileTypes=="Video" || allowedFileTypes=="Videos")
        {
            tempNewFilter = new GPE_FileFilter("Video (*.mp4 | *.ogg| *.webm)", "*.mp4;*.ogg;*.webm");
            filters.push_back(tempNewFilter );
            fileTypeVector.push_back("mp4");
            fileTypeVector.push_back("MP4");
            fileTypeVector.push_back("ogg");
            fileTypeVector.push_back("OGG");
            fileTypeVector.push_back("webm");
            fileTypeVector.push_back("WEBM");
        }
        else if( allowedFileTypes=="Fonts Only" || allowedFileTypes=="Font" || allowedFileTypes=="Fonts")
        {
            tempNewFilter = new GPE_FileFilter("Fonts (*.eot | *.svg| *.ttf)", "*.eot;*.svg;*.ttf");
            filters.push_back(tempNewFilter );
            fileTypeVector.push_back("eot");
            fileTypeVector.push_back("EOT");
            fileTypeVector.push_back("svg");
            fileTypeVector.push_back("SVG");
            fileTypeVector.push_back("ttf");
            fileTypeVector.push_back("TTF");
        }
        else if( allowedFileTypes=="Game Pencil Projects" || allowedFileTypes=="GPE Project")
        {
            tempNewFilter = new GPE_FileFilter("Game Pencil Projects (*.gppf)", "*.gppf");
            fileTypeVector.push_back("gppf");
        }
        else if( allowedFileTypes.size() > 2)
        {
            allowedFileTypes = string_replace_all(allowedFileTypes," ","");
            int asterikPosition = allowedFileTypes.find("*");
            int maxIterations = 10;
            int otherTypesIterations = 0;
            if( asterikPosition!=(int)std::string::npos)
            {
                while( asterikPosition!=(int)std::string::npos && otherTypesIterations < maxIterations )
                {
                    fileTypeVector.push_back( split_first_string(allowedFileTypes,"*") );
                    otherTypesIterations++;
                }
            }
            else
            {
                fileTypeVector.push_back(allowedFileTypes);
            }
        }
    }
    tempNewFilter = new GPE_FileFilter("All Files (*.*)", "*.*");
    filters.push_back(tempNewFilter );
    returnFileFilterString = generate_filters(filters);
    for( int iDelete = (int)filters.size()-1; iDelete>=0; iDelete--)
    {
        tempNewFilter = filters.at(iDelete);
        if( tempNewFilter!=NULL)
        {
            delete tempNewFilter;
            tempNewFilter = NULL;
        }
    }
    filters.clear();
    return returnFileFilterString;
}

bool file_passes_filter(std::string fileTypeIn, std::vector <std::string> &fileTypeVector)
{
    if( (int)fileTypeVector.size() > 0 )
    {
        if( (int)fileTypeIn.size() > 0)
        {
            std::string tempStr = "";
            for( int i = (int)fileTypeVector.size()-1; i >=0; i--)
            {
                tempStr = fileTypeVector[i];
                if(fileTypeIn==tempStr)
                {
                    return true;
                }
            }
        }
    }
    else
    {
        return true;
    }
    return false;
}

GPE_FileFilter::GPE_FileFilter(std::string fDesc , std::string fExts )
{
    desc = fDesc;
    exts = fExts;
}

GPE_FileFilter::~GPE_FileFilter()
{

}

GPE_File::GPE_File(std::string fName,bool fileIsDirectory)
{
    isDirectory = fileIsDirectory;
    if( (int)fName.size() > 0)
    {
        fileName = fName;
        if( isDirectory)
        {
            fileType = "";
        }
        else
        {
            fileType = get_file_ext(fName);
        }
    }
    else
    {
        fileName = "";
        fileType = "";
    }
    fileThumbnail = NULL;
    fileSizeInfo = 0;
    dataCreatedInfo = "";
    dataModifiedInfo = "";
}

GPE_File::~GPE_File()
{
    if( fileThumbnail!=NULL)
    {
        delete fileThumbnail;
        fileThumbnail = NULL;
    }
}

bool GPE_File::is_directory()
{
    return isDirectory;
}

std::string GPE_File::get_name()
{
    return fileName;
}

std::string GPE_File::get_type()
{
    return fileType;
}

GPE_FileDirectory::GPE_FileDirectory()
{
    fdPosition= 0;
    fileCount= 0;
    subdirectoryCount= 0;
}

GPE_FileDirectory::~GPE_FileDirectory()
{
    close_directory();
}


bool GPE_FileDirectory::open_directory(std::string directoryIn)
{
    return open_directory_sorted(directoryIn);
}

void GPE_FileDirectory::close_directory()
{
    GPE_File * tFile = NULL;
    for( int i = (int)myFiles.size()-1; i>=0; i--)
    {
        tFile = myFiles[i];
        if( tFile!=NULL)
        {
            delete tFile;
            tFile = NULL;
        }
    }
    myFiles.clear();
    fdPosition= 0;
    fileCount= 0;
    subdirectoryCount= 0;
}

void GPE_FileDirectory::filter_directory(bool onlyFolders, std::vector <std::string> &fTypesToUse)
{
    GPE_File * tempFile = NULL;
    fdPosition = 0;
    fileCount = 0;
    subdirectoryCount = 0;
    for( int i = (int)myFiles.size() - 1; i >=0; i--)
    {
        tempFile = myFiles[i];
        if( tempFile!=NULL)
        {
            if( onlyFolders)
            {
                if( tempFile->is_directory() )
                {
                    subdirectoryCount++;
                }
            }
            else if( tempFile->is_directory() )
            {
                subdirectoryCount++;
            }
            else if( file_passes_filter (tempFile->get_type() , fTypesToUse) )
            {
                fileCount++;
            }
            else
            {
                delete tempFile;
                tempFile = NULL;
                myFiles.erase(myFiles.begin()+i);
            }
        }
        else
        {
            myFiles.erase(myFiles.begin()+i);
        }
    }
}

bool GPE_FileDirectory::open_directory_sorted(std::string directoryIn)
{
    if( path_exists(directoryIn) )
    {
        close_directory();
        std::string foundErrorMessage;
        DIR *dir;
        struct dirent *ent;
        dir = opendir( directoryIn.c_str() );
        if( dir==NULL)
        {
            foundErrorMessage = strerror(errno);

            record_error("Unable to open directory["+directoryIn+"]");
            record_error("Error: "+foundErrorMessage);

            //tinydir_close(&dir);
            return false;
        }
        else
        {
            GPE_File * newFile = NULL;
            GPE_File * tFile = NULL;
            int i = 0;
            int j = 0;
            bool foundNewPosition = false;
            bool newFileIsDirectory = false;
            std::string newFileName = "";
            while ( (ent = readdir(dir)) != NULL )
            {
                std::string entry( ent->d_name );
                //std::string lcEntry( std::strToLower(entry) );
                /*
                if( tinydir_readfile(&dir, &file)==-1)
                {
                    foundErrorMessage = strerror(errno) ;
                    record_error("Unable to open directory's file #"+int_to_string(i)+"]");
                    record_error("Error: "+foundErrorMessage);
                    tinydir_close(&dir);
                    return false;
                }
                else*/
                {
                    newFileName = ent->d_name;
                    if(newFileName!=".." && newFileName!=".")
                    {
                        newFileIsDirectory = path_exists(directoryIn+"/"+ent->d_name);
                        if( ( MAIN_EDITOR_SETTINGS!=NULL && MAIN_EDITOR_SETTINGS->showHiddenFilesInBrowser->is_clicked() ) || GPE_FOUND_OS!=GPE_IDE_LINUX || (GPE_FOUND_OS==GPE_IDE_LINUX && newFileName.find_first_of(".",0)!=0) )
                        {
                            newFile = new GPE_File(newFileName, newFileIsDirectory);
                            if( newFile!=NULL)
                            {
                                newFile->fileLocationDirectory = directoryIn;
                                foundNewPosition = false;

                                for( j = (int)myFiles.size()-1; j >=0 && foundNewPosition==false; j--)
                                {
                                    tFile = myFiles[j];
                                    if( tFile!=NULL)
                                    {
                                        if( tFile->get_name() >= newFileName )
                                        {
                                            myFiles.insert(myFiles.begin()+j,newFile);
                                            foundNewPosition = true;
                                        }
                                    }
                                }
                                if( !foundNewPosition)
                                {
                                    myFiles.push_back(newFile);
                                }
                                if( newFileIsDirectory )
                                {
                                    subdirectoryCount++;
                                }
                                else
                                {
                                    fileCount++;
                                }
                            }
                        }
                    }
                    //tinydir_next(&dir);
                }
                i++;
            }
            //tinydir_close(&dir);

        }

        return true;
    }
    return false;
}

GPE_File * GPE_FileDirectory::get_file(int position)
{
    if( position >=0 && position < (int)myFiles.size() )
    {
        return myFiles.at(position);
    }
    return NULL;
}

int GPE_FileDirectory::get_count()
{
    return (int)myFiles.size();
}

int GPE_FileDirectory::get_subdirectory_count()
{
    return subdirectoryCount;
}

int GPE_FileDirectory::get_file_count()
{
    return fileCount;
}

GPE_File * GPE_FileDirectory::get_next_file()
{
    if( has_next_file() )
    {
        fdPosition++;
        return get_file(fdPosition);
    }
    return NULL;
}

bool GPE_FileDirectory::has_next_file()
{
    if( fdPosition>=0 && fdPosition < (int)myFiles.size()-1 )
    {
        return true;
    }
    return false;
}

bool GPE_FileDirectory::set_position(int position)
{
    if( position >=0 && position < (int)myFiles.size() )
    {
        fdPosition = position;
    }
    return false;
}

std::string GPE_GetPlainFileName( const std::string & prompt, std::string allowedFileTypes, std::string &previousDirectory,bool isSaving, bool isDirectorySearch )
{
    RESOURCE_TO_DRAG = NULL;
    GPE_File * currentFile = NULL;
    GPE_FileDirectory * currentDirectory = new GPE_FileDirectory();

    GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
    GPE_MAIN_GUI->process_cursor();
    record_error("[Opening file] Plainfile Function... using <"+previousDirectory+"> as previous.");
    GPE_MAIN_GUI->take_frozen_screenshot();
    std::string returnFile = "";
    std::string currentDirectoryInView = "";
    std::string nextDirectoryToView = "";
    std::string soughtReturnFilename = "";
    std::string userHomePath = "";
    std::string  osFileFilterString = "All types(*.*)\0*.*\0";
    int filesAndDirectoryPassedFilterCount = 16;
    int maxCharsToView = 16;
    bool fileMatchesFilter = false;
    bool mouseIsInBrowserBox = false;
    float imagePreviewScaleSize = 1;
    char* homeDir;
    std::string iDirLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    homeDir = getenv("%UserProfile%");
    if( homeDir!=NULL)
    {
        userHomePath = currentDirectoryInView = homeDir;
    }
    else
    {
        homeDir = getenv("home");
        if( homeDir!=NULL)
        {
            userHomePath = currentDirectoryInView = homeDir;
        }
        else
        {
            homeDir = getenv("HOME");
            if( homeDir!=NULL)
            {
                userHomePath = currentDirectoryInView = homeDir;
            }
            else
            {
                homeDir = getenv("homepath");
                if( homeDir!=NULL)
                {
                    userHomePath = currentDirectoryInView = homeDir;
                }
                else
                {
                    userHomePath = currentDirectoryInView = APP_DIRECTORY_NAME;
                }
            }
        }
    }

    for( int iLetter = 0; iLetter < (int)iDirLetters.size(); iLetter++)
    {
        if( path_exists(iDirLetters.substr(iLetter,1)+":"+userHomePath) )
        {
            userHomePath = iDirLetters.substr(iLetter,1)+":"+userHomePath;
            break;
        }
        else
        {
            record_error(iDirLetters.substr(iLetter,1)+":"+userHomePath+" is not a directory.");
        }
    }
    userHomePath = string_replace_all(userHomePath,"\\","/");
    currentDirectoryInView = userHomePath;
    if( path_exists(previousDirectory) )
    {
        currentDirectoryInView = previousDirectory.c_str();
    }
    if( (int)currentDirectoryInView.size()>0 && currentDirectory!=NULL)
	{
	    GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);
	    int fontSizeH = 12;
        int fontSizeW = 12;
        FONT_TEXTINPUT->get_metrics("A",&fontSizeW,&fontSizeH);
        if( fontSizeW<=0)
        {
            fontSizeW = 12;
        }
	    GPE_Texture * previewedImageTexture = new GPE_Texture();
        GPE_GuiElementList * shortCutGList = new GPE_GuiElementList();

        std::string shorterCurrentDirectoryInView = currentDirectoryInView;

        std::vector<std::string > fileFilterTypes;
        if( currentDirectoryInView.size() > 32)
        {
            shorterCurrentDirectoryInView = currentDirectoryInView.substr(0,32);
        }
        userInput->reset_all_input();

        int iFile = 0;
        int filesProcessedCount = 0;
        int iDirectory = 0;
        bool enterMyComputerMode = false;
        bool exitOperation = false;
        if( currentDirectory->open_directory_sorted(currentDirectoryInView )==-1)
        {
            exitOperation = true;
        }
        int TEXTBOX_FONT_SIZE_WIDTH = 12;
        int TEXTBOX_FONT_SIZE_HEIGHT = 12;

        int DRIVER_FONT_SIZE_WIDTH = 24;
        int DRIVER_FONT_SIZE_HEIGHT = 24;
        if( FONT_TEXTINPUT!=NULL)
        {
             FONT_TEXTINPUT->get_metrics("A",&TEXTBOX_FONT_SIZE_WIDTH,&TEXTBOX_FONT_SIZE_HEIGHT);
        }
        if( FONT_CATEGORY_BAR!=NULL)
        {
             FONT_CATEGORY_BAR->get_metrics("A",&DRIVER_FONT_SIZE_WIDTH,&DRIVER_FONT_SIZE_HEIGHT);
        }
        std::string returnVal = "";
        std::string fileToClick = "";
        std::string currentFileExt = "";
        std::string fileRenderName[3];
        fileRenderName[0] = "";
        fileRenderName[1] = "";
        fileRenderName[2] = "";
        std::vector <std::string> mountedDriversList;
        GPE_DropDown_Menu * fileTypeDropDown = new GPE_DropDown_Menu(0,0,"All types(*.*)",false);
        osFileFilterString = parse_file_types(allowedFileTypes,fileFilterTypes);
        std::string tempFileType = "";
        for( int fDT = 0; fDT < (int)fileFilterTypes.size(); fDT++)
        {
            tempFileType  = fileFilterTypes.at(fDT);
            fileTypeDropDown->add_menu_option(tempFileType,tempFileType );
        }
        fileFilterTypes.clear();

        GPE_ToolLabelButton * yesButton = NULL;
        if( isSaving)
        {
            yesButton= new GPE_ToolLabelButton(0,32,"Save","");
        }
        else
        {
            yesButton = new GPE_ToolLabelButton(0,32,"Open","");
        }

        GPE_Sprite * mainFilesSprite = NULL;
        GPE_Sprite * mainMenuSprite = NULL;


        GPE_ToolIconButtonBar * fileBrowserModeBar = new GPE_ToolIconButtonBar(0,0,32,true);
        fileBrowserModeBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/table.png","Thumbnailed View",1,false);
        fileBrowserModeBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/list-alt.png","Tiled View",1,false);
        fileBrowserModeBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/list.png","Detailed View",1,false);
        int pastFileBrowserMode = 0;
        GPE_ToolPushButton * mycomputerButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/archive.png","Computer","My Computer");
        GPE_ToolPushButton * homeButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/home.png","Home","View Home Disk Drives");
        GPE_ToolPushButton * desktopButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/desktop.png","Desktop","Opens the Desktop folder");
        GPE_ToolPushButton * documentsButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/suitcase.png","Documents","Opens the Documents folder");
        GPE_ToolPushButton * downloadsButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/download.png","Downloads","Opens the Downloads folder");
        GPE_ToolPushButton * picturesButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/image.png","Pictures","Opens the Pictures folder");
        GPE_ToolPushButton * musicButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/music.png","Music","Opens the Music folder");
        GPE_ToolPushButton * videoButtons = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/film.png","Videos","Opens the Videos folder");

        GPE_ToolPushButton * backButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/backward.png","Up Dir...","Traverses up one directory");
        GPE_ToolPushButton * appDirectoryButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/pencil.png","GPE Folder","Opens the drive to GPE IDE");
        GPE_ToolPushButton * examplesDirectoryButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/leanpub.png","Examples","Examples of Key and simple features");
        //GPE_ToolPushButton * tutorialsDirectoryButton = new GPE_ToolPushButton(0,32,APP_DIRECTORY_NAME+"resources/gfx/buttons/institution.png","Tutorials","Tutorials on using GPE");

        GPE_ToolLabelButton * cancelButton = new GPE_ToolLabelButton(0,32,"Cancel","");
        GPE_TextInputBasic * newStringBox = new GPE_TextInputBasic("");
        GPE_TextInputBasic * directoryViewBox = new GPE_TextInputBasic("Directory");
        directoryViewBox->set_string("Home");
        GPE_ToolIconButton * refreshButton = new GPE_ToolIconButton(32,32,"resources/gfx/buttons/refresh.png","Refresh");

        GPE_ScrollBar_YAxis * fileDirYScroll = new GPE_ScrollBar_YAxis();
        int maxFilesInColumn = 0;
        int maxFilesInRows = 0;
        int maxContentInView = 0;
        int iFileXPos = 0;
        int iDirectoryXPos = 0;
        int fileSelectedNumber = -1;
        int fileHoverNumber = -1;
        int fileSubImageToDraw = 0;
        int colTextWidth = 128;
        int fileRowHeight = 128;
        int colTextCharacters = colTextWidth/fontSizeW;
        if( isDirectorySearch)
        {
            newStringBox->set_label("Directory Name:");
        }
        else
        {
            newStringBox->set_label("File Name:");
        }
        newStringBox->switch_inuse(true);
        int buttonsWidth = yesButton->get_width()+cancelButton->get_width()+GENERAL_GPE_PADDING*2;

        SDL_Rect barBox;
        barBox.x = 0;
        barBox.y = 0;
        barBox.w = 512;
        barBox.h = 416;

        SDL_Rect fileBrowserBox;
        fileBrowserBox.x = 160;
        fileBrowserBox.y = 64;
        fileBrowserBox.w = 512-32;
        fileBrowserBox.h = barBox.h -384;

        SDL_Rect filePreviewBox;
        filePreviewBox.x = SCREEN_WIDTH-(barBox.x+barBox.w);
        filePreviewBox.y = 64;
        filePreviewBox.w = SCREEN_WIDTH-filePreviewBox.x;
        filePreviewBox.h = barBox.h -384;

        SDL_Rect fileShortcutTab;
        fileShortcutTab.x = 0;
        fileShortcutTab.y = 64;
        fileShortcutTab.w = 144;
        fileShortcutTab.h = barBox.h -384;

        SDL_Rect currFileRect;
        currFileRect.x = 0;
        currFileRect.y = 0;
        currFileRect.w = GENERAL_ICON_WIDTH;

        int iContentCol = 0;
        int jContentRow = 0;

        SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
        GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
        record_error("Attempting to open file selection menu...");
        //The lovely file selector loop
        nextDirectoryToView = currentDirectoryInView;
        #ifdef _WIN32
        #include "windows.h"
        if( !isDirectorySearch)
        {
            const int BUFSIZE = 1024;
            char buffer[BUFSIZE] = {0};
            OPENFILENAME ofns = {0};
            ofns.lStructSize = sizeof( ofns );
            ofns.lpstrFile = buffer;
            ofns.nMaxFile = BUFSIZE;
            ofns.lpstrInitialDir = currentDirectoryInView.c_str();
            ofns.lpstrTitle = prompt.c_str();
            ofns.lpstrFilter =  osFileFilterString.c_str();

            ofns.nFilterIndex = 1;
            ofns.Flags =  OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
            bool emptyFileReturned = false;
            if( isSaving)
            {
                if ( !GetSaveFileName( & ofns ) )
                {
                    emptyFileReturned = true;
                }
            }
            else if ( !GetOpenFileName( & ofns ) )
            {
                emptyFileReturned = true;
            }
            returnFile = buffer;
            if( emptyFileReturned)
            {
                returnFile = "";
            }
            exitOperation = true;
        }
        #endif

        GPE_Texture * currentFIleTexture = NULL;
        GPE_Texture * textRepFolder = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/folder-open.png");
        GPE_Texture * textRepHarddrive = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/hdd-o.png");
        GPE_Texture * textRepAudio = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file-audio-o.png");
        GPE_Texture * textRepCode = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file-code-o.png");
        GPE_Texture * textRepExe = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/paper-plane-o.png");
        GPE_Texture * textRepFont = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/font.png");
        GPE_Texture * textRepGPE = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/pencil-square.png");
        GPE_Texture * textRepImage = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file-image-o.png");
        GPE_Texture * textRepOther = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file.png");
        GPE_Texture * textRepPDF = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file-pdf-o.png");
        GPE_Texture * textRepText = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file-text-o.png");
        GPE_Texture * textRepVideo = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file-video-o.png");
        GPE_Texture * textRepZip = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file-zip-o.png");
        GPE_Color * fileIconColor = NULL;
        while(exitOperation==false)
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
            SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
            if( !point_within(userInput->mouse_x,userInput->mouse_y,
                              fileBrowserBox.x,fileBrowserBox.y,
                              fileBrowserBox.x+fileBrowserBox.w,
                              fileBrowserBox.y+fileBrowserBox.h) )
            {
                fileHoverNumber = -1;
            }

            ///
            if( (int)nextDirectoryToView.size() > 0 && path_exists(nextDirectoryToView) )
            {
                record_error("Attempting to open ["+nextDirectoryToView+"] directory...");
                if( path_exists(nextDirectoryToView)==false)
                {
                    nextDirectoryToView+="\\";
                }
                if( path_exists(nextDirectoryToView) )
                {
                    record_error("Opening... ["+nextDirectoryToView+"] directory...");

                    currentDirectoryInView = nextDirectoryToView;
                    directoryViewBox->set_string(currentDirectoryInView);
                    shorterCurrentDirectoryInView = currentDirectoryInView;
                    if( currentDirectoryInView.size() > 32)
                    {
                        shorterCurrentDirectoryInView = currentDirectoryInView.substr(0,32);
                    }
                    nextDirectoryToView = "";
                    fileHoverNumber = -1;
                    fileSelectedNumber = -1;
                    enterMyComputerMode= false;
                    iFile = 0;
                    iDirectory = 0;
                    iFileXPos = 0;
                    iDirectoryXPos = 0;
                    fileDirYScroll->fullRect.x = fileDirYScroll->contextRect.x = 0;
                    fileDirYScroll->fullRect.y = fileDirYScroll->contextRect.y = 0;
                    fileDirYScroll->fullRect.w = fileDirYScroll->contextRect.w = 0;
                    fileDirYScroll->fullRect.h = fileDirYScroll->contextRect.h = 16;
                    fileDirYScroll->process_self();
                    previewedImageTexture->change_texture(NULL);

                    parse_file_types(fileTypeDropDown->get_selected_name(),fileFilterTypes);
                    //Processes files to view
                    filesAndDirectoryPassedFilterCount = 0;

                    if( currentDirectory->open_directory_sorted( currentDirectoryInView ) ==-1)
                    {
                        exitOperation = true;
                    }
                    else
                    {
                        currentDirectory->filter_directory(isDirectorySearch, fileFilterTypes );
                        filesAndDirectoryPassedFilterCount = currentDirectory->get_count();
                        /*
                        for(iFile = 0; iFile < currentDirectory->get_count(); iFile++)
                        {
                            currentFile = currentDirectory->get_file(iFile);
                            if( currentFile!=NULL)
                            {
                                fileToClick = currentFile->get_name();
                                if( currentFile->is_directory() )
                                {
                                    filesAndDirectoryPassedFilterCount++;
                                }
                                else if( !isDirectorySearch &&  file_passes_filter(currentFile->get_type(),fileFilterTypes) )
                                {
                                    filesAndDirectoryPassedFilterCount++;
                                }
                            }
                        }
                        */
                        record_error("<"+currentDirectoryInView+"> has ["+int_to_string(filesAndDirectoryPassedFilterCount)+"/"+int_to_string(currentDirectory->get_count() )+"] amount of files/directories...");
                        fileDirYScroll->fullRect.h = fileDirYScroll->contextRect.h =  filesAndDirectoryPassedFilterCount;
                    }
                }
                else
                {
                    nextDirectoryToView = "";
                }
            }

            ///
            //Start the frame timer
            capTimer->start();
            //gets user input
            GPE_MAIN_GUI->reset_gui_info();
            userInput->handle(true,true);

            barBox.x = 0;
            barBox.y = 0;
            if( SCREEN_WIDTH > 1024)
            {
                barBox.w = SCREEN_WIDTH*2/3;
            }
            else
            {
                barBox.w = SCREEN_WIDTH-128;
            }

            //if( SCREEN_HEIGHT >= 600)
            {
                barBox.h = SCREEN_HEIGHT*4/5;
            }/*
            else
            {
                barBox.h = SCREEN_HEIGHT;
            }*/

            fileBrowserBox.w = barBox.w-16-fileBrowserBox.x;
            fileBrowserBox.h = barBox.h - 192;

            filePreviewBox.x = barBox.x+barBox.w;
            filePreviewBox.y = fileBrowserBox.y;
            filePreviewBox.w = SCREEN_WIDTH-filePreviewBox.x-(GENERAL_GPE_PADDING*2);
            filePreviewBox.h = fileBrowserBox.h;

            fileShortcutTab.h = barBox.h - fileShortcutTab.y;
            fileBrowserModeBar->process_self(&camera,&camera);
            if( fileBrowserModeBar->is_clicked() || pastFileBrowserMode!=fileBrowserModeBar->get_tab_pos() )
            {
                iDirectoryXPos = iFileXPos = 0;
                pastFileBrowserMode=fileBrowserModeBar->get_tab_pos();
            }

            if( enterMyComputerMode ==true)
            {
                maxFilesInRows = 1;
                colTextWidth = fileBrowserBox.w-GENERAL_GPE_PADDING-GENERAL_THUMBNAIL_SIZE;
            }
            else
            {
                if( fileBrowserBox.w >TEXTBOX_FONT_SIZE_WIDTH*60 )
                {
                    maxFilesInRows = fileBrowserBox.w / (TEXTBOX_FONT_SIZE_WIDTH*60);
                    colTextWidth = (fileBrowserBox.w-maxFilesInColumn*(GENERAL_GPE_PADDING+GENERAL_ICON_WIDTH) )/maxFilesInRows;
                }
                else
                {
                    maxFilesInRows = 1;
                    colTextWidth = fileBrowserBox.w-GENERAL_GPE_PADDING;
                }
            }

            if( enterMyComputerMode ==true)
            {
                maxFilesInColumn = fileBrowserBox.h / (GENERAL_THUMBNAIL_SIZE+GENERAL_GPE_PADDING);
                maxFilesInRows = 1;
                currFileRect.w =colTextWidth = fileBrowserBox.w-32;
                currFileRect.h = GENERAL_THUMBNAIL_SIZE;
            }
            else
            {
                maxCharsToView = (fileBrowserBox.w/TEXTBOX_FONT_SIZE_WIDTH)-20;
                fileRowHeight = GENERAL_ICON_WIDTH;
                if( fileBrowserModeBar->get_tab_pos()==0 )
                {
                    currFileRect.w = colTextWidth = (GENERAL_THUMBNAIL_SIZE+GENERAL_GPE_PADDING*4);
                    maxFilesInRows = fileBrowserBox.w/currFileRect.w;
                    currFileRect.h = fileRowHeight = GENERAL_THUMBNAIL_SIZE+TEXTBOX_FONT_SIZE_HEIGHT*3+GENERAL_GPE_PADDING;
                    maxFilesInColumn = std::ceil( (float)fileBrowserBox.h/(float)currFileRect.h );
                    maxContentInView = (maxFilesInColumn)*maxFilesInRows;
                }
                else if( fileBrowserModeBar->get_tab_pos()==1 )
                {
                    currFileRect.w = colTextWidth = 40*TEXTBOX_FONT_SIZE_WIDTH+GENERAL_ICON_WIDTH;
                    maxFilesInRows = fileBrowserBox.w/currFileRect.w;
                    currFileRect.h = GENERAL_ICON_WIDTH+GENERAL_GPE_PADDING;
                    maxFilesInColumn = fileBrowserBox.h/currFileRect.h;
                    maxContentInView = (maxFilesInColumn)*maxFilesInRows;
                }
                else if( fileBrowserModeBar->get_tab_pos()==2 )
                {
                    currFileRect.w =colTextWidth = fileBrowserBox.w-32;
                    currFileRect.h = GENERAL_ICON_WIDTH+GENERAL_GPE_PADDING;
                    maxFilesInRows = 1;
                    maxFilesInColumn = fileBrowserBox.h/currFileRect.h;
                    maxContentInView = (maxFilesInColumn)*maxFilesInRows;
                }
            }


            colTextCharacters = colTextWidth/fontSizeW;
            shorterCurrentDirectoryInView = currentDirectoryInView;

            if( (int)currentDirectoryInView.size() > maxCharsToView)
            {
                shorterCurrentDirectoryInView = "/..."+currentDirectoryInView.substr(currentDirectoryInView.size()-maxCharsToView);
            }

            refreshButton->set_coords(GENERAL_GPE_PADDING,barBox.y+32);
            newStringBox->set_coords( fileBrowserBox.x+GENERAL_GPE_PADDING,fileBrowserBox.y+fileBrowserBox.h+GENERAL_GPE_PADDING);
            newStringBox->set_width(fileBrowserBox.w-128 );

            fileTypeDropDown->set_coords( fileBrowserBox.x+GENERAL_GPE_PADDING,newStringBox->get_y2pos()+GENERAL_GPE_PADDING);
            fileTypeDropDown->set_width(fileBrowserBox.w-128 );


            directoryViewBox->set_coords( barBox.x+GENERAL_GPE_PADDING+32,barBox.y+32);
            directoryViewBox->set_width(barBox.w - 192);

            fileBrowserModeBar->set_coords(directoryViewBox->get_x2pos(),directoryViewBox->get_ypos() );
            fileBrowserModeBar->set_width(128);

            backButton->set_width(128);
            mycomputerButton->set_width(128);
            homeButton->set_width(128);
            desktopButton->set_width(128);
            documentsButton->set_width(128);
            downloadsButton->set_width(128);
            picturesButton->set_width(128);
            musicButton->set_width(128);
            videoButtons->set_width(128);
            appDirectoryButton->set_width(128);
            examplesDirectoryButton->set_width(128);
            //tutorialsDirectoryButton->set_width(128);

            yesButton->set_coords(  barBox.x+barBox.w-buttonsWidth,barBox.h-48);
            cancelButton->set_coords( barBox.x+yesButton->get_x2pos()+GENERAL_GPE_PADDING,barBox.h-48);

            if( shortCutGList!=NULL)
            {
                shortCutGList->clear_list();
                shortCutGList->barXMargin = GENERAL_GPE_PADDING;
                shortCutGList->barYMargin = 0;
                shortCutGList->barXPadding = 0;
                shortCutGList->barYPadding = GENERAL_GPE_PADDING;

                shortCutGList->set_coords(fileShortcutTab.x,fileShortcutTab.y);
                shortCutGList->set_width(fileShortcutTab.w);
                shortCutGList->set_height(fileShortcutTab.h);
                //if( GPE_FOUND_OS==GPE_IDE_LINUX)
                {
                    if( MAIN_EDITOR_SETTINGS!=NULL)
                    {
                        shortCutGList->add_gui_element(MAIN_EDITOR_SETTINGS->showHiddenFilesInBrowser,true);
                    }
                }
                shortCutGList->add_gui_element(backButton,true);
                shortCutGList->add_gui_element(mycomputerButton,true);
                shortCutGList->add_gui_element(homeButton,true);
                shortCutGList->add_gui_element(desktopButton,true);
                shortCutGList->add_gui_element(documentsButton,true);
                shortCutGList->add_gui_element(downloadsButton,true);
                shortCutGList->add_gui_element(picturesButton,true);
                shortCutGList->add_gui_element(musicButton,true);
                shortCutGList->add_gui_element(videoButtons,true);
                shortCutGList->add_gui_element(appDirectoryButton,true);
                shortCutGList->add_gui_element(examplesDirectoryButton,true);
                //shortCutGList->add_gui_element(tutorialsDirectoryButton,true);
                //shortCutGList->add_gui_element(musicButton);
                shortCutGList->process_self(&camera,&camera);
            }

            refreshButton->process_self(&camera,&camera);
            yesButton->process_self(&camera,&camera);

            cancelButton->process_self(&camera,&camera);

            newStringBox->process_self(&camera,&camera);
            if( !isDirectorySearch)
            {
                fileTypeDropDown->process_self(&camera,&camera);
            }
            if( fileTypeDropDown->just_activated() )
            {
                nextDirectoryToView = currentDirectoryInView;
            }
            directoryViewBox->process_self(&camera,&camera);

            if( directoryViewBox->is_inuse() ==false)
            {
                if( directoryViewBox->get_string() !=currentDirectoryInView )
                {
                    if( path_exists(directoryViewBox->get_string() ) )
                    {
                        nextDirectoryToView  = directoryViewBox->get_string();
                    }
                }
            }

            if( backButton->is_clicked() )
            {
                nextDirectoryToView = get_path_from_file(currentDirectoryInView);
                if( nextDirectoryToView.size()<=1 )
                {
                    nextDirectoryToView = "";
                }
            }

            if( newStringBox->is_inuse()==false && directoryViewBox->is_inuse()==false )
            {
                if( userInput->check_keyboard_released(kb_backspace) )
                {
                    nextDirectoryToView = get_path_from_file(currentDirectoryInView);
                    if( nextDirectoryToView.size()<=1 )
                    {
                        nextDirectoryToView = "";
                    }
                }
            }
            if( homeButton->is_clicked() )
            {
                nextDirectoryToView = userHomePath;
            }

            if( desktopButton->is_clicked() )
            {
                nextDirectoryToView = userHomePath+"/Desktop";
                if( path_exists( nextDirectoryToView)==false)
                {
                    nextDirectoryToView = userHomePath+"/desktop";
                    if( path_exists( nextDirectoryToView)==false)
                    {
                        nextDirectoryToView = userHomePath+"/MyDesktop";
                        if( path_exists( nextDirectoryToView)==false)
                        {
                            nextDirectoryToView = userHomePath+"/My Desktop";
                        }
                        else
                        {
                            nextDirectoryToView = "";
                        }
                    }
                }
            }

            if( downloadsButton->is_clicked() )
            {
                nextDirectoryToView = userHomePath+"/Downloads";
                if( path_exists( nextDirectoryToView)==false)
                {
                    nextDirectoryToView = userHomePath+"/downloads";
                    if( path_exists( nextDirectoryToView)==false)
                    {
                        nextDirectoryToView = userHomePath+"/MyDownloads";
                        if( path_exists( nextDirectoryToView)==false)
                        {
                            nextDirectoryToView = userHomePath+"/My Downloads";
                        }
                        else
                        {
                            nextDirectoryToView = "";
                        }
                    }
                }
            }

            if( picturesButton->is_clicked() )
            {
                nextDirectoryToView = userHomePath+"/Pictures";
                if( path_exists( nextDirectoryToView)==false)
                {
                    nextDirectoryToView = userHomePath+"/pictures";
                    if( path_exists( nextDirectoryToView)==false)
                    {
                        nextDirectoryToView = userHomePath+"/MyPictures";
                        if( path_exists( nextDirectoryToView)==false)
                        {
                            nextDirectoryToView = userHomePath+"/My Pictures";
                        }
                        else
                        {
                            nextDirectoryToView = "";
                        }
                    }
                }
            }

            if( musicButton->is_clicked() )
            {
                nextDirectoryToView = userHomePath+"/Music";
                if( path_exists( nextDirectoryToView)==false)
                {
                    nextDirectoryToView = userHomePath+"/music";
                    if( path_exists( nextDirectoryToView)==false)
                    {
                        nextDirectoryToView = userHomePath+"/MyMusic";
                        if( path_exists( nextDirectoryToView)==false)
                        {
                            nextDirectoryToView = userHomePath+"/My Music";
                        }
                        else
                        {
                            nextDirectoryToView = "";
                        }
                    }
                }
            }

            if( videoButtons->is_clicked() )
            {
                nextDirectoryToView = userHomePath+"/Videos";
                if( path_exists( nextDirectoryToView)==false)
                {
                    nextDirectoryToView = userHomePath+"/videos";
                    if( path_exists( nextDirectoryToView)==false)
                    {
                        nextDirectoryToView = userHomePath+"/MyVideos";
                        if( path_exists( nextDirectoryToView)==false)
                        {
                            nextDirectoryToView = userHomePath+"/My Videos";
                        }
                        else
                        {
                            nextDirectoryToView = "";
                        }
                    }
                }
            }

            if( enterMyComputerMode==false && refreshButton->is_clicked() )
            {
                nextDirectoryToView = currentDirectoryInView;
            }

            if( mycomputerButton->is_clicked() || ( enterMyComputerMode==true && refreshButton->is_clicked()) )
            {
                mountedDriversList.clear();
                nextDirectoryToView = "/proc/mounts";
                if( file_exists( nextDirectoryToView) && GPE_FOUND_OS==GPE_IDE_LINUX )
                {
                    enterMyComputerMode = true;
                }
                else if( GPE_FOUND_OS==GPE_IDE_WINDOWS)
                {
                    enterMyComputerMode = true;
                    #ifdef _WIN32

                    DWORD dwSize = MAX_PATH;
                    char szLogicalDrives[MAX_PATH] = {0};
                    DWORD dwResult = GetLogicalDriveStrings(dwSize,szLogicalDrives);

                    if (dwResult > 0 && dwResult <= MAX_PATH)
                    {
                        char* szSingleDrive = szLogicalDrives;
                        while(*szSingleDrive)
                        {
                            mountedDriversList.push_back(szSingleDrive);

                              // get the next drive
                            szSingleDrive += strlen(szSingleDrive) + 1;
                        }
                    }
                    #endif
                }
                nextDirectoryToView = "";
                directoryViewBox->set_string("My Computer");
            }

            if( documentsButton->is_clicked() )
            {
                nextDirectoryToView = userHomePath+"/Documents";
                if( path_exists( nextDirectoryToView)==false)
                {
                    nextDirectoryToView = userHomePath+"/documents";
                    if( path_exists( nextDirectoryToView)==false)
                    {
                        nextDirectoryToView = userHomePath+"/MyDocuments";
                        if( path_exists( nextDirectoryToView)==false)
                        {
                            nextDirectoryToView = userHomePath+"/My Documents";
                        }
                    }
                }
            }

            if( appDirectoryButton->is_clicked() )
            {
                nextDirectoryToView = get_path_from_file(APP_DIRECTORY_NAME);
            }

            if( examplesDirectoryButton->is_clicked() )
            {
                nextDirectoryToView = APP_DIRECTORY_NAME+"examples";
            }

            /*if( tutorialsDirectoryButton->is_clicked() )
            {
                nextDirectoryToView = APP_DIRECTORY_NAME+"tutorials";
            }*/

            if( userInput->check_keyboard_released(kb_esc) || cancelButton->is_clicked() )
            {
                exitOperation = true;
                returnVal = "";
            }
            else if( userInput->check_keyboard_released(kb_enter) || yesButton->is_clicked() )
            {
                if( newStringBox!=NULL)
                {
                    soughtReturnFilename = currentDirectoryInView+"/"+newStringBox->get_string();
                    if( isDirectorySearch )
                    {
                        if( path_exists(soughtReturnFilename) )
                        {
                            exitOperation = true;
                            returnFile = soughtReturnFilename;
                        }
                        else
                        {
                            soughtReturnFilename = currentDirectoryInView;
                            if( path_exists(soughtReturnFilename) )
                            {
                                exitOperation = true;
                                returnFile = soughtReturnFilename;
                            }
                        }
                    }
                    else if( isSaving && (int)newStringBox->get_string().size()>0 )
                    {
                        if( file_exists(soughtReturnFilename) )
                        {
                            if( display_get_prompt("File already exists","Do you wish to overwrite this file?")==DISPLAY_QUERY_YES )
                            {
                                exitOperation = true;
                                returnFile = soughtReturnFilename;
                            }
                        }
                        else
                        {
                            exitOperation = true;
                            returnFile = soughtReturnFilename;
                        }
                    }
                    else if( file_exists(soughtReturnFilename) )
                    {
                        exitOperation = true;
                        returnFile = soughtReturnFilename;
                    }
                }
            }

            if( enterMyComputerMode)
            {
                if( (int)mountedDriversList.size() > maxContentInView)
                {
                    fileDirYScroll->barBox.x = fileBrowserBox.x+fileBrowserBox.w-16;
                    fileDirYScroll->barBox.y = fileBrowserBox.y;
                    fileDirYScroll->barBox.w = 16;
                    fileDirYScroll->barBox.h = fileBrowserBox.h;

                    fileDirYScroll->fullRect.x = 0;
                    fileDirYScroll->fullRect.y = 0;
                    fileDirYScroll->fullRect.w = 0;
                    fileDirYScroll->fullRect.h = (int)mountedDriversList.size();
                    //if( directoryViewBox->is_inuse()==false && newStringBox->is_inuse()==false && shortCutGList->hasScrollControl==false)
                    //{
                    if( point_between_rect(userInput->mouse_x,userInput->mouse_y,&fileBrowserBox ) )
                    {
                        if( userInput->mouseScrollingUp || userInput->check_keyboard_down(kb_page_up))
                        {
                            iDirectoryXPos-=maxContentInView/2;
                        }
                        else if( userInput->mouseScrollingDown || userInput->check_keyboard_down(kb_page_down) )
                        {
                            iDirectoryXPos+=maxContentInView/2;
                        }
                    }
                    fileDirYScroll->contextRect.x = 0;
                    fileDirYScroll->contextRect.y = iDirectoryXPos;
                    fileDirYScroll->contextRect.w = 0;
                    fileDirYScroll->contextRect.h = maxContentInView;

                    fileDirYScroll->process_self();
                    if( fileDirYScroll->has_moved() )
                    {
                        iDirectoryXPos = ceil( ( (float)mountedDriversList.size() ) * ( (float)fileDirYScroll->scrollYPos/(float)fileDirYScroll->barBox.h ) );
                    }
                }
                else
                {
                    fileDirYScroll->contextRect.x =  fileDirYScroll->fullRect.x = 0;
                    fileDirYScroll->contextRect.y =  fileDirYScroll->fullRect.y = 0;
                    fileDirYScroll->contextRect.w =  fileDirYScroll->fullRect.w = 32;
                    fileDirYScroll->contextRect.h =  fileDirYScroll->fullRect.h = (int)mountedDriversList.size();
                    fileDirYScroll->process_self();
                }
            }
            else
            {
                if( filesAndDirectoryPassedFilterCount > maxContentInView)
                {
                    fileDirYScroll->barBox.x = fileBrowserBox.x+fileBrowserBox.w-16;
                    fileDirYScroll->barBox.y = fileBrowserBox.y;
                    fileDirYScroll->barBox.w = 16;
                    fileDirYScroll->barBox.h = fileBrowserBox.h;

                    fileDirYScroll->fullRect.x = 0;
                    fileDirYScroll->fullRect.y = 0;
                    fileDirYScroll->fullRect.w = 0;
                    fileDirYScroll->fullRect.h = filesAndDirectoryPassedFilterCount;

                    /*if( maxContentInView >8)
                    {

                    }
                    scrollAmount = */
                    //if( directoryViewBox->is_inuse()==false && newStringBox->is_inuse()==false && shortCutGList->hasScrollControl==false)
                    if( point_between_rect(userInput->mouse_x,userInput->mouse_y,&fileBrowserBox ) )
                    {

                        if( userInput->mouseScrollingUp)
                        {
                            iFileXPos-=maxFilesInRows;
                        }
                        else if( userInput->mouseScrollingDown)
                        {
                            iFileXPos+=maxFilesInRows;
                        }
                    }
                    if( directoryViewBox->is_inuse()==false && newStringBox->is_inuse()==false && shortCutGList->hasScrollControl==false )
                    {
                        if( userInput->check_keyboard_down(kb_up) )
                        {
                            iFileXPos-=maxFilesInRows;
                        }
                        else if( userInput->check_keyboard_down(kb_down) )
                        {
                            iFileXPos+=maxFilesInRows;
                        }
                    }

                    fileDirYScroll->contextRect.x = 0;
                    fileDirYScroll->contextRect.y = iFileXPos;
                    fileDirYScroll->contextRect.w = 0;
                    fileDirYScroll->contextRect.h = maxContentInView;
                    fileDirYScroll->process_self(&camera,&camera);

                    if( fileDirYScroll->has_moved() )
                    {
                        iFileXPos = ceil( ( (float)filesAndDirectoryPassedFilterCount ) * ( (float)fileDirYScroll->scrollYPos/(float)fileDirYScroll->barBox.h ) );
                    }
                }
                else
                {
                    fileDirYScroll->contextRect.x =  fileDirYScroll->fullRect.x = 0;
                    fileDirYScroll->contextRect.y =  fileDirYScroll->fullRect.y = 0;
                    fileDirYScroll->contextRect.w =  fileDirYScroll->fullRect.w = 32;
                    fileDirYScroll->contextRect.h =  fileDirYScroll->fullRect.h = filesAndDirectoryPassedFilterCount;
                    fileDirYScroll->process_self();
                }
            }


            calculate_avg_fps();
            if( !WINDOW_WAS_JUST_RESIZED)
            {
                //if( userInput->windowEventHappendInFrame )
                {
                    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
                    //currentState->render();
                    //MAIN_RENDERER->update_renderer();
                }
                //Update screen
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->Program_Header_Color,false);

                render_rectangle(MAIN_RENDERER,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+32,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);

                render_new_text(MAIN_RENDERER,barBox.x+barBox.w/2,barBox.y+16,prompt,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,DEFAULT_FONT,FA_CENTER,FA_MIDDLE);
                if( enterMyComputerMode)
                {
                    //render_new_text(MAIN_RENDERER,barBox.x+32,barBox.y+48,"My Computer",GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_MIDDLE);
                }
                else
                {
                    //render_new_text(MAIN_RENDERER,barBox.x+32,barBox.y+48,"Viewing "+shorterCurrentDirectoryInView,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_MIDDLE);
                }

                render_rect(MAIN_RENDERER,&fileShortcutTab,GPE_MAIN_TEMPLATE->Text_Box_Color,false);
                render_rect(MAIN_RENDERER,&fileShortcutTab,GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,true);

                render_rect(MAIN_RENDERER,&fileBrowserBox,GPE_MAIN_TEMPLATE->Text_Box_Color,false);
                render_rect(MAIN_RENDERER,&fileBrowserBox,GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,true);

                iContentCol = 0;
                jContentRow = 0;
                SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),&fileBrowserBox);
                mouseIsInBrowserBox = point_between_rect(userInput->mouse_x,userInput->mouse_y,&fileBrowserBox);

                if( enterMyComputerMode==true)
                {
                    //display my computer directory
                    for (iDirectory = iDirectoryXPos; iDirectory < (int)mountedDriversList.size() && iDirectory < iDirectoryXPos+maxContentInView; iDirectory++)
                    {
                        currFileRect.x = fileBrowserBox.x+GENERAL_GPE_PADDING;
                        currFileRect.y = fileBrowserBox.y+jContentRow*(GENERAL_THUMBNAIL_SIZE+GENERAL_GPE_PADDING);

                        if( mouseIsInBrowserBox && point_between_rect(userInput->mouse_x,userInput->mouse_y,&currFileRect) )
                        {
                            fileHoverNumber = iDirectory;
                            if( userInput->check_mouse_doubleclicked(0) )
                            {
                                nextDirectoryToView = mountedDriversList[iDirectory];
                                fileHoverNumber = -1;
                                fileSelectedNumber = -1;
                            }
                            else if( userInput->check_mouse_released(0) )
                            {
                                fileSelectedNumber = iDirectory;
                                fileHoverNumber = -1;
                            }
                        }

                        currFileRect.x = GENERAL_GPE_PADDING;
                        currFileRect.y = jContentRow*(GENERAL_THUMBNAIL_SIZE+GENERAL_GPE_PADDING);

                        if( fileSelectedNumber ==iDirectory)
                        {
                            render_rect(MAIN_RENDERER,&currFileRect,GPE_MAIN_TEMPLATE->Main_Box_Font_Highlight_Color,false);
                        }
                        else if( fileHoverNumber ==iDirectory)
                        {
                            render_rect(MAIN_RENDERER,&currFileRect,GPE_MAIN_TEMPLATE->Main_Border_Color,false);
                        }
                        render_texture_resized(MAIN_RENDERER,textRepHarddrive,currFileRect.x,currFileRect.y,GENERAL_THUMBNAIL_SIZE,GENERAL_THUMBNAIL_SIZE,NULL,NULL,FA_LEFT, FA_TOP, GPE_MAIN_TEMPLATE->Main_Folder_Color );
                        render_new_text(MAIN_RENDERER,currFileRect.x+GENERAL_THUMBNAIL_SIZE+GENERAL_GPE_PADDING,currFileRect.y+GENERAL_THUMBNAIL_SIZE/2,mountedDriversList[iDirectory],GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_CATEGORY_BAR,FA_LEFT,FA_MIDDLE);

                        jContentRow += 1;
                    }
                }
                else
                {
                    filesProcessedCount = 0;
                    for(iFile = iFileXPos;filesProcessedCount < maxContentInView && iFile < currentDirectory->get_count(); iFile++)
                    {
                        currentFile = currentDirectory->get_file(iFile);
                        if( currentFile!=NULL)
                        {
                            fileToClick = currentFile->get_name();
                            if( currentFile->is_directory() )
                            {
                                fileMatchesFilter = true;
                            }
                            else if( !isDirectorySearch )
                            {
                                currentFileExt = currentFile->get_type();
                                fileMatchesFilter = file_passes_filter(currentFileExt,fileFilterTypes);
                            }
                            else
                            {
                                fileMatchesFilter = false;
                            }
                            if( fileMatchesFilter)
                            {
                                currFileRect.x = fileBrowserBox.x+iContentCol*(currFileRect.w);
                                currFileRect.y = fileBrowserBox.y+jContentRow*(currFileRect.h);
                                if( mouseIsInBrowserBox && point_between_rect(userInput->mouse_x,userInput->mouse_y,&currFileRect) )
                                {
                                    fileHoverNumber = iFile;
                                    if( userInput->check_mouse_doubleclicked(0) )
                                    {
                                        if( currentFile->is_directory() )
                                        {
                                            nextDirectoryToView = currentDirectoryInView+"/"+fileToClick;
                                        }
                                        else
                                        {
                                            soughtReturnFilename = currentDirectoryInView+"/"+fileToClick;
                                            fileMatchesFilter = file_passes_filter(get_file_ext(fileToClick),fileFilterTypes);
                                            if( fileMatchesFilter)
                                            {
                                                if( isSaving)
                                                {
                                                    if( file_exists(soughtReturnFilename) )
                                                    {
                                                        if( display_get_prompt("File already exists","Do you wish to overwrite this file?")==DISPLAY_QUERY_YES )
                                                        {
                                                            exitOperation = true;
                                                            returnFile = soughtReturnFilename;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        exitOperation = true;
                                                        returnFile = soughtReturnFilename;
                                                    }
                                                }
                                                else
                                                {
                                                    if( file_exists(soughtReturnFilename) )
                                                    {
                                                        exitOperation = true;
                                                        returnFile = soughtReturnFilename;
                                                    }
                                                }
                                            }
                                        }
                                        fileHoverNumber = -1;
                                        fileSelectedNumber = -1;
                                    }
                                    else if( userInput->check_mouse_released(0) )
                                    {
                                        fileSelectedNumber = iFile;
                                        fileHoverNumber = -1;
                                        if( !currentFile->is_directory() )
                                        {
                                            newStringBox->set_string(fileToClick);
                                            if( previewedImageTexture!=NULL )
                                            {
                                                if( fileMatchesFilter)
                                                {
                                                    if( currentFileExt=="bmp" || currentFileExt=="gif" || currentFileExt=="jpg" || currentFileExt=="jpeg"  || currentFileExt=="png" )
                                                    {
                                                        previewedImageTexture->load_new_texture(MAIN_RENDERER,currentDirectoryInView+"/"+fileToClick);
                                                        if( previewedImageTexture!=NULL)
                                                        {
                                                            if( previewedImageTexture->get_width() < 1 || previewedImageTexture->get_height() < 1 || previewedImageTexture->get_width() > 4096 || previewedImageTexture->get_height() > 4096)
                                                            {
                                                                previewedImageTexture->change_texture(NULL);
                                                            }
                                                        }
                                                    }
                                                    else
                                                    {
                                                        previewedImageTexture->change_texture(NULL);
                                                    }
                                                }
                                            }
                                            else if(previewedImageTexture!=NULL)
                                            {
                                                previewedImageTexture->change_texture(NULL);
                                            }
                                        }
                                        else if( isDirectorySearch)
                                        {
                                            newStringBox->set_string(fileToClick);
                                        }
                                    }
                                }
                                fileRenderName[0] = "";
                                fileRenderName[1] = "";
                                fileRenderName[2] = "";
                                //Renders file
                                currFileRect.x = iContentCol*(currFileRect.w);
                                currFileRect.y = jContentRow*(currFileRect.h);
                                if( fileSelectedNumber ==iFile)
                                {
                                    render_rect(MAIN_RENDERER,&currFileRect,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,false);
                                }
                                else if( fileHoverNumber ==iFile)
                                {
                                    render_rect(MAIN_RENDERER,&currFileRect,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,false);
                                }
                                currentFIleTexture = NULL;
                                if( currentFile->is_directory() )
                                {
                                    fileSubImageToDraw = 1;
                                    //mainFilesSprite
                                    if( fileSelectedNumber ==iFile)
                                    {
                                        fileIconColor = GPE_MAIN_TEMPLATE->Main_Folder_Highlighted_Color;
                                    }
                                    else
                                    {
                                        fileIconColor = GPE_MAIN_TEMPLATE->Main_Folder_Color;
                                    }
                                    currentFIleTexture = textRepFolder;
                                }
                                else
                                {
                                    fileToClick = currentFile->get_name();
                                    currentFileExt =currentFile->get_type();
                                    fileMatchesFilter = file_passes_filter(currentFileExt,fileFilterTypes);

                                    fileSubImageToDraw = 0;

                                    if( currentFileExt=="txt")
                                    {
                                        currentFIleTexture = textRepText;
                                    }
                                    else if( currentFileExt=="eot" || currentFileExt=="ttf" || currentFileExt=="woff")
                                    {
                                        currentFIleTexture = textRepFont;
                                    }
                                    else if( currentFileExt=="bmp" || currentFileExt=="gif" || currentFileExt=="jpg" || currentFileExt=="jpeg"  || currentFileExt=="png" )
                                    {
                                        currentFIleTexture = textRepImage;
                                    }
                                    else if( currentFileExt=="aac" || currentFileExt=="mp3" || currentFileExt=="ogg")
                                    {
                                        currentFIleTexture = textRepAudio;
                                    }
                                    else if( currentFileExt=="avi" || currentFileExt=="mp4" || currentFileExt=="webm")
                                    {
                                        currentFIleTexture = textRepVideo;
                                    }
                                    else if( currentFileExt=="c" || currentFileExt=="css" || currentFileExt=="h" || currentFileExt=="html" || currentFileExt=="js"  || currentFileExt=="php")
                                    {
                                        currentFIleTexture = textRepCode;
                                    }
                                    else if( currentFileExt=="gppf")
                                    {
                                        currentFIleTexture = textRepGPE;
                                    }
                                    else if( currentFileExt=="exe")
                                    {
                                        currentFIleTexture = textRepExe;
                                    }
                                    else
                                    {
                                        currentFIleTexture = textRepOther;
                                    }

                                    if( fileSelectedNumber ==iFile)
                                    {
                                       fileIconColor = GPE_MAIN_TEMPLATE->Main_Box_Font_Highlight_Color;
                                    }
                                    else
                                    {
                                       fileIconColor  = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;
                                    }
                                }

                                fileRenderName[0] = "";
                                fileRenderName[1] = "";
                                fileRenderName[2] = "";
                                if( (int)fileToClick.size() >=colTextCharacters)
                                {
                                    fileRenderName[0] = get_substring(fileToClick,0,colTextCharacters);
                                    fileRenderName[1] = get_substring(fileToClick,colTextCharacters,colTextCharacters);

                                    if( (int)fileToClick.size() >colTextCharacters*3)
                                    {
                                        fileRenderName[2] = get_substring(fileToClick,colTextCharacters*2,colTextCharacters-3)+"...";
                                    }
                                    else
                                    {
                                        fileRenderName[2] = get_substring(fileToClick,colTextCharacters*2,colTextCharacters);
                                    }
                                    fileToClick = fileRenderName[2];
                                }
                                else
                                {
                                    fileRenderName[0] = fileToClick;
                                }
                                //Renders Thumbnails
                                if( fileBrowserModeBar->get_tab_pos()==0 )
                                {
                                    if( currentFile->fileThumbnail!=NULL )
                                    {
                                        render_texture_resized(MAIN_RENDERER,currentFile->fileThumbnail,
                                                               currFileRect.x+(currFileRect.w-GENERAL_THUMBNAIL_SIZE)/2,currFileRect.y,GENERAL_THUMBNAIL_SIZE,GENERAL_THUMBNAIL_SIZE);
                                    }
                                    else if( currentFIleTexture!=NULL)
                                    {
                                        render_texture_resized(MAIN_RENDERER,currentFIleTexture,currFileRect.x+(currFileRect.w-GENERAL_THUMBNAIL_SIZE)/2,currFileRect.y,GENERAL_THUMBNAIL_SIZE,GENERAL_THUMBNAIL_SIZE,NULL,NULL,FA_LEFT,FA_TOP,fileIconColor );
                                    }
                                    render_new_text(MAIN_RENDERER,currFileRect.x+currFileRect.w/2,currFileRect.y+GENERAL_THUMBNAIL_SIZE,fileRenderName[0],GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_TEXTINPUT,FA_CENTER,FA_TOP);
                                    render_new_text(MAIN_RENDERER,currFileRect.x+currFileRect.w/2,currFileRect.y+GENERAL_THUMBNAIL_SIZE+TEXTBOX_FONT_SIZE_HEIGHT,fileRenderName[1],GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_TEXTINPUT,FA_CENTER,FA_TOP);
                                    render_new_text(MAIN_RENDERER,currFileRect.x+currFileRect.w/2,currFileRect.y+GENERAL_THUMBNAIL_SIZE+TEXTBOX_FONT_SIZE_HEIGHT*2,fileRenderName[2],GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_TEXTINPUT,FA_CENTER,FA_TOP);
                                }
                                else
                                {
                                    //Renders listed icon
                                    if( currentFIleTexture!=NULL)
                                    {
                                        render_texture_resized(MAIN_RENDERER,currentFIleTexture,
                                                               currFileRect.x,currFileRect.y+(currFileRect.h-GENERAL_ICON_WIDTH)/2,
                                                               GENERAL_ICON_WIDTH,GENERAL_ICON_WIDTH,NULL,NULL,FA_LEFT,FA_TOP,fileIconColor );
                                    }
                                    render_new_text(MAIN_RENDERER,currFileRect.x+GENERAL_ICON_WIDTH,currFileRect.y+currFileRect.h/2,fileRenderName[0],GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_TEXTINPUT,FA_LEFT,FA_MIDDLE );
                                }

                                filesProcessedCount++;
                                iContentCol++;
                                if( iContentCol >= maxFilesInRows || fileBrowserModeBar->get_tab_pos()==2 )
                                {
                                    iContentCol = 0;
                                    jContentRow += 1;
                                }
                            }
                        }
                        //tinydir_next(&dir);
                    }
                }
                SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
                if( filesAndDirectoryPassedFilterCount > maxContentInView)
                {
                    fileDirYScroll->render_self(MAIN_RENDERER,&camera, &camera);
                }
                /*
                appDirectoryButton->render_self(MAIN_RENDERER,&camera,&camera);
                backButton->render_self(MAIN_RENDERER,&camera,&camera);
                desktopButton->render_self(MAIN_RENDERER,&camera,&camera);
                documentsButton->render_self(MAIN_RENDERER,&camera,&camera);
                downloadsButton->render_self(MAIN_RENDERER,&camera,&camera);
                homeButton->render_self(MAIN_RENDERER,&camera,&camera);
                musicButton->render_self(MAIN_RENDERER,&camera,&camera);
                mycomputerButton->render_self(MAIN_RENDERER,&camera,&camera);*/
                shortCutGList->render_self(MAIN_RENDERER,&camera,&camera);

                refreshButton->render_self(MAIN_RENDERER,&camera,&camera);

                yesButton->render_self(MAIN_RENDERER,&camera,&camera);
                cancelButton->render_self(MAIN_RENDERER,&camera,&camera);
                directoryViewBox->render_self(MAIN_RENDERER,&camera, &camera,true);
                fileBrowserModeBar->render_self(MAIN_RENDERER,&camera, &camera,true);
                newStringBox->render_self(MAIN_RENDERER,&camera, &camera,true);
                if( !isDirectorySearch)
                {
                    fileTypeDropDown->render_self(MAIN_RENDERER,&camera, &camera,true);
                }
                if( previewedImageTexture!=NULL && enterMyComputerMode==false && filePreviewBox.w!=0 && filePreviewBox.h!=0)
                {
                    if( filePreviewBox.w > previewedImageTexture->get_width()&& filePreviewBox.h> previewedImageTexture->get_height() )
                    {
                        previewedImageTexture->render_tex(MAIN_RENDERER,filePreviewBox.x,filePreviewBox.y);
                    }
                    else
                    {
                        imagePreviewScaleSize = std::max((float)previewedImageTexture->get_width()/ (float)(filePreviewBox.w), (float)previewedImageTexture->get_height()/(float)(filePreviewBox.h) );
                        if( imagePreviewScaleSize > 1)
                        {
                            previewedImageTexture->render_tex_resized(MAIN_RENDERER,filePreviewBox.x,filePreviewBox.y,(float)previewedImageTexture->get_width()/imagePreviewScaleSize,(float)previewedImageTexture->get_height()/imagePreviewScaleSize);
                        }
                        else
                        {
                            previewedImageTexture->render_tex_resized(MAIN_RENDERER,filePreviewBox.x,filePreviewBox.y,previewedImageTexture->get_width()*imagePreviewScaleSize,previewedImageTexture->get_height()*imagePreviewScaleSize);
                        }
                    }
                }
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
                GPE_MAIN_GUI->process_cursor();
                GPE_MAIN_GUI->render_gui_info(MAIN_RENDERER, true);
                MAIN_RENDERER->update_renderer();
            }
        }

        //tinydir_close(&dir);
        if( currentDirectory!=NULL)
        {
            delete currentDirectory;
            currentDirectory = NULL;
        }

        if( refreshButton!=NULL)
        {
            delete refreshButton;
            refreshButton = NULL;
        }
        if( appDirectoryButton!=NULL)
        {
            delete appDirectoryButton;
            appDirectoryButton = NULL;
        }
        if( examplesDirectoryButton!=NULL)
        {
            delete examplesDirectoryButton;
            examplesDirectoryButton = NULL;
        }
        /*if( tutorialsDirectoryButton!=NULL)
        {
            delete tutorialsDirectoryButton;
            tutorialsDirectoryButton = NULL;
        }*/
        if( backButton!=NULL)
        {
            delete backButton;
            backButton = NULL;
        }
        if( desktopButton!=NULL)
        {
            delete desktopButton;
            desktopButton = NULL;
        }
        if( documentsButton!=NULL)
        {
            delete documentsButton;
            documentsButton = NULL;
        }
        if( downloadsButton!=NULL)
        {
            delete downloadsButton;
            downloadsButton = NULL;
        }
        if( picturesButton!=NULL)
        {
            delete picturesButton;
            picturesButton = NULL;
        }
         if( musicButton!=NULL)
        {
            delete musicButton;
            musicButton = NULL;
        }
        if( homeButton!=NULL)
        {
            delete homeButton;
            homeButton = NULL;
        }
        if( mycomputerButton!=NULL)
        {
            delete mycomputerButton;
            mycomputerButton = NULL;
        }
        if( yesButton!=NULL)
        {
            delete yesButton;
            yesButton = NULL;
        }
        if( cancelButton!=NULL)
        {
            delete cancelButton;
            cancelButton = NULL;
        }
        if( newStringBox!=NULL)
        {
            delete newStringBox;
            newStringBox = NULL;
        }
        if( fileTypeDropDown!=NULL)
        {
            delete fileTypeDropDown;
            fileTypeDropDown = NULL;
        }
        if( directoryViewBox!=NULL)
        {
            delete directoryViewBox;
            directoryViewBox = NULL;
        }
        if( fileBrowserModeBar!=NULL)
        {
            delete fileBrowserModeBar;
            fileBrowserModeBar = NULL;
        }
        if( fileDirYScroll!=NULL)
        {
            delete fileDirYScroll;
            fileDirYScroll = NULL;
        }
        if( previewedImageTexture!=NULL)
        {
            delete previewedImageTexture;
            previewedImageTexture = NULL;
        }
        if( shortCutGList!=NULL)
        {
            delete shortCutGList;
            shortCutGList = NULL;
        }
        userInput->reset_all_input();
        previousDirectory = currentDirectoryInView;
        return returnFile;
    }
    userInput->reset_all_input();
	return returnFile;
}

std::string  GPE_GetOpenFileName( const std::string & prompt, std::string allowedFileTypes , std::string &previousDirectory)
{
    return GPE_GetPlainFileName( prompt, allowedFileTypes,previousDirectory,false);
}

std::string GPE_GetSaveFileName( const std::string & prompt, std::string allowedFileTypes, std::string &previousDirectory )
{
    return GPE_GetPlainFileName( prompt, allowedFileTypes,previousDirectory,true);
}

std::string  GPE_GetDirectoryName( const std::string & prompt, std::string &previousDirectory, bool isSaving )
{
    return GPE_GetPlainFileName(prompt,"",previousDirectory,isSaving, true);
}

int GPE_GetMessageBoxResult(const std::string  title, const std::string  prompt, int flagType)
{
    return 0;
}

void GPE_OpenProgram(std::string programLocation, std::string programInfo, bool openProgrmaInfoOnFail)
{
    record_error("Attempting to open ["+programLocation+"] with ["+programInfo+"] data...");
    if( file_exists(programLocation) || path_exists(programLocation) )
    {
        #ifdef _WIN32
            // win implementation
            //programLocation = "start "+urlIn;
            programInfo = string_replace_all(programInfo,"/","\\");
            if( GPE_Main_Logs!=NULL )
            {
                GPE_Main_Logs->log_general_line( "Starting "+programLocation );
            }
            ShellExecute(NULL,NULL,programLocation.c_str(),programInfo.c_str(),NULL,SW_SHOW );
        #elif __APPLE__
            // apple implementation
            programLocation = "open "+programLocation;
            if( GPE_Main_Logs!=NULL )
            {
                GPE_Main_Logs->log_general_line( "Starting "+programLocation );
            }
            system(programLocation.c_str() );
        #else
            // Linux and others implementation
            programLocation = "xdg-open \""+programLocation+"\"";
            system(programLocation.c_str() );
            if( GPE_Main_Logs!=NULL )
            {
                GPE_Main_Logs->log_general_line( "Starting "+programLocation );
            }
        #endif
    }
    else if( openProgrmaInfoOnFail )
    {
        GPE_OpenURL(programInfo);
    }
}

void GPE_OpenURL(std::string urlIn)
{
    //urlIn+="&";
    /**/
    #ifdef _WIN32
        // win implementation
        //urlIn = string_replace_all(urlIn," ","%20");
        urlIn = "start  \"\" \""+urlIn+"\"";
        record_error(urlIn);
        system(urlIn.c_str() );
	#elif __APPLE__
        // apple implementation
        urlIn = "open "+urlIn;
        system(urlIn.c_str() );
    #else
        // Linux and others implementation
        urlIn = "xdg-open \""+urlIn+"\"";
        system(urlIn.c_str() );
    #endif
}

void update_action_message(std::string newMessage)
{
    GPE_Action_Message = newMessage;
}

void update_popup_info(std::string newMessage, int selectedOpId, bool popIsContext)
{
    GPE_Action_Message = newMessage;
    GPE_Action_ID = selectedOpId;
    GPE_ACTION_IS_CONTEXT = popIsContext;
}


GPE_KeyPair::GPE_KeyPair(double idNumb, std::string str, std::string ksubstr)
{
    keyString = str;
    keyValue = idNumb;
    keySubString = ksubstr;
}

GPE_KeyPair::~GPE_KeyPair()
{

}

void update_rectangle(GPE_Rect * rectIn, double nx, double ny, double nw, double nh)
{
    if( rectIn!=NULL)
    {
        rectIn->x = nx;
        rectIn->y = ny;
        rectIn->w = nw;
        rectIn->h = nh;
    }
}

GPE_ScrollBar_XAxis::GPE_ScrollBar_XAxis()
{
    barBox.x = contextRect.x =  fullRect.x = 0;
    barBox.y = contextRect.y =  fullRect.y = 0;
    barBox.w = contextRect.w =  fullRect.w = 32;
    barBox.h = contextRect.h =  fullRect.h = 32;


    scrollWidth = 32;
    scrollPercent = 100;
    scrollPixels = 16;
    scrollXPos = 0;
    scrollDisplayPixels = 0;
    hasMoved = false;
    mouseXScrolPos =0;
    isOnScrollBox = false;
    isHeldOn = false;
}

GPE_ScrollBar_XAxis::~GPE_ScrollBar_XAxis()
{

}

int GPE_ScrollBar_XAxis::get_box_width()
{
    return barBox.w;
}

int GPE_ScrollBar_XAxis::get_box_height()
{
    return barBox.h;
}

bool GPE_ScrollBar_XAxis::has_moved()
{
    return hasMoved;
}

bool GPE_ScrollBar_XAxis::is_held()
{
    return isHeldOn;
}

bool GPE_ScrollBar_XAxis::is_scrolling()
{
    return isOnScrollBox;
}

void GPE_ScrollBar_XAxis::process_self(SDL_Rect * viewedSpace, SDL_Rect * cam, bool autoCorrect)
{
    cam = GPE_find_camera(cam);
    viewedSpace = GPE_find_camera(viewedSpace);
    bool doWork = true;
    //calculates the height needed to be scrolled.
    if( fullRect.w!=0)
    {
        if( contextRect.w < fullRect.w)
        {
            scrollPercent =  (float)contextRect.w/(float)fullRect.w;
            scrollDisplayPixels = (float)(barBox.w)*scrollPercent;
            scrollXPos = (float)(contextRect.x)/(float)(fullRect.w)*(float)barBox.w;
        }
        else
        {
            scrollPercent = 1;
            scrollDisplayPixels = barBox.w;
            scrollXPos = 0;
            doWork = false;
            contextRect.x = 0;
        }
    }

    float prevPosition = scrollXPos;
    hasMoved = false;
    isHeldOn = false;
    if( doWork)
    {
        if( point_within(userInput->mouse_x,userInput->mouse_y,viewedSpace->x+barBox.x-cam->x,viewedSpace->y+barBox.y-cam->y,viewedSpace->x+barBox.x+barBox.w-cam->x,viewedSpace->y+barBox.y+barBox.h-cam->y) )
        {
            if( userInput->check_mouse_pressed(0 ) )
            {
                isOnScrollBox = true;
                isHeldOn = false;
            }
            else if( userInput->check_mouse_down(0 ) )
            {
                if( !isOnScrollBox)
                {
                    isHeldOn = true;
                }
            }
        }
        else if( userInput->check_mouse_released(-1) )
        {
            isOnScrollBox = false;
            isHeldOn = false;
        }

        if(viewedSpace->x+barBox.x-cam->x <= userInput->mouse_x && userInput->mouse_x <= viewedSpace->x+barBox.x+barBox.w-cam->x )
        {
            if( userInput->check_mouse_down(0 ) && isOnScrollBox)
            {
                mouseXScrolPos = userInput->mouse_x - viewedSpace->x-barBox.x-cam->x; //translates mouse coords to viewed space coords
                if( isOnScrollBox)
                {
                    scrollXPos = mouseXScrolPos;
                }
            }
        }
        else
        {
            isOnScrollBox = false;
            isHeldOn = false;
        }

        if( userInput->check_mouse_released(0) || userInput->check_mouse_released(1))
        {
            if( isOnScrollBox)
            {
                userInput->reset_all_input();
            }
            isOnScrollBox = false;
            isHeldOn = false;
        }

        if( autoCorrect)
        {
            if( scrollXPos > barBox.w- scrollDisplayPixels)
            {
                scrollXPos = barBox.w- scrollDisplayPixels;
            }

            if( scrollXPos < 0)
            {
                scrollXPos = 0;
            }
        }

        prevPosition = contextRect.x;
        contextRect.x =  ( scrollXPos/barBox.w )*fullRect.w;

        if( contextRect.x!=prevPosition)
        {
            hasMoved = true;
        }
    }
    else
    {
        scrollPercent = 1;
        scrollDisplayPixels = barBox.w;
        scrollXPos = 0;
        contextRect.x = 0;
        //hasMoved = true;
    }

}

void GPE_ScrollBar_XAxis::render_self(GPE_Renderer *  cRender, SDL_Rect * viewedSpace, SDL_Rect * cam)
{
    cam = GPE_find_camera(cam);
    viewedSpace = GPE_find_camera(viewedSpace);
    if( cRender==NULL)
    {
        cRender = MAIN_RENDERER;
    }
    if( cRender!=NULL && cam!=NULL && viewedSpace!=NULL)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Scroll_Box_Color,false);
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Scroll_Box_Border_Color,true);
        int scrollRenderPixels = scrollDisplayPixels;
        if( scrollRenderPixels < barBox.h)
        {
            scrollRenderPixels = barBox.h;
        }
        if( isOnScrollBox )
        {
            render_rectangle(cRender,barBox.x+scrollXPos-cam->x,barBox.y-cam->y,barBox.x+scrollXPos+scrollRenderPixels-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Scroll_Box_Camera_Highlight_Color,false);
        }
        else
        {
            render_rectangle(cRender,barBox.x+scrollXPos-cam->x,barBox.y-cam->y,barBox.x+scrollXPos+scrollRenderPixels-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Scroll_Box_Camera_Color,false);
        }
        render_sprite_ext(cRender,GPE_TRIANGLE,2,barBox.x+barBox.h/4-cam->x,barBox.y+barBox.h/4-cam->y,barBox.h/2,barBox.h/2, GPE_MAIN_TEMPLATE->Scroll_Box_Arrow_Color );
        render_sprite_ext(cRender,GPE_TRIANGLE,0,barBox.x+barBox.w-barBox.h*3/4-cam->x,  barBox.y+barBox.h/4-cam->y,barBox.h/2,barBox.h/2,GPE_MAIN_TEMPLATE->Scroll_Box_Arrow_Color );
    }
}

void GPE_ScrollBar_XAxis::reset_scroller()
{
    hasMoved = false;
    isOnScrollBox = false;
    barBox.x = 0;
    barBox.y = 0;
    barBox.w = 0;
    barBox.h = 0;
}

GPE_ScrollBar_YAxis::GPE_ScrollBar_YAxis()
{
    documentActions = false;
    barBox.x = 0;
    barBox.y = 0;
    barBox.w = 16;
    barBox.h = 16;

    contextRect.x = fullRect.x = 0;
    contextRect.y = fullRect.y = 0;
    contextRect.w = fullRect.w = 32;
    contextRect.h = fullRect.h = 32;

    scrollHeight = 32;
    scrollPercent = 100;
    scrollDisplayPixels = 16;
    scrollYPos = 0;

    scrollYPos = 0;
    mouseYScrolPos = scrollYPos;
    isOnScrollBox = false;
    hasMoved = false;
    isHeldOn = false;
}

GPE_ScrollBar_YAxis::~GPE_ScrollBar_YAxis()
{

}

int GPE_ScrollBar_YAxis::get_box_width()
{
    return barBox.w;
}

int GPE_ScrollBar_YAxis::get_box_height()
{
    return barBox.h;
}

bool GPE_ScrollBar_YAxis::has_moved()
{
    return hasMoved;
}

bool GPE_ScrollBar_YAxis::is_held()
{
    return isHeldOn;
}

bool GPE_ScrollBar_YAxis::is_scrolling()
{
    return isOnScrollBox;
}

void GPE_ScrollBar_YAxis::process_self(SDL_Rect * viewedSpace, SDL_Rect * cam, bool autoCorrect)
{
    cam = GPE_find_camera(cam);
    viewedSpace = GPE_find_camera(viewedSpace);
    bool doWork = true;
    if( viewedSpace!=NULL && cam!=NULL )
    {
        //calculates the height needed to be scrolled.
        if( fullRect.h!=0)
        {
            if( contextRect.h < fullRect.h)
            {
                scrollPercent =  contextRect.h/fullRect.h;
                scrollDisplayPixels = (barBox.h)*scrollPercent;
                scrollYPos = ( contextRect.y/fullRect.h )*barBox.h;
            }
            else
            {
                scrollPercent = 1;
                scrollDisplayPixels = barBox.h;
                scrollYPos = 0;
                doWork = false;
            }
        }
        else
        {
            doWork = false;
        }
        hasMoved = false;
        isHeldOn = false;
        if( doWork)
        {
            if( point_between(userInput->mouse_x,userInput->mouse_y,barBox.x+viewedSpace->x-cam->x,barBox.y+viewedSpace->y-cam->y,barBox.x+barBox.w+viewedSpace->x-cam->x,barBox.y+barBox.h+viewedSpace->y-cam->y) )
            {
                if( userInput->check_mouse_pressed(0 ) )
                {
                    isOnScrollBox = true;
                }
            }

            if(barBox.y+viewedSpace->y-cam->y <= userInput->mouse_y && userInput->mouse_y <= barBox.y+barBox.h+viewedSpace->y-cam->y )
            {
                if( userInput->check_mouse_down(0 ) && isOnScrollBox)
                {
                    mouseYScrolPos = userInput->mouse_y - viewedSpace->y-barBox.y+cam->y; //translates mouse coords to viewed space coords
                    if( isOnScrollBox)
                    {
                        scrollYPos = mouseYScrolPos;
                    }
                }
                else
                {
                    isOnScrollBox = false;
                    isHeldOn = false;
                }
            }
            else
            {
                isOnScrollBox = false;
                isHeldOn = false;
            }

            if( userInput->check_mouse_released(0) || userInput->check_mouse_released(1))
            {
                if( isOnScrollBox)
                {
                    userInput->reset_all_input();
                }
                isOnScrollBox = false;
                isHeldOn = false;
            }
            float prevPosition = contextRect.y;
            //if( scrollPercent)
            {
                if( scrollYPos+scrollDisplayPixels > barBox.h )
                {
                    scrollYPos = barBox.h- scrollDisplayPixels;
                }

                if( scrollYPos < 0)
                {
                    scrollYPos = 0;
                }
            }
            contextRect.y =  ( scrollYPos/barBox.h )*fullRect.h;

            //if( autoCorrect)
            {
                if( contextRect.y+contextRect.h > fullRect.h )
                {
                    contextRect.y = fullRect.h- contextRect.h;
                }

                if( contextRect.y < 0)
                {
                    contextRect.y = 0;
                }
            }
            if( contextRect.y!=prevPosition)
            {
                hasMoved = true;
            }
        }
        else
        {
            scrollPercent = 1;
            scrollDisplayPixels = barBox.h;
            scrollYPos = 0;
            contextRect.y = 0;
        }
    }
}

void GPE_ScrollBar_YAxis::render_self(GPE_Renderer *  cRender, SDL_Rect * viewedSpace, SDL_Rect * cam)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( viewedSpace!=NULL && cam!=NULL )
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Scroll_Box_Color,false);
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Scroll_Box_Border_Color,true);
        int scrollRenderPixels = scrollDisplayPixels;
        if( scrollRenderPixels < barBox.w)
        {
            scrollRenderPixels = barBox.w;
        }
        if( isOnScrollBox )
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y+scrollYPos-cam->y,barBox.x+barBox.w-cam->x,barBox.y+scrollYPos+scrollRenderPixels-cam->y,GPE_MAIN_TEMPLATE->Scroll_Box_Camera_Highlight_Color,false);
        }
        else
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y+scrollYPos-cam->y,barBox.x+barBox.w-cam->x,barBox.y+scrollYPos+scrollRenderPixels-cam->y,GPE_MAIN_TEMPLATE->Scroll_Box_Camera_Color,false);
        }
        render_sprite_ext(cRender,GPE_TRIANGLE,1,barBox.x+barBox.w/4-cam->x,barBox.y+barBox.w/4,barBox.w/2-cam->y,barBox.w/2,GPE_MAIN_TEMPLATE->Scroll_Box_Arrow_Color);
        render_sprite_ext(cRender,GPE_TRIANGLE,3,barBox.x+barBox.w/4-cam->x,barBox.y+barBox.h-barBox.w*3/4-cam->y,barBox.w/2,barBox.w/2,GPE_MAIN_TEMPLATE->Scroll_Box_Arrow_Color);
    }
}

void GPE_ScrollBar_YAxis::reset_scroller()
{
    isOnScrollBox = false;
    hasMoved = false;
    barBox.x = 0;
    barBox.y = 0;
    barBox.w = 0;
    barBox.h = 0;

}

GPE_GeneralGuiElement::GPE_GeneralGuiElement()
{
    barBox.x =0;
    barBox.y = 0;
    barBox.w = 0;
    barBox.h = 0;
    maxWidth = 0;
    maxHeight = 0;
    autoResizes = false;
    clickedOutside = false;
    clickedOutside = false;
    hasScrollControl = false;
    hasArrowkeyControl = false;
    isClicked = false;
    isRightClicked = false;
    isEnabled = true;
    isHovered = false;
    guiListTypeName = "";
    guiListTypeId = 0;
    opName = "";
    descriptionText = "";
    showBorderBox = true;
    hasLineBreak = false;
    isModified = false;
    isInUse = false;
}

GPE_GeneralGuiElement::~GPE_GeneralGuiElement()
{

}

bool GPE_GeneralGuiElement::is_modified()
{
    return isModified;
}

bool GPE_GeneralGuiElement::is_inuse()
{
    return isInUse;
}

void GPE_GeneralGuiElement::switch_inuse(bool newUse)
{
    isInUse = newUse;
}

void GPE_GeneralGuiElement::update_paragraph( int foundMaxWidth )
{

}

void GPE_GeneralGuiElement::disable_self()
{
    isEnabled = false;
}

void GPE_GeneralGuiElement::enable_self()
{
    isEnabled = true;
}

int GPE_GeneralGuiElement::get_height()
{
    return barBox.h;
}

int GPE_GeneralGuiElement::get_max_height()
{
    return maxHeight;
}

int GPE_GeneralGuiElement::get_max_width()
{
    return maxWidth;
}

std::string GPE_GeneralGuiElement::get_name()
{
    return opName;
}

std::string GPE_GeneralGuiElement::get_element_type()
{
    return guiListTypeName;
}

std::string GPE_GeneralGuiElement::get_data()
{
    return "";
}

std::string GPE_GeneralGuiElement::get_plain_string()
{
    return "\""+opName+"\"";
}

void GPE_GeneralGuiElement::load_data(std::string dataString)
{
    dataString = dataString;
}

void GPE_GeneralGuiElement::remove_data(std::string dataString)
{
    dataString = dataString;
}

int GPE_GeneralGuiElement::get_width()
{
    return barBox.w;
}

int GPE_GeneralGuiElement::get_xpos()
{
    return barBox.x;

}

int GPE_GeneralGuiElement::get_x2pos()
{
    return barBox.x+barBox.w;
}

int GPE_GeneralGuiElement::get_ypos()
{
    return barBox.y;
}

int GPE_GeneralGuiElement::get_y2pos()
{
    return barBox.y+barBox.h;
}

bool GPE_GeneralGuiElement::is_clicked()
{
    return isClicked;
}

bool GPE_GeneralGuiElement::is_rightclicked()
{
    return isRightClicked;
}


bool GPE_GeneralGuiElement::is_enabled()
{
    return isEnabled;
}

bool GPE_GeneralGuiElement::is_hovered()
{
    return isHovered;
}

void GPE_GeneralGuiElement::move_pos(int newX, int newY)
{
    if( newX!=0)
    {
        barBox.x += newX;
    }
    if(newY!=0)
    {
        barBox.y += newY;
    }
}

void GPE_GeneralGuiElement::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    if( isEnabled)
    {
        bool wasHovered = isHovered;
        isClicked = false;
        isRightClicked = false;
        isHovered = false;
        clickedOutside = false;
        viewedSpace = GPE_find_camera(viewedSpace);
        cam = GPE_find_camera(cam);
        if(viewedSpace!=NULL && cam!=NULL)
        {
            if( point_between(userInput->mouse_x,userInput->mouse_y,viewedSpace->x,viewedSpace->y,viewedSpace->x+viewedSpace->w,viewedSpace->y+viewedSpace->h) )
            {
                if (point_between(userInput->mouse_x,userInput->mouse_y,barBox.x+viewedSpace->x-cam->x,barBox.y+viewedSpace->y-cam->y,barBox.x+barBox.w+viewedSpace->x-cam->x,barBox.y+barBox.h+viewedSpace->y-cam->y) )
                {
                    isHovered = true;
                    if( (int)descriptionText.size()>0 )
                    {
                        GPE_MAIN_GUI->update_tooltip(descriptionText);
                    }
                    else
                    {
                        GPE_MAIN_GUI->update_tooltip(opName);
                    }
                    if( userInput->check_mouse_released(0) )
                    {
                        isClicked = true;
                        isInUse = true;
                    }

                    if( userInput->check_mouse_pressed(1) )
                    {
                        isRightClicked = true;
                        isInUse = true;
                    }
                }
                else if( userInput->check_mouse_pressed(-1) || userInput->check_mouse_released(-1) )
                {
                    clickedOutside = true;
                    isInUse = false;
                    hasScrollControl = false;
                    hasArrowkeyControl = false;
                }
            }
            else if( userInput->check_mouse_pressed(-1)  || userInput->check_mouse_released(-1) )
            {
                clickedOutside = true;
                isInUse = false;
                hasScrollControl = false;
                hasArrowkeyControl = false;
            }
        }
    }
}

void GPE_GeneralGuiElement::prerender_self(GPE_Renderer * cRender)
{

}

void GPE_GeneralGuiElement::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw)
{

}

void GPE_GeneralGuiElement::set_name(std::string newName)
{
    opName = newName;
}

void GPE_GeneralGuiElement::set_coords(int newX, int newY)
{
    if( newX!=-1)
    {
        barBox.x = newX;
    }
    if(newY!=-1)
    {
        barBox.y = newY;
    }
}

void GPE_GeneralGuiElement::set_max_width( int nMW)
{
    maxWidth = nMW;
    if( maxWidth > 0 && barBox.w > maxWidth)
    {
        barBox.w = maxWidth;
    }
}

void GPE_GeneralGuiElement::set_max_height( int nMH)
{
    maxHeight = nMH;
    if( maxHeight > 0 && barBox.h > maxHeight)
    {
        barBox.h = maxHeight;
    }
}

void GPE_GeneralGuiElement::set_clicked( bool clickedVal)
{
    isClicked = clickedVal;
}


void GPE_GeneralGuiElement::set_rightclicked( bool clickedVal)
{
    isRightClicked = clickedVal;
}

void GPE_GeneralGuiElement::set_height(int newHeight)
{
    barBox.h = newHeight;
    /*if(barBox.y+barBox.h > SCREEN_HEIGHT)
    {
        barBox.h = SCREEN_HEIGHT-barBox.y;
    }*/
}

void GPE_GeneralGuiElement::set_hovered(bool hoverVal)
{
    isHovered = hoverVal;
}

void GPE_GeneralGuiElement::set_width(int newWid)
{
    barBox.w = newWid;
}

GPE_TabManager::GPE_TabManager()
{
    guiListTypeName = "tabmanager";
    barBox.x = 16;
    barBox.y = 16;
    barBox.w = SCREEN_WIDTH/2;
    barBox.h = 32;

    tabHeaderBox.x = 16;
    tabHeaderBox.y = 0;
    tabHeaderBox.w = SCREEN_WIDTH/2;
    tabHeaderBox.h = 28;
    tabBox.x = 16;
    tabBox.y = 32;
    tabBox.w = SCREEN_WIDTH;
    tabBox.h = SCREEN_HEIGHT-barBox.y;
    barXPadding = 4;
    barYPadding = 4;
    tabXPAdding = 4;

    tabToClose = -1;
    tabXHover = -1;
    tabInUse = -1;
    tabSize = -1; //defaults to equally divide the tab onto the screen

    miniTabSize = 48;
    extraSmallSize = 64;
    smallTabSize = 96;
    medTabSize = 128;
    largeTabSize = 160;
    extraLargeTabSize = 192;
    xxLargeTabSize = 256;
    tabsPerView = -1;
    tabPos = 0;
    openContextMenu = false;
}

GPE_TabManager::~GPE_TabManager()
{

}

void GPE_TabManager::add_new_tab(generalGameResource * newTabResource)
{
    if( newTabResource!=NULL)
    {
        if( (int)subOptions.size() > 0 )
        {
            int i = 0;
            int foundTab = -1;
            generalGameResource * cGResource = NULL;
            //makes sure the tab is not already open
            for( i = 0; i < (int)subOptions.size(); i +=1)
            {
                cGResource = subOptions[i];
                if( cGResource!=NULL)
                {
                    if( cGResource->matches( newTabResource) )
                    {
                        foundTab = i;
                        tabInUse = i;
                        move_to_tab(i);
                    }
                }
            }
            //if tab is not already open, open it
            if(foundTab==-1)
            {
                subOptions.push_back(newTabResource);
                newTabResource->justOpenedThisFrame = true;
                tabInUse = (int)subOptions.size() - 1;
            }
        }
        else
        {
            //automatically add  resource to when the tab bar is empty
            subOptions.push_back(newTabResource);
            tabInUse = 0;
            newTabResource->justOpenedThisFrame = true;
        }
        if( tabInUse < (int)subOptions.size() )
        {
            subOptions[tabInUse]->justOpenedThisFrame = true;
        }
    }
}

void GPE_TabManager::close_resource_tab( std::string projectParentName, int resIdIn)
{
    generalGameResource * tRes = NULL;
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        tRes = subOptions[i];
        if( tRes!=NULL)
        {
            if( projectParentName==tRes->parentProjectName && tRes->get_global_rid()==resIdIn)
            {
                close_tab(i);
            }
        }
        else
        {
            record_error("Removing tab value with unknown origin...");
            close_tab(i);
        }
    }
}

void GPE_TabManager::close_tab(int tabIdToClose)
{
    if( tabIdToClose>=0 && tabIdToClose < (int)subOptions.size() )
    {
        subOptions.erase(subOptions.begin()+tabIdToClose);
        if( tabInUse>=tabIdToClose)
        {
            tabInUse -=1;
            if( tabInUse < 0)
            {
                tabInUse = 0;
            }
        }
        tabToClose = -1;
        update_tabsizes();
        if( tabInUse >=0 && tabInUse < (int)subOptions.size() )
        {
            subOptions[tabInUse]->justOpenedThisFrame = true;
        }
        GPE_MAIN_GUI->close_finder();
        GPE_MAIN_GUI->update_temporary_message("","","",0);
    }
}

void GPE_TabManager::close_tabs_left(int tabIdToClose)
{
    if( tabIdToClose>0 && tabIdToClose < (int) subOptions.size() )
    {
        for( int i = tabIdToClose-1; i >=0; i--)
        {
            subOptions.erase(subOptions.begin()+i);
        }
        tabToClose = -1;
        tabInUse = 0;
        update_tabsizes();
        if( tabInUse < (int)subOptions.size() )
        {
            subOptions[tabInUse]->justOpenedThisFrame = true;
        }
        GPE_MAIN_GUI->close_finder();
        GPE_MAIN_GUI->update_temporary_message("","","",0);
    }
}

void GPE_TabManager::close_tabs_right(int tabIdToClose)
{
    if( tabIdToClose>=0 && tabIdToClose < (int) subOptions.size()-1 )
    {
        for( int i = (int) subOptions.size()-1; i >tabIdToClose; i--)
        {
            subOptions.erase(subOptions.begin()+i);
        }
        tabToClose = -1;
        update_tabsizes();
        if( tabInUse < (int)subOptions.size() )
        {
            subOptions[tabInUse]->justOpenedThisFrame = true;
        }
        GPE_MAIN_GUI->close_finder();
        GPE_MAIN_GUI->update_temporary_message("","","",0);
    }
}

void GPE_TabManager::close_tabs_from_project( std::string projectDirNameIn)
{
    generalGameResource * tRes = NULL;
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        tRes = subOptions[i];
        if( tRes!=NULL)
        {
            if( tRes->parentProjectName==projectDirNameIn)
            {
                close_tab(i);
            }
        }
        else
        {
            close_tab(i);
        }
    }
}

void GPE_TabManager::close_all_tabs()
{
    tabPos= 0;
    tabToClose = -1;
    tabXHover = -1;
    tabInUse= 0;
    subOptions.clear();
    update_tabsizes();

}

void GPE_TabManager::update_tabsizes()
{
    if( tabHeaderBox.w!=0)
    {
     //gets tab size for tabs, dependent on number of tiles
        int subOpCount = (int)subOptions.size();

        tabSize = subOpCount*xxLargeTabSize;
        tabsPerView = subOpCount;
        if( tabSize < tabHeaderBox.w)
        {
            tabSize = xxLargeTabSize;
        }
        else
        {
            tabSize = subOpCount*extraLargeTabSize;
            tabsPerView = subOpCount;
            if( tabSize < tabHeaderBox.w)
            {
                tabSize = extraLargeTabSize;
            }
            else
            {
                tabSize = subOpCount*largeTabSize;
                tabsPerView = subOpCount;
                if( tabSize < tabHeaderBox.w)
                {
                    tabSize = largeTabSize;
                }
                else
                {
                    tabSize = subOpCount*medTabSize;
                    if( tabSize < tabHeaderBox.w)
                    {
                        tabSize = medTabSize;
                    }
                    else
                    {
                        tabSize = subOpCount*smallTabSize;
                        if( tabSize < tabHeaderBox.w)
                        {
                            tabSize = smallTabSize;
                        }
                        else
                        {
                            tabSize = subOpCount*extraSmallSize;
                            if( tabSize < tabHeaderBox.w)
                            {
                                tabSize = extraSmallSize;
                            }
                            else
                            {
                                tabsPerView = floor(tabHeaderBox.w/miniTabSize);
                                tabSize = miniTabSize;
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
        tabSize = -1;
    }
}

generalGameResource * GPE_TabManager::get_selected_resource()
{
    if(tabInUse>=0 && tabInUse < (int)subOptions.size() )
    {
        generalGameResource * cGenResource = subOptions.at(tabInUse);
        return cGenResource;
    }
    return NULL;
}

void GPE_TabManager::process_tabbar()
{
    add_new_tab( GPE_get_selected_gresource() );
    update_tabsizes();
    generalGameResource * fResource = NULL;
    if( openContextMenu)
    {
        openContextMenu = false;
        int prevTabInUse = tabInUse;
        if( prevTabInUse >=0 && prevTabInUse < (int)subOptions.size() )
        {
            fResource = subOptions.at(prevTabInUse);
            GPE_open_context_menu(userInput->mouse_x,userInput->mouse_y);
            MAIN_CONTEXT_MENU->set_width(256);
            MAIN_CONTEXT_MENU->add_menu_option("Close",0);
            MAIN_CONTEXT_MENU->add_menu_option("Close All Tabs",1);
            MAIN_CONTEXT_MENU->add_menu_option("Close Other Tabs",2);
            MAIN_CONTEXT_MENU->add_menu_option("Close Tabs to the Left",3);
            MAIN_CONTEXT_MENU->add_menu_option("Close Tabs to the Right",4);
            MAIN_CONTEXT_MENU->add_menu_option("Save",5);
            int foundResult = get_popupmenu_result();
            switch(foundResult)
            {
                case 0:
                    tabToClose = prevTabInUse;
                    tabXHover = -1;
                    userInput->reset_all_input();
                break;
                case 1:
                    close_all_tabs();
                    userInput->reset_all_input();
                break;
                case 2:
                    close_tabs_right(prevTabInUse);
                    close_tabs_left(prevTabInUse);
                    tabInUse = 0;
                    if( tabInUse < (int)subOptions.size() )
                    {
                        subOptions[tabInUse]->justOpenedThisFrame = true;
                    }
                break;

                case 3:
                    close_tabs_left(prevTabInUse);
                    tabInUse = 0;
                    if( tabInUse < (int)subOptions.size() )
                    {
                        subOptions[tabInUse]->justOpenedThisFrame = true;
                    }
                break;

                case 4:
                    close_tabs_right(prevTabInUse);
                    tabInUse = prevTabInUse;
                    if( tabInUse < (int)subOptions.size() )
                    {
                        subOptions[tabInUse]->justOpenedThisFrame = true;
                    }
                break;

                case 5:
                    if( fResource!=NULL)
                    {
                        fResource->save_resource();
                    }
                break;

                default:
                break;
            }
            GPE_close_context_menu();
            update_tabsizes();
        }
    }
    if( tabHeaderBox.w!=0)
    {
        bool withinTabArea = false;
        if (point_between_rect(userInput->mouse_x,userInput->mouse_y,&tabHeaderBox) )
        {
            withinTabArea = true;
        }

        tabXHover = -1;
        if(withinTabArea)
        {
            int subPos = 0;
            for(int i=tabPos; i< (int)subOptions.size() && i < tabsPerView+tabPos; i+=1)
            {
                fResource = subOptions[i];
                if( fResource!=NULL)
                {
                    if (point_between(userInput->mouse_x,userInput->mouse_y,tabHeaderBox.x+(subPos)*(tabSize+tabXPAdding)+tabSize-16,tabHeaderBox.y,tabHeaderBox.x+(subPos)*(tabSize+tabXPAdding)+tabSize,tabHeaderBox.y+tabHeaderBox.h) )
                    {
                        GPE_MAIN_GUI->update_tooltip("Close "+fResource->get_name() );
                        tabXHover = i;
                        if(userInput->check_mouse_released(0) )
                        {
                            tabToClose = i;
                            tabXHover = -1;
                            userInput->reset_all_input();
                        }
                    }
                    else if(point_between(userInput->mouse_x,userInput->mouse_y,tabHeaderBox.x+subPos*(tabSize+tabXPAdding),tabHeaderBox.y,tabHeaderBox.x+(subPos)*(tabSize+tabXPAdding)+tabSize,tabHeaderBox.y+tabHeaderBox.h) )
                    {
                        GPE_MAIN_GUI->update_tooltip( fResource->get_name() );
                        if(userInput->check_mouse_released(0) )
                        {
                            tabInUse = i;
                            if( tabInUse < (int)subOptions.size() )
                            {
                                subOptions[tabInUse]->justOpenedThisFrame = true;
                            }
                            userInput->reset_all_input();
                        }
                        else if(userInput->check_mouse_released(1) )
                        {
                            tabInUse = i;
                            openContextMenu = true;
                        }
                        else if(userInput->check_mouse_released(2) )
                        {
                            tabToClose = i;
                            tabXHover = -1;
                            userInput->reset_all_input();
                        }
                    }
                }
                subPos+=1;
            }
        }

        if( userInput->check_keyboard_down(kb_ctrl)  )
        {
            if( userInput->check_keyboard_released(kb_w))
            {
                tabToClose = tabInUse;
            }
            else if( userInput->check_keyboard_released(kb_tab) )
            {
                if( userInput->shiftKeyIsPressed )
                {
                    move_to_tab(tabInUse-1);
                }
                else
                {
                    move_to_tab(tabInUse+1);
                }
            }
        }
        if( tabToClose>=0 && tabToClose < (int) subOptions.size() )
        {
            close_tab(tabToClose);
            tabToClose = -1;
        }
        if(!GPE_MAIN_GUI->mainResourceBar->beingResized )
        {
            if(tabInUse>=0 && tabInUse < (int)subOptions.size() )
            {
                generalGameResource * cGenResource = subOptions.at(tabInUse);
                if( cGenResource!=NULL)
                {
                    cGenResource->process_resource(&tabBox,&camera);
                }
            }
        }
    }
}

void GPE_TabManager::render_tabbar(GPE_Renderer * rendTarget, SDL_Rect *cam,bool forceRedraw)
{
    if( forceRedraw)
    {
        render_rect(rendTarget,&tabHeaderBox,GPE_MAIN_TEMPLATE->Program_Color,false);
        render_rect(rendTarget,&tabHeaderBox,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
    }
    if( (int)subOptions.size() >0 )
    {
        int subPos = 0;
        generalGameResource * fResource = NULL;
        std::string tabOptionStr = "";
        if( forceRedraw)
        {
            SDL_RenderSetViewport( rendTarget->get_renderer(), &tabHeaderBox );
            for(int i=tabPos; i< (int)subOptions.size() && i < tabsPerView+tabPos; i+=1)
            {
                fResource = subOptions[i];
                if( tabInUse==i)
                {
                    render_rectangle(rendTarget,subPos*(tabSize+tabXPAdding),0,(subPos)*(tabSize+tabXPAdding)+tabSize,tabHeaderBox.h,GPE_MAIN_TEMPLATE->Program_Color,false);
                }
                else
                {
                    render_rectangle(rendTarget,subPos*(tabSize+tabXPAdding),0,(subPos)*(tabSize+tabXPAdding)+tabSize,tabHeaderBox.h,GPE_MAIN_TEMPLATE->Program_Header_Color,false);
                }
                if( fResource!=NULL)
                {
                    if( fResource->is_modified() )
                    {
                        tabOptionStr = "* "+fResource->get_name();
                    }
                    else
                    {
                        tabOptionStr =fResource->get_name();
                    }
                    if( tabInUse==i)
                    {
                        render_new_text_ext(rendTarget,subPos*(tabSize+tabXPAdding)+tabSize/2,tabHeaderBox.h/2,tabOptionStr,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_CENTER,FA_MIDDLE,tabSize-tabXPAdding-16);
                    }
                    else
                    {
                        render_new_text_ext(rendTarget,subPos*(tabSize+tabXPAdding)+tabSize/2,tabHeaderBox.h/2,tabOptionStr,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT,FA_CENTER,FA_MIDDLE,tabSize-tabXPAdding-16);
                    }
                }

                if( tabXHover==i)
                {
                    render_rectangle(rendTarget,subPos*(tabSize+tabXPAdding)+tabSize-GENERAL_ICON_WIDTH,0,+(subPos)*(tabSize+tabXPAdding)+tabSize,+tabHeaderBox.h,c_red,false);
                }
                render_new_text(rendTarget,(subPos)*(tabSize+tabXPAdding)+tabSize-GENERAL_GPE_PADDING,+tabHeaderBox.h-barYPadding,"X",GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT,FA_RIGHT,FA_BOTTOM);


                /*if( i!=tabInUse)
                {
                    render_rectangle(rendTarget,subPos*(tabSize+tabXPAdding),0,(subPos)*(tabSize+tabXPAdding)+tabSize,tabHeaderBox.h,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
                    render_rectangle(rendTarget,subPos*(tabSize+tabXPAdding),0,(subPos)*(tabSize+tabXPAdding)+tabSize-1,tabHeaderBox.h-1,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
                }*/
                subPos+=1;
            }
            SDL_RenderSetViewport( rendTarget->get_renderer(), NULL );
        }
        if(tabInUse>=0 && tabInUse < (int)subOptions.size() )
        {
            generalGameResource * cGenResource = subOptions.at(tabInUse);
            if( cGenResource!=NULL)
            {
                if( userInput->input_received() || rendTarget->screen_was_cleared() || forceRedraw)
                {
                    //render_rect(rendTarget,&tabBox,GPE_MAIN_TEMPLATE->Program_Color,false);
                }
                SDL_RenderSetViewport( rendTarget->get_renderer(), &tabBox );
                cGenResource->render_resource(rendTarget,&tabBox,&camera,forceRedraw);
                SDL_RenderSetViewport( rendTarget->get_renderer(), NULL );
            }
        }
    }
    else if( forceRedraw)
    {
        render_rect(rendTarget,&tabBox,GPE_MAIN_TEMPLATE->Program_Color,false);
    }
    //render_rect(rendTarget,&tabBox,GPE_MAIN_TEMPLATE->Text_Box_Outline_Color,true);

}

int GPE_TabManager::search_for_string(std::string needle)
{
    int foundStrings = 0;
    generalGameResource * fOption  = NULL;
    GPE_Main_Logs->log_debug_line("Searching for ["+needle+"] in tabs");
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        fOption = subOptions[i];
        if( fOption!=NULL)
        {
            foundStrings+=fOption->search_for_string(needle);
        }
    }
    GPE_Main_Logs->log_debug_line("Found ["+needle+"] "+int_to_string(foundStrings)+" times...");
    return foundStrings;
}

int GPE_TabManager::search_and_replace_string(std::string needle, std::string newStr )
{
    int foundStrings = 0;
    generalGameResource * fOption  = NULL;
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        fOption = subOptions[i];
        if( fOption!=NULL)
        {
            foundStrings+=fOption->search_and_replace_string(needle, newStr);
        }
    }
    return foundStrings;
}

void GPE_TabManager::set_coords(int newX, int newY)
{
    if( newX!=-1)
    {
        barBox.x = newX;
        tabBox.x = newX;
        tabHeaderBox.x = newX;
        tabBox.x = tabHeaderBox.x = barBox.x;

        if( RENDER_RESOURCEBAR_LEFT)
        {
            tabBox.w = tabHeaderBox.w = barBox.w = SCREEN_WIDTH - barBox.x;
        }
        else
        {
            //tabBox.w = tabHeaderBox.w = barBox.w = SCREEN_WIDTH - barBox.w;
        }
    }
    if(newY!=-1)
    {
        barBox.y = newY;
        tabHeaderBox.y = newY;
        tabBox.y = newY+tabHeaderBox.h;
    }
}

void GPE_TabManager::set_height(int newHeight)
{
    barBox.h = newHeight;
    tabBox.h = newHeight-tabHeaderBox.h;
}

void GPE_TabManager::set_width(int newWidth)
{
    tabBox.w = newWidth;
    tabHeaderBox.w = newWidth;
    barBox.w = newWidth;
}

void GPE_TabManager::move_to_tab(int newTabId)
{
    if( (int)subOptions.size() > 0)
    {
        tabInUse= newTabId;
        if( newTabId<0)
        {
            tabInUse = subOptions.size()-1;
        }
        if( tabInUse >=(int)subOptions.size() )
        {
            tabInUse = 0;
        }
    }
    else
    {
        tabInUse = 0;
        tabPos = 0;
    }
}

GPE_TabBar::GPE_TabBar()
{
    tabIsRightClicked = false;
    isInUse = false;
    guiListTypeName = "tabbar";
    barBox.x = 16;
    barBox.y = 16;
    barBox.w = 0;
    barBox.h = 28;

    barXPadding = GENERAL_GPE_PADDING*2;
    barYPadding = 4;
    fontTextWidth = 12;
    fontTextHeight = 12;
    if( DEFAULT_FONT!=NULL)
    {
         DEFAULT_FONT->get_metrics("A",&fontTextWidth,&fontTextHeight);
    }
    else
    {
        fontTextWidth = 12;
        fontTextHeight = 12;
    }
    tabInUse = 0;
    tabSize = -1; //defaults to equally divide the tab onto the screen

    miniTabSize = 48;
    extraSmallSize = 64;
    smallTabSize = 96;
    medTabSize = 128;
    largeTabSize = 160;
    extraLargeTabSize = 192;
    xxLargeTabSize = 256;
    tabsPerView = -1;
    tabPos = 0;
}

GPE_TabBar::~GPE_TabBar()
{
    subOptions.clear();
}

void GPE_TabBar::add_new_tab(std::string newOption, bool switchToNew )
{
    if( (int)newOption.size() > 0)
    {
        //automatically add  resource to when the tab bar is empty
        if( switchToNew)
        {
            tabInUse = (int)subOptions.size();
        }
        subOptions.push_back(newOption);
        barBox.w+=fontTextWidth*(int)newOption.size()+barXPadding;
    }
}

void GPE_TabBar::open_tab(int tabId)
{
    if( tabId >=0 && tabId < (int)subOptions.size() )
    {
        tabInUse = tabId;
    }
    else
    {
        tabInUse = 0;
    }
}

void GPE_TabBar::open_tab(std::string tabName)
{
    if( (int)tabName.size() > 0)
    {
        for( int i = 0; i < (int)subOptions.size(); i++)
        {
            if( tabName==subOptions[i] )
            {
                tabInUse = i;
                break;
            }
        }
    }
}

std::string GPE_TabBar::get_selected_name()
{
    if( (int)subOptions.size() > 0)
    {
        if( tabInUse >=0 && tabInUse < (int)subOptions.size() )
        {
            return subOptions[tabInUse];
        }
    }
    return "";
}

void GPE_TabBar::process_self(SDL_Rect *viewedSpace,SDL_Rect *cam)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    tabIsRightClicked = false;
    if( barBox.w!=0 && viewedSpace!=NULL && cam!=NULL)
    {
        GPE_GeneralGuiElement::process_self(viewedSpace, cam);
        if( isClicked || isRightClicked)
        {
            isInUse = true;
        }
        else if( clickedOutside)
        {
            isInUse = false;
        }
        if( isInUse)
        {
            if( isClicked || isRightClicked)
            {
                int cTabXPos = barBox.x+viewedSpace->x-cam->x;
                int cTabX2Pos = barBox.x+viewedSpace->x-cam->x;
                int cTabYPos = barBox.y+viewedSpace->y-cam->y;
                int cTabY2Pos = barBox.y+barBox.h+viewedSpace->y-cam->y;
                for(int i=0; i< (int)subOptions.size(); i++)
                {
                    cTabX2Pos+=fontTextWidth*(int)subOptions[i].size()+barXPadding;
                    if(point_between(userInput->mouse_x,userInput->mouse_y,cTabXPos,cTabYPos,cTabX2Pos,cTabY2Pos) )
                    {
                        tabInUse = i;
                        if( isRightClicked )
                        {
                            tabIsRightClicked = true;
                        }
                    }
                    cTabXPos = cTabX2Pos+1;
                }
            }
            if( userInput->check_keyboard_released(kb_left) &&  tabInUse > 0)
            {
                tabInUse--;
            }
            else if( userInput->check_keyboard_released(kb_right) && tabInUse < (int)subOptions.size()-1 )
            {
                tabInUse++;
            }
        }
    }
}

void GPE_TabBar::render_self(GPE_Renderer * rendTarget, SDL_Rect *viewedSpace,SDL_Rect *cam , bool forceRedraw)
{
    //render_rect(rendTarget,&barBox,barColor,false);
    //render_rect(rendTarget,&barBox,barOutlineColor,true);
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if(forceRedraw && viewedSpace!=NULL && cam!=NULL)
    {
        if( (int)subOptions.size() >0 )
        {
            int cTabXPos = barBox.x-cam->x;
            int cTabX2Pos = barBox.x-cam->x;
            int thisTabWidth = 0;
            for(int i=0; i< (int)subOptions.size(); i++)
            {
                thisTabWidth=fontTextWidth*(int)subOptions[i].size()+barXPadding;
                cTabX2Pos+=thisTabWidth;
                if( tabInUse==i)
                {
                    render_rectangle(rendTarget,cTabXPos,barBox.y-cam->y,cTabX2Pos,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Program_Color,false);
                    render_rectangle(rendTarget,cTabXPos,barBox.y-cam->y,cTabX2Pos,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
                    render_new_text(rendTarget,cTabXPos+thisTabWidth/2,barBox.y+barBox.h/2-cam->y,subOptions[i],GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT,FA_CENTER,FA_MIDDLE);
                }
                else
                {
                    render_rectangle(rendTarget,cTabXPos,barBox.y-cam->y,cTabX2Pos,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Program_Header_Color,false);
                    render_rectangle(rendTarget,cTabXPos,barBox.y-cam->y,cTabX2Pos,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
                    render_new_text(rendTarget,cTabXPos+thisTabWidth/2,barBox.y+barBox.h/2-cam->y,subOptions[i],GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_CENTER,FA_MIDDLE);
                }
                cTabXPos = cTabX2Pos+1;
            }
        }
        else
        {
            render_rectangle(rendTarget,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Program_Color,false);
            render_rectangle(rendTarget,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
        }
    }
}



GPE_StatusBar::GPE_StatusBar()
{
    guiListTypeName = "statusbar";
    codeEditorStatusBarString = "";
    insertModeString = "";
}

GPE_StatusBar::~GPE_StatusBar()
{

}

void GPE_StatusBar::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    codeEditorStatusBarString= "";
    insertModeString = "";
}

void GPE_StatusBar::render_self(GPE_Renderer * cRender, SDL_Rect *viewedSpace,SDL_Rect *cam, bool forceRedraw)
{
    if( isEnabled && forceRedraw && cRender!=NULL && barBox.h >0 && FONT_STATUSBAR!=NULL)
    {
        render_rect(cRender,&barBox,GPE_MAIN_TEMPLATE->Program_Color,false);
        int statusBarStringWidth = 0, statusBarStringHeight = 0;
        int projectNameWidth = 0, projectNameHeight = 0;
        if( (int)CURRENT_PROJECT_NAME.size() > 0)
        {
            std::string  projectNameToRender = CURRENT_PROJECT_NAME;

            if( MAIN_EDITOR_SETTINGS!=NULL && MAIN_EDITOR_SETTINGS->showShortProjectNames!=NULL  )
            {
                if( MAIN_EDITOR_SETTINGS->showShortProjectNames->is_clicked() )
                {
                    projectNameToRender = get_file_noext( get_local_from_global_file(CURRENT_PROJECT_NAME) );

                }
            }
            FONT_STATUSBAR->get_metrics(projectNameToRender,&projectNameWidth, &projectNameHeight);

            if( (int)codeEditorStatusBarString.size() > 0)
            {
                FONT_STATUSBAR->get_numbered_metrics(codeEditorStatusBarString,&statusBarStringWidth, &statusBarStringHeight);
                if( barBox.w > statusBarStringWidth+projectNameWidth +GENERAL_GPE_PADDING )
                {
                    render_new_text(cRender,barBox.x,barBox.y+GENERAL_GPE_PADDING,projectNameToRender,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_STATUSBAR,FA_LEFT,FA_TOP);
                    //render_rectangle(cRender,barBox.x+projectNameWidth,barBox.y,barBox.x+barBox.w,barBox.y+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Color,false);
                    render_bitmap_text(cRender,barBox.x+projectNameWidth+GENERAL_GPE_PADDING,barBox.y+GENERAL_GPE_PADDING,codeEditorStatusBarString,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_STATUSBAR,FA_LEFT,FA_TOP);
                }
                else
                {
                    render_bitmap_text(cRender,barBox.x+GENERAL_GPE_PADDING,barBox.y+GENERAL_GPE_PADDING,codeEditorStatusBarString,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_STATUSBAR,FA_LEFT,FA_TOP);
                }
            }
            else if( barBox.w > projectNameWidth +GENERAL_GPE_PADDING )
            {
                render_new_text(cRender,barBox.x+GENERAL_GPE_PADDING,barBox.y+GENERAL_GPE_PADDING,projectNameToRender,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_STATUSBAR,FA_LEFT,FA_TOP);
            }
            else
            {
                render_new_text(cRender,barBox.x+barBox.w-GENERAL_GPE_PADDING/2,barBox.y+GENERAL_GPE_PADDING,projectNameToRender,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_STATUSBAR,FA_RIGHT,FA_TOP);
            }
        }
        else if( (int)codeEditorStatusBarString.size() > 0)
        {
            FONT_STATUSBAR->get_numbered_metrics(codeEditorStatusBarString,&statusBarStringWidth, &statusBarStringHeight);
            render_bitmap_text(cRender,barBox.x+GENERAL_GPE_PADDING,barBox.y+GENERAL_GPE_PADDING,codeEditorStatusBarString,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_STATUSBAR,FA_LEFT,FA_TOP);
        }
        render_rect(cRender,&barBox,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
    }
}

void GPE_StatusBar::reset_statusbar()
{
    codeEditorStatusBarString = "";
    insertModeString = "";
}

void GPE_StatusBar::set_codestring(std::string newCodeString)
{
    codeEditorStatusBarString = newCodeString;
}

void GPE_StatusBar::set_insertmode(std::string newInsertMode)
{
    insertModeString = newInsertMode;
}

GPE_Log_Entry::GPE_Log_Entry(std::string projectName, std::string resName, std::string logTxt, std::string funcName, int lineNumb, int charNumb)
{
    projectLogBelongsTo = projectName;
    resourceNameRelated = resName;
    functionName = funcName; //where applicable
    logText = logTxt;
    lineToReach = lineNumb;
    characterToReach = charNumb;
}


GPE_Log_Entry::~GPE_Log_Entry()
{
    projectLogBelongsTo = "";
    resourceNameRelated = "";
    functionName = ""; //where applicable
    logText = "";
}

GPE_LogManager::GPE_LogManager()
{
    isVisible = true;
    menuResized = false;
    beingResized = false;
    justResized = false;
    logTabs = new GPE_TabBar();
    logTabs->add_new_tab("Game Pencil Log",true);
    logTabs->add_new_tab("Build Log",false);
    logTabs->add_new_tab("Search",false);
    logTabs->add_new_tab("Search Results",false);
    logTabs->add_new_tab("Other...",false);
    /*logTabs->add_new_tab("Debug Log");
    logTabs->add_new_tab("Search Results");*/

    generalTextLog = new GPE_TextAreaInputBasic();
    generalTextLog->isCodeEditor = false;
    generalTextLog->isTextLog = true;
    generalTextLog->set_read_only();
    generalTextLog->clear_all_lines();

    debugTextLog = new GPE_TextAreaInputBasic();
    debugTextLog->isCodeEditor = false;
    debugTextLog->isTextLog = true;
    debugTextLog->set_read_only();
    debugTextLog->clear_all_lines();

    buildTextLog = new GPE_TextAreaInputBasic();
    buildTextLog->isCodeEditor = false;
    buildTextLog->isTextLog = true;
    buildTextLog->set_read_only();
    buildTextLog->clear_all_lines();

    otherLog = new GPE_TextAreaInputBasic();
    otherLog->isCodeEditor = false;
    otherLog->isTextLog = true;
    otherLog->set_read_only();
    otherLog->clear_all_lines();

    logToView = NULL;
    seekedY1Pos = 0;
    bottomInfoList = new GPE_GuiElementList();
    emptyResultsLabel = new GPE_Label_Text("No results found","No results found");
}

GPE_LogManager::~GPE_LogManager()
{
    if( bottomInfoList!=NULL)
    {
        bottomInfoList->clear_list();
        delete bottomInfoList;
        bottomInfoList = NULL;
    }
    if( logTabs!=NULL)
    {
        delete logTabs;
        logTabs = NULL;
    }

    if( generalTextLog!=NULL)
    {
        delete generalTextLog;
        generalTextLog = NULL;
    }

    if( debugTextLog!=NULL)
    {
        delete debugTextLog;
        debugTextLog = NULL;
    }

    if( buildTextLog!=NULL)
    {
        delete buildTextLog;
        buildTextLog = NULL;
    }
    if( emptyResultsLabel!=NULL)
    {
        delete emptyResultsLabel;
        emptyResultsLabel = NULL;
    }
}

void GPE_LogManager::clear_search_anchors()
{
    if( (int)searchAnchors.size() > 0)
    {
        GPE_TextAnchor * tAnchor = NULL;
        for( int i = (int)searchAnchors.size()-1; i >=0; i--)
        {
            tAnchor = searchAnchors[i];
            delete tAnchor;
            tAnchor = NULL;
        }
        searchAnchors.clear();
    }
    if( FONT_LABEL_ANCHOR!=NULL)
    {
        FONT_LABEL_ANCHOR->clear_cache();
    }
}

void GPE_LogManager::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( barBox.h < 32 && GPE_MAIN_GUI!=NULL )
    {
         GPE_MAIN_GUI->close_finder();
    }


    if( isEnabled && isVisible && viewedSpace!=NULL && cam!=NULL && barBox.h >8 )
    {
        std::string pastTab = logTabs->get_selected_name();
        if( pastTab!="Search" && GPE_MAIN_GUI!=NULL )
        {
             GPE_MAIN_GUI->close_finder();
        }
        //resize_code
        if( beingResized)
        {
            if( point_between(userInput->mouse_x,userInput->mouse_y,barBox.x,0,barBox.x+barBox.w,SCREEN_HEIGHT-32) )
            {
                seekedY1Pos = userInput->mouse_y;
                GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZENS);
                if(userInput->check_mouse_released(0) )
                {
                    justResized = true;
                    beingResized = false;
                    barBox.y = userInput->mouse_y;
                    if( barBox.y < 96)
                    {
                        barBox.y = 96;
                    }

                    barBox.h = SCREEN_HEIGHT-barBox.y-GPE_Main_Statusbar->get_height();
                    if( barBox.h < 16 && isVisible)
                    {
                        barBox.h = 16;
                        barBox.y = SCREEN_HEIGHT-GPE_Main_Statusbar->get_height()-32;
                    }
                    userInput->reset_all_input();
                    //GPE_MAIN_GUI->save_settings();
                }
            }
            else
            {
                beingResized = false;
            }
        }
        menuResized = false;

		if( logToView==NULL || (logToView->hasScrollControl==false) )
        {
            if( point_within(userInput->mouse_x,userInput->mouse_y,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+8) )
            {
                GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZENS);
                if(userInput->check_mouse_pressed(0) )
                {
                    beingResized = true;
                }
            }
        }

        menuResized = false;
		if( logToView!=NULL )
        {
            if( point_within(userInput->mouse_x,userInput->mouse_y,barBox.x,barBox.y-2,barBox.x+barBox.w,barBox.y+8) )
            {
                GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZENS);
                if(userInput->check_mouse_pressed(0) )
                {
                    beingResized = true;
                }
            }
        }

        if( barBox.h > 32)
        {
            if( barBox.y < 96)
            {
                barBox.h = SCREEN_HEIGHT-GPE_Main_Statusbar->get_height()-96;
            }
            if( logTabs!=NULL)
            {
                GPE_GeneralGuiElement::process_self(viewedSpace,cam);

                logTabs->set_width(barBox.w);
                logTabs->set_height(24);
                logTabs->set_coords(barBox.x, barBox.y+barBox.h-24);
                logTabs->process_self(viewedSpace,cam);

                if( logTabs->tabIsRightClicked )
                {
                    logTabs->tabIsRightClicked = false;
                    GPE_open_context_menu(userInput->mouse_x,userInput->mouse_y-32);
                    MAIN_CONTEXT_MENU->set_width(256);
                    MAIN_CONTEXT_MENU->add_menu_option("Copy Log to Clipboard",0);
                    MAIN_CONTEXT_MENU->add_menu_option("Clear THIS Log",1);
                    MAIN_CONTEXT_MENU->add_menu_option("Clear ALL Logs",2);
                    MAIN_CONTEXT_MENU->add_menu_option("Clear Search Results",3);
                    //MAIN_CONTEXT_MENU->add_menu_option("Tabs at Top",3);
                    int foundResult = get_popupmenu_result();
                    switch(foundResult)
                    {
                        case 0:
                            if( logToView!=NULL )
                            {
                                logToView->copy_all();
                            }
                        break;

                            case 1:
                            if( logToView!=NULL )
                            {
                                logToView->clear_all_lines();
                            }
                        break;

                        case 2:
                            clear_all_logs();
                        break;

                        case 3:
                            clear_search_anchors();
                        break;

                        default:
                            logToView = NULL;
                        break;
                    }
                }

                if( pastTab != logTabs->get_selected_name() )
                {
                    bottomInfoList->reset_self();
                }
                logToView = NULL;

                if( barBox.h >= 64 && FONT_TEXTINPUT!=NULL)
                {
                    if( logTabs->get_selected_name()=="Game Pencil Log")
                    {
                        logToView = generalTextLog;
                        GPE_MAIN_GUI->close_finder();
                    }
                    else if( logTabs->get_selected_name()=="Build Log")
                    {
                        logToView = buildTextLog;
                        GPE_MAIN_GUI->close_finder();
                    }
                    else if( logTabs->get_selected_name()=="Debug Log")
                    {
                        logToView = generalTextLog;
                        GPE_MAIN_GUI->close_finder();
                    }
                    else if( logTabs->get_selected_name()=="Other...")
                    {
                        logToView = otherLog;
                        GPE_MAIN_GUI->close_finder();
                    }
                    else
                    {
                        logToView= NULL;
                        if( logTabs->get_selected_name()=="Search" && bottomInfoList!=NULL )
                        {
                            if( pastTab != "Search" )
                            {
                                userInput->reset_all_input();
                                barBox.h = 96;
                                if( GPE_MAIN_GUI->previousSearchMode != GPE_MAIN_GUI->textSearchMode )
                                {
                                    GPE_MAIN_GUI->textSearchMode = GPE_MAIN_GUI->previousSearchMode;
                                    if( GPE_MAIN_GUI->textSearchMode==SEARCH_MODE_FIND || GPE_MAIN_GUI->textSearchMode==SEARCH_MODE_FINDALL )
                                    {
                                        GPE_MAIN_GUI->findTextStringBox->switch_inuse( true);
                                        GPE_MAIN_GUI->findTextStringBox->inputSubmitted = false;
                                        GPE_MAIN_GUI->findTextStringBox->resubmissionAllowed = true;
                                        GPE_MAIN_GUI->findTextStringBox->set_clicked( true);
                                        GPE_MAIN_GUI->findButton->set_clicked( false);
                                        GPE_MAIN_GUI->findAllButton->set_clicked( false);
                                        record_error("Opening Finder...");
                                    }
                                    else if( GPE_MAIN_GUI->textSearchMode==SEARCH_MODE_GOTO )
                                    {
                                        GPE_MAIN_GUI->goToLineStringBox->switch_inuse( true);
                                        GPE_MAIN_GUI->goToLineStringBox->inputSubmitted = false;
                                        GPE_MAIN_GUI->goToLineStringBox->resubmissionAllowed = true;
                                        GPE_MAIN_GUI->goToLineStringBox->set_clicked( true);
                                        GPE_MAIN_GUI->goToButton->set_clicked( false);
                                        record_error("Opening Goto Finder...");
                                    }
                                    else
                                    {
                                        GPE_MAIN_GUI->findTextStringBox->switch_inuse( true);
                                        GPE_MAIN_GUI->findTextStringBox->set_clicked( false);
                                        GPE_MAIN_GUI->findButton->set_clicked( true);
                                        GPE_MAIN_GUI->findAllButton->set_clicked( false);
                                        GPE_MAIN_GUI->findTextStringBox->inputSubmitted = false;
                                        GPE_MAIN_GUI->findTextStringBox->resubmissionAllowed = true;
                                        record_error("Opening Finder thru Else...");
                                    }
                                }
                                //GPE_Main_Logs->open_search_mode();
                            }

                            bottomInfoList->set_coords(barBox.x,barBox.y);
                            bottomInfoList->set_width(barBox.w);
                            bottomInfoList->set_height(barBox.h-32);
                            bottomInfoList->barYMargin = bottomInfoList->barYPadding = GENERAL_GPE_PADDING/2;
                            bottomInfoList->barXMargin = bottomInfoList->barXPadding = GENERAL_GPE_PADDING;
                            bottomInfoList->clear_list();
                            switch( GPE_MAIN_GUI->textSearchMode )
                            {
                                //find case
                                case SEARCH_MODE_FIND:
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findTextStringBox,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findButton,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findMatchCase,false);
                                break;

                                 case SEARCH_MODE_FINDALL:
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findTextStringBox,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findButton,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findMatchCase,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->scopeLabel,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findScope,false);

                                break;

                                //goto case
                                case SEARCH_MODE_GOTO:
                                        bottomInfoList->add_gui_element(GPE_MAIN_GUI->goToLineStringBox,false);
                                        bottomInfoList->add_gui_element(GPE_MAIN_GUI->goToButton,false);
                                break;

                                case SEARCH_MODE_REPLACE:
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findTextStringBox,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findButton,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findMatchCase,true);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->replaceTextStringBox,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->replaceButton,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->replaceAllButton,false);
                                break;

                                case SEARCH_MODE_REPLACEALL:
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findTextStringBox,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findButton,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findMatchCase,true);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->replaceTextStringBox,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->replaceButton,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->replaceAllButton,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->scopeLabel,false);
                                    bottomInfoList->add_gui_element(GPE_MAIN_GUI->findScope,false);
                                break;

                                //find/replace case
                                default:
                                    GPE_MAIN_GUI->close_finder();
                                    bottomInfoList->clear_list();
                                    /**/
                                break;
                            }
                            bottomInfoList->process_self(viewedSpace,cam);
                            if( GPE_MAIN_GUI->textSearchMode == SEARCH_MODE_FINDALL )
                            {
                                if( GPE_MAIN_GUI->findButton->is_clicked() || GPE_MAIN_GUI->findTextStringBox->was_submitted() )
                                {
                                    if( (int)GPE_MAIN_GUI->findTextStringBox->get_string().size() > 0 )
                                    {
                                        if( GPE_MAIN_GUI->findScope!=NULL)
                                        {
                                            GPE_Main_Logs->clear_search_anchors();
                                            if( GPE_MAIN_GUI->findScope->get_selected_tag()=="Open Tabs" && GPE_Main_TabManager!=NULL )
                                            {
                                                GPE_Main_Logs->log_general_comment("Searching Tabs for ["+GPE_MAIN_GUI->findTextStringBox->get_string()+"]...");
                                                GPE_Main_TabManager->search_for_string(GPE_MAIN_GUI->findTextStringBox->get_string() );
                                            }
                                            else if( GPE_MAIN_GUI->findScope->get_selected_tag()=="Project Resources" && CURRENT_PROJECT!=NULL )
                                            {
                                                if( CURRENT_PROJECT->RESC_PROJECT_FOLDER!=NULL)
                                                {
                                                    GPE_Main_Logs->log_general_comment("Searching Project for ["+GPE_MAIN_GUI->findTextStringBox->get_string()+"]...");
                                                    CURRENT_PROJECT->RESC_PROJECT_FOLDER->search_for_string(GPE_MAIN_GUI->findTextStringBox->get_string() );
                                                }
                                            }
                                            userInput->reset_all_input();
                                            open_search_results();
                                        }
                                    }
                                    else
                                    {
                                        display_user_alert("Search Error","You can not search for an empty string!");
                                    }
                                }
                            }
                        }
                        else if( logTabs->get_selected_name()=="Search Results" && bottomInfoList!=NULL)
                        {
                            GPE_MAIN_GUI->close_finder();
                            GPE_TextAnchor * fAnchor = NULL;

                            bottomInfoList->set_coords(barBox.x,barBox.y);
                            bottomInfoList->set_width(barBox.w);
                            bottomInfoList->set_height(barBox.h-32);
                            bottomInfoList->clear_list();
                            if( (int)searchAnchors.size()== 0 )
                            {
                                bottomInfoList->add_gui_element(emptyResultsLabel,true);
                            }
                            else
                            {
                                bottomInfoList->barYMargin = bottomInfoList->barXMargin =  0;
                                bottomInfoList->barYPadding = bottomInfoList->barXPadding = 0;
                                for( int iAnchor = 0; iAnchor < (int)searchAnchors.size(); iAnchor++)
                                {
                                    fAnchor = searchAnchors[iAnchor];
                                    if( fAnchor!=NULL)
                                    {
                                        bottomInfoList->add_gui_element(fAnchor,true);
                                    }
                                }
                            }
                            bottomInfoList->set_full_width();
                            bottomInfoList->process_self(viewedSpace,cam);
                        }
                        else
                        {
                            GPE_MAIN_GUI->close_finder();
                        }
                    }
                    if( logToView!=NULL)
                    {
                        logToView->set_coords(barBox.x,barBox.y+8);
                        logToView->set_width(barBox.w);
                        logToView->set_height(barBox.h-32);
                        logToView->process_self(viewedSpace,cam);
                    }
                }
            }
        }
    }
}

void GPE_LogManager::render_self(GPE_Renderer * cRender, SDL_Rect *viewedSpace,SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( isEnabled && forceRedraw && cRender!=NULL && barBox.h >8 )
    {
        render_rect(cRender,&barBox,GPE_MAIN_TEMPLATE->Text_Box_Color,false);
        if( barBox.h > 32 && logTabs!=NULL)
        {
            if( barBox.h >= 64 && FONT_TEXTINPUT!=NULL)
            {
                if( logToView!=NULL)
                {
                    logToView->render_self(cRender,viewedSpace,cam,forceRedraw);
                }
                else if( bottomInfoList!=NULL)
                {
                    bottomInfoList->render_self(cRender,viewedSpace,cam,forceRedraw);
                }
            }
            logTabs->render_self(cRender,viewedSpace,cam,forceRedraw);
        }
        render_rect(cRender,&barBox,GPE_MAIN_TEMPLATE->Text_Box_Outline_Color,true);
    }
    if( beingResized && viewedSpace!=NULL && cam!=NULL && seekedY1Pos>0)
    {
        if( seekedY1Pos < 96)
        {
            render_rectangle(cRender,barBox.x, seekedY1Pos-2,barBox.x+barBox.w,seekedY1Pos+2,GPE_MAIN_TEMPLATE->Input_Error_Font_Color,false);
        }
        else
        {
            render_rectangle(cRender,barBox.x, seekedY1Pos-2,barBox.x+barBox.w,seekedY1Pos+2,GPE_MAIN_TEMPLATE->Input_Outline_Color,false);
        }
    }
}

bool GPE_LogManager::being_resized()
{
    return beingResized;
}

void GPE_LogManager::clear_all_logs()
{
    clear_build_log();
    clear_debug_log();
    clear_general_log();

}

void GPE_LogManager::clear_debug_log()
{
    GPE_Log_Entry * tempLogEntry = NULL;
    for( int i = (int)debugLog.size()-1; i >=0; i--)
    {
        tempLogEntry = debugLog[i];
        if( tempLogEntry!=NULL)
        {
            delete tempLogEntry;
            tempLogEntry = NULL;
        }
    }
    debugLog.clear();
    if( debugTextLog!=NULL)
    {
        debugTextLog->clear_all_lines();
    }
}

void GPE_LogManager::clear_build_log()
{
    GPE_Log_Entry * tempLogEntry = NULL;
    for( int i = (int)buildLog.size()-1; i >=0; i--)
    {
        tempLogEntry = buildLog[i];
        if( tempLogEntry!=NULL)
        {
            delete tempLogEntry;
            tempLogEntry = NULL;
        }
    }
    buildLog.clear();
    if( buildTextLog!=NULL)
    {
        buildTextLog->clear_all_lines();
    }
}

void GPE_LogManager::clear_general_log()
{
    GPE_Log_Entry * tempLogEntry = NULL;
    for( int i = (int)generalLog.size()-1; i >=0; i--)
    {
        tempLogEntry = generalLog[i];
        if( tempLogEntry!=NULL)
        {
            delete tempLogEntry;
            tempLogEntry = NULL;
        }
    }
    generalLog.clear();
    if( generalTextLog!=NULL)
    {
        generalTextLog->clear_all_lines();
    }
}

void GPE_LogManager::log_general_line(std::string newLogLine)
{
    if( generalTextLog!=NULL)
    {
        generalTextLog->add_line(newLogLine, true );
        open_general_log();
    }
}

void GPE_LogManager::log_general_comment(std::string newLogLine)
{
    if( generalTextLog!=NULL)
    {
        generalTextLog->add_line("Comment: "+newLogLine, true );
        open_general_log();
    }
}


void GPE_LogManager::log_general_error(std::string newLogLine)
{
    if( generalTextLog!=NULL)
    {
        generalTextLog->add_line("Error: "+newLogLine, true );
        open_general_log();
    }
}

void GPE_LogManager::log_general_warning(std::string newLogLine)
{
    if( generalTextLog!=NULL)
    {
        generalTextLog->add_line("Warning: "+newLogLine, true );
        open_general_log();
    }
}

void GPE_LogManager::log_debug_line(std::string newLogLine)
{
    if( generalTextLog!=NULL)
    {
        generalTextLog->add_line("Error: "+newLogLine, true );
        open_general_log();
    }
}


void GPE_LogManager::log_build_line(std::string newLogLine)
{
    if( buildTextLog!=NULL)
    {
        buildTextLog->add_line(newLogLine, true );
        open_build_log();
    }
}

void GPE_LogManager::log_build_comment(std::string newLogLine)
{
    if( buildTextLog!=NULL)
    {
        buildTextLog->add_line("Comment: "+newLogLine, true );
        open_build_log();
    }
}

void GPE_LogManager::log_build_error(std::string newLogLine)
{
    if( buildTextLog!=NULL)
    {
        buildTextLog->add_line("Error: "+newLogLine, true );
        open_build_log();
    }
}

void GPE_LogManager::log_build_warning(std::string newLogLine)
{
    if( buildTextLog!=NULL)
    {
        buildTextLog->add_line("Warning: "+newLogLine, true );
        open_build_log();
    }
}


void GPE_LogManager::log_other_line(std::string newLogLine)
{
    record_error(newLogLine);
    if( otherLog!=NULL)
    {
        otherLog->add_line(newLogLine, true );
        open_other_log();
    }
}

void GPE_LogManager::open_general_log()
{
    if( barBox.h < 192 )
    {
        barBox.h = 192;
    }
    if( logTabs!=NULL)
    {
        logTabs->open_tab("Game Pencil Log");
    }
}
void GPE_LogManager::open_build_log()
{
    if( barBox.h < 192 )
    {
        barBox.h = 192;
    }
    if( logTabs!=NULL)
    {
        logTabs->open_tab("Build Log");
    }
}

void GPE_LogManager::open_other_log()
{
    if( barBox.h < 192 )
    {
        barBox.h = 192;
    }
    if( logTabs!=NULL)
    {
        logTabs->open_tab("Other...");
    }
}

void GPE_LogManager::open_replace_mode()
{
    //if( barBox.h < 128 )
    {
        barBox.h = 128;
    }
    bottomInfoList->reset_self();
    if( logTabs!=NULL)
    {
        logTabs->open_tab("Search");
    }
}

void GPE_LogManager::open_search_mode()
{
    //if( barBox.h < 96)
    {
        barBox.h = 96;
    }
    bottomInfoList->reset_self();
    if( logTabs!=NULL)
    {
        logTabs->open_tab("Search");
    }
}

void GPE_LogManager::open_search_results()
{
    if( barBox.h < 128)
    {
        barBox.h = 128;
    }
    if( logTabs!=NULL)
    {
        logTabs->open_tab("Search Results");
    }
    bottomInfoList->reset_self();
    if( GPE_MAIN_GUI!=NULL)
    {
        GPE_MAIN_GUI->close_finder();
    }
}

GPE_PopUpMenu_Option::GPE_PopUpMenu_Option(std::string name, int id, bool selectable, bool seeShortCut, bool makeContext, int kbS1, int kbS2 , int kbS3 )
{
    upDelay = 0;
    downDelay = 0;
    leftDelay = 0;
    rightDelay = 0;
    kbShortCut1 = kbS1;
    kbShortCut2 = kbS2;
    kbShortCut3 = kbS3;
    shortcutString = "";
    if( kbShortCut1 >=0 && kbShortCut1 < userInput->key_count )
    {
        shortcutString = userInput->binding_name[kbShortCut1];
        if( kbShortCut2 >=0 && kbShortCut2 < userInput->key_count )
        {
            shortcutString += "+"+userInput->binding_name[kbShortCut2];
            if( kbShortCut3 >=0 && kbShortCut3 < userInput->key_count )
            {
                shortcutString += "+"+userInput->binding_name[kbShortCut3];
            }
        }
    }
    //barColor = GPE_MAIN_TEMPLATE->PopUp_Box_Color;
    renderWhite = false;
    isResourceOption = false;
    sectionBottom = false;
    opName = name;
    opId = id;
    optionWidth = 0;

    optionWidthSpace = INT_MIN;
    subOptionWidthSpace = INT_MIN;

    int textW = 0;
    int textH = 0;
    if( (int)opName.size()>0)
    {
        textW = 0;
        textH = 0;
        DEFAULT_FONT->get_metrics(opName,&textW, &textH);
        optionWidth = textW;
        optionWidthSpace = textW;
        subOptionWidthSpace = optionWidthSpace;
    }
    if( (int)shortcutString.size()>0 )
    {
        textW = 0;
        textH = 0;
        DEFAULT_FONT->get_metrics(shortcutString,&textW, &textH);
        optionWidth += textW+GENERAL_GPE_PADDING;
        optionWidthSpace += textW+GENERAL_GPE_PADDING;
        subOptionWidthSpace += optionWidthSpace+GENERAL_GPE_PADDING;
    }
    widestOptionSpace = INT_MIN;
    subMenuIsOpen = false;
    isTopOfMenu = true;
    isContext = makeContext;
    hoverOption = -1;
    opSprite = NULL;
    spriteFrameNumber = 0;
    optionBox.x = 0;
    optionBox.y = 0;
    optionBox.w = 0;
    optionBox.h = GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING;
    isSelectable = selectable;
    showShortCuts = seeShortCut;
    subMenuStartPos= 0;
    maxOptionsToView = SCREEN_HEIGHT/optionBox.h;
    selfDistanceToBottom = 0;
    isFolderOption = false;
}

GPE_PopUpMenu_Option::~GPE_PopUpMenu_Option()
{
    GPE_PopUpMenu_Option * tOption = NULL;
    for (int i = 0; i < (int)subOptions.size(); i++)
    {
        tOption = subOptions[i];
        if( tOption!=NULL)
        {
            delete tOption;
            tOption = NULL;
        }
    }
    subOptions.clear();
}

int GPE_PopUpMenu_Option::activate_hovered()
{
    GPE_PopUpMenu_Option * gOption = NULL;
    if( hoverOption >=0 && hoverOption < (int)subOptions.size() )
    {
        gOption = subOptions[hoverOption];
    }
    else if( selectedOption >=0 && selectedOption < (int)subOptions.size() )
    {
        gOption = subOptions[selectedOption];
    }
    //if its possible to open up the suboption do it/return mkay
    if( gOption!=NULL )
    {
        return gOption->activate_hovered();
    }
    else
    {
        if( get_menu_size() == 0 )
        {
            if(isSelectable)
            {
                 //select, execute and exit
                update_popup_info(opName,opId, isContext);
                return opId;
            }
            else
            {
                return -3; //unselectable
            }
        }
    }
    return -1;
}

void GPE_PopUpMenu_Option::clear_menu()
{
    GPE_PopUpMenu_Option * tOption = NULL;
    for (int i = 0; i < (int)subOptions.size(); i++)
    {
        tOption = subOptions[i];
        if( tOption!=NULL)
        {
            delete tOption;
            tOption = NULL;
        }
    }
    subOptions.clear();
    hoverOption = -1;
    selectedOption = -1;
    subMenuIsOpen = false;
    subMenuStartPos = 0;
    maxOptionsToView = 0;
    selfDistanceToBottom = 0;
}

std::string GPE_PopUpMenu_Option::get_name()
{
    return opName;
}

int GPE_PopUpMenu_Option::get_menu_size()
{
    return (int)subOptions.size();
}

GPE_PopUpMenu_Option * GPE_PopUpMenu_Option::get_menu_option(int atNumb)
{
    if( atNumb>=0 && atNumb<(int)subOptions.size())
    {
        return subOptions[atNumb];
    }
    return NULL;
}

int GPE_PopUpMenu_Option::get_width()
{
    return optionWidth;
}

bool GPE_PopUpMenu_Option::is_open()
{
    return subMenuIsOpen;
}

bool GPE_PopUpMenu_Option::push_left()
{
    GPE_PopUpMenu_Option * gOption = NULL;
    if( selectedOption >=0 && selectedOption < (int)subOptions.size() )
    {
        gOption = subOptions[selectedOption];
    }
    else if( hoverOption >=0 && hoverOption < (int)subOptions.size() )
    {
        gOption = subOptions[hoverOption];
    }
    else
    {
        hoverOption = -1;
        selectedOption = -1;
        if( isContext)
        {
            hoverOption = 0;
        }
        else
        {
            subMenuIsOpen = false;
        }
    }
    //if its possible to open up the suboption do it/return mkay
    if( gOption!=NULL )
    {
        if( gOption->is_open()==false || gOption->get_menu_size() == 0 )
        {
            gOption->subMenuIsOpen = false;
            hoverOption = -1;
            selectedOption = -1;
            if( isContext)
            {
                hoverOption = 0;
            }
            else
            {
                subMenuIsOpen = false;
            }
            return true;
        }
        else
        {
            return gOption->push_left();
        }
    }
    return false;
}

bool GPE_PopUpMenu_Option::push_right()
{
    if( subMenuIsOpen==false && (int)subOptions.size() > 0 )
    {
        reset_suboptions();
        subMenuIsOpen = true;
        selectedOption =  hoverOption = 0;
        return true;
    }
    else
    {
        GPE_PopUpMenu_Option * gOption = NULL;
        int tempCursorPos = 0;
        if( selectedOption >=0 && selectedOption < (int)subOptions.size() )
        {
            tempCursorPos = selectedOption;
            gOption = subOptions[selectedOption];
            hoverOption = -1;
        }
        else if( hoverOption >=0 && hoverOption < (int)subOptions.size() )
        {
             tempCursorPos = hoverOption;
            gOption = subOptions[hoverOption];
            selectedOption = -1;
        }
        else if( (int)subOptions.size() > 0)
        {
            selectedOption = hoverOption = 0;
            gOption = subOptions[0];
            selectedOption = -1;
        }
        if( gOption!=NULL )
        {
            //if its possible to open up the suboption do it/return mkay
            if( gOption->push_right() )
            {
                selectedOption = hoverOption =  tempCursorPos;
                return true;
            }
        }
    }
    return false;
}

bool GPE_PopUpMenu_Option::push_up()
{
    if( subMenuIsOpen==false && isContext==false)
    {
        return false;
    }
    if( (int)subOptions.size() > 0 )
    {
        GPE_PopUpMenu_Option * fOption = NULL;
        int currentCursorPos = 0;
        if( selectedOption >=0 && selectedOption < (int)subOptions.size() )
        {
            currentCursorPos = hoverOption = selectedOption;
            fOption = subOptions[currentCursorPos];

        }
        else if( hoverOption >=0 && hoverOption < (int)subOptions.size() )
        {
            currentCursorPos = hoverOption;
            fOption = subOptions[currentCursorPos];
        }
        else if( (int)subOptions.size() > 0 )
        {
            if( subMenuIsOpen == false && isContext==false )
            {
                reset_suboptions();
                subMenuIsOpen = true;
            }
            else if( isContext)
            {
                subMenuIsOpen = true;
            }
            currentCursorPos = hoverOption = selectedOption = 0;
            fOption = subOptions[currentCursorPos];
        }
        /*else
        {
            currentCursorPos = hoverOption = selectedOption = -1;
        }*/

        if( fOption!=NULL)
        {
            bool moveUpward = false;
            if( fOption->get_menu_size() > 0 && fOption->subMenuIsOpen  )
            {
                fOption->push_up();
                /*if( fOption->push_up() == false )
                {
                    moveUpward = true;
                }*/
            }
            else
            {
                moveUpward = true;
            }

            if( moveUpward)
            {
                currentCursorPos--;
                if( currentCursorPos < 0)
                {
                    currentCursorPos = (int)subOptions.size()-1;
                }
                if( currentCursorPos < 0)
                {
                    currentCursorPos = 0;
                }
                //reset_suboptions();
                hoverOption = selectedOption = currentCursorPos;
            }
            return moveUpward;
        }
    }
    return false;
}

bool GPE_PopUpMenu_Option::push_down()
{
    if( subMenuIsOpen==false && isContext==false)
    {
        return false;
    }
    if( (int)subOptions.size() > 0 )
    {
        GPE_PopUpMenu_Option * fOption = NULL;
        int currentCursorPos = 0;
        if( selectedOption>=0 && selectedOption < (int)subOptions.size() )
        {
            currentCursorPos = hoverOption =  selectedOption;
            fOption = subOptions[currentCursorPos];
        }
        else if( hoverOption>=0 && hoverOption < (int)subOptions.size() )
        {
            currentCursorPos = selectedOption =  hoverOption;
            fOption = subOptions[currentCursorPos];
        }
        else if( (int)subOptions.size() > 0 )
        {
            if( subMenuIsOpen == false)
            {
                //reset_suboptions();
                subMenuIsOpen = true;
            }
            currentCursorPos = selectedOption =  hoverOption = 0;
            fOption = subOptions[currentCursorPos];
        }
        /*else
        {
            currentCursorPos = hoverOption = selectedOption = -1;
        }*/

        if( fOption!=NULL)
        {
            bool moveDownward = false;
            if( fOption->get_menu_size() > 0 && fOption->subMenuIsOpen )
            {
                fOption->push_down();
                /*
                if( fOption->push_down() == false )
                {
                    moveDownward = true;
                }
                */
            }
            else
            {
                moveDownward = true;
            }

            if( moveDownward)
            {
                currentCursorPos++;
                if( currentCursorPos >= (int)subOptions.size() )
                {
                    currentCursorPos = 0;
                }
                selectedOption = hoverOption = currentCursorPos;
            }
            return moveDownward;
        }
    }
    return false;
}


void GPE_PopUpMenu_Option::set_id(int newId)
{
    opId = newId;
}

GPE_PopUpMenu_Option * GPE_PopUpMenu_Option::add_menu_option( std::string name, int id, GPE_Texture * gTexture, int spriteImgNumb,GPE_Sprite * gSprite, bool endsSection, bool selectable, bool isResource, int kbS1, int kbS2 , int kbS3 )
{
    maxOptionsToView = SCREEN_HEIGHT/GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING;
    selfDistanceToBottom = (SCREEN_HEIGHT-optionBox.y-optionBox.h)/GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING;

    GPE_PopUpMenu_Option * newOp = new GPE_PopUpMenu_Option(name,id,selectable,showShortCuts,false, kbS1, kbS2, kbS3);
    newOp->optionBox.h = GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING;
    newOp->isTopOfMenu = false;
    newOp->sectionBottom = endsSection;
    newOp->subMenuIsOpen = false;
    newOp->isResourceOption = isResource;

    GPE_PopUpMenu_Option * tempFOption = NULL;
    int i = 0;
    if( id<0)
    {
        //newOp->set_id( (int)subOptions.size() *-1);
        newOp->set_id(  -1 );
    }
    newOp->set_image_data(gSprite, spriteImgNumb);
    newOp->set_texture(gTexture);
    int menuCountSize = (int)subOptions.size();
    if(isContext)
    {
        if( menuCountSize > selfDistanceToBottom)
        {
            newOp->set_position(optionBox.x ,optionBox.y+(menuCountSize-selfDistanceToBottom)*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING);
        }
        else
        {
            newOp->set_position(optionBox.x ,optionBox.y+menuCountSize*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING );
        }
        //newOp->barColor = GPE_MAIN_TEMPLATE->PopUp_Box_Color;
        newOp->set_width(optionWidthSpace);
    }
    else if( isTopOfMenu)
    {
        newOp->set_position(optionBox.x ,optionBox.y+optionBox.h+ menuCountSize*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING );
        //newOp->barColor = GPE_MAIN_TEMPLATE->PopUp_Box_Color;
        newOp->set_width(optionWidthSpace);
    }
    else
    {
        if( menuCountSize > selfDistanceToBottom)
        {
            newOp->set_position(optionBox.x+optionBox.w ,optionBox.y+(menuCountSize-selfDistanceToBottom)*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING );
        }
        else
        {
            newOp->set_position(optionBox.x+optionBox.w ,optionBox.y+menuCountSize*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING );
        }
        //newOp->barColor = barColor;
        newOp->set_width(subOptionWidthSpace);
    }
    subOptions.push_back(newOp);

    //resizes submenu in the event that the new option is wider
    if( newOp->get_width()>=widestOptionSpace)
    {
        widestOptionSpace = newOp->get_width();
        if( showShortCuts)
        {
             subOptionWidthSpace = widestOptionSpace+TOOLKEY_SHORTCUT_WIDTH+GENERAL_ICON_WIDTH_AND_PADDING*2;
        }
        else
        {
            subOptionWidthSpace = widestOptionSpace+GENERAL_ICON_WIDTH_AND_PADDING*2;
        }
        //if( isContext || isTopOfMenu)
        {
            optionWidthSpace = subOptionWidthSpace;
        }
        tempFOption = NULL;
        for( i=0; i<(int)subOptions.size(); i++)
        {
            tempFOption = subOptions[i];
            if( isContext || isTopOfMenu)
            {
                tempFOption->set_width(optionWidthSpace);
            }
            else
            {
                tempFOption->set_width(subOptionWidthSpace);
            }
        }
    }
    return newOp;
}

void GPE_PopUpMenu_Option::prerender_self( GPE_Renderer * cRender)
{
    /*GPE_PopUpMenu_Option * tempOption = NULL;
    for( int i = 0; i < (int)subOptions.size(); i++)
    {
        tempOption = subOptions[i];
        tempOption->prerender_self(cRender);
    }*/
}

int GPE_PopUpMenu_Option::process_menu_option()
{
    int barAction = -1;
    int returnAction = -1;
    if( userInput->check_mouse_released(1) || userInput->check_mouse_released(2) || WINDOW_WAS_JUST_RESIZED || userInput->released[kb_esc])
    {
        returnAction = -2;
    }
    else
    {
        if( subMenuIsOpen )
        {
            if( isContext )
            {
                if( userInput->down[kb_up] && userInput->pressed[kb_up]==false && userInput->released[kb_up]==false )
                {
                    upDelay+=0.5;
                }
                else
                {
                    upDelay = -1;
                }

                if( userInput->down[kb_down] && userInput->pressed[kb_down]==false && userInput->released[kb_down]==false )
                {
                    downDelay+=0.5;
                }
                else
                {
                    downDelay = -1;
                }

                if( userInput->down[kb_left] && userInput->pressed[kb_left]==false && userInput->released[kb_left]==false )
                {
                    leftDelay+=0.5;
                }
                else
                {
                    leftDelay = -1;
                }

                if( userInput->down[kb_right] && userInput->pressed[kb_right]==false && userInput->released[kb_right]==false )
                {
                    rightDelay+=0.5;
                }
                else
                {
                    rightDelay = -1;
                }
            }
            else
            {
                upDelay = -1;
                downDelay = -1;
                leftDelay = -1;
                rightDelay = -1;
            }
            int subPosX = optionBox.x;
            maxOptionsToView = SCREEN_HEIGHT/GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING;
            selfDistanceToBottom = (SCREEN_HEIGHT-optionBox.y-optionBox.h)/GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING;
            GPE_PopUpMenu_Option * fOption = NULL;
            int menuCountSize = (int)subOptions.size() ;
            int extraRenderSpace = 0;
            int subOptionsCurrWidth = optionWidthSpace;
            if( isTopOfMenu==false && isContext==false)
            {
                extraRenderSpace = optionBox.w;
                subOptionsCurrWidth = subOptionWidthSpace;
            }

            if( menuCountSize > maxOptionsToView)
            {
                if( point_between(userInput->mouse_x,userInput->mouse_y,optionBox.x+extraRenderSpace,0,optionBox.x+extraRenderSpace+subOptionsCurrWidth,SCREEN_HEIGHT) )
                {
                    if( userInput->mouseScrollingUp )
                    {
                        subMenuStartPos-=maxOptionsToView/8;
                    }

                    else if( userInput->mouseScrollingDown)
                    {
                        subMenuStartPos+=maxOptionsToView/8;
                    }
                }
                if( subMenuStartPos+maxOptionsToView > (int)subOptions.size() )
                {
                    subMenuStartPos = (int)subOptions.size()-maxOptionsToView;
                }
                if( subMenuStartPos < 0)
                {
                    subMenuStartPos = 0;
                }
            }

            bool keyActivityHappend = false;
            if( isContext)
            {
                int currentCursorPos = 0;
                if( selectedOption>=0 && selectedOption < (int)subOptions.size() )
                {
                    fOption = subOptions[selectedOption];
                    currentCursorPos = selectedOption;
                }
                else if( hoverOption>=0 && hoverOption < (int)subOptions.size() )
                {
                    fOption = subOptions[hoverOption];
                    currentCursorPos = hoverOption;
                }
                /*else if( (int)subOptions.size() > 0 && subOptions[0]!=NULL )
                {
                    currentCursorPos = hoverOption = 0;
                    selectedOption = -1;
                    fOption = subOptions[hoverOption];
                }*/

                if( leftDelay >= (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO  || ( !userInput->pressed[kb_left] && userInput->released[kb_left] ) )
                {
                    leftDelay = -1;
                    push_left();
                    keyActivityHappend = true;
                }
                else if( rightDelay >= (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO  || ( !userInput->pressed[kb_right] && userInput->released[kb_right] ) )
                {
                    push_right();
                    rightDelay = -1;
                    keyActivityHappend = true;

                }
                else if( upDelay >= (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO  || ( !userInput->pressed[kb_up] && userInput->released[kb_up] ) )
                {
                    push_up();
                    upDelay = -1;
                    keyActivityHappend = true;
                }
                else if( downDelay >= (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO  || ( !userInput->pressed[kb_down] && userInput->released[kb_down] ) )
                {
                    push_down();
                    downDelay = -1;
                    keyActivityHappend = true;
                }
                else if( userInput->released[kb_enter] || userInput->released[kb_space] && subMenuIsOpen  )
                {
                    returnAction = activate_hovered();
                    hoverOption = -1;
                    selectedOption = -1;
                    reset_suboptions();
                    subMenuIsOpen = false;
                    keyActivityHappend = true;
                }
                else
                {
                    keyActivityHappend = false;
                }
            }
            else
            {
                keyActivityHappend = false;
            }

            if( keyActivityHappend == false )
            {
                for( int i=subMenuStartPos; i<menuCountSize && i < subMenuStartPos+maxOptionsToView; i++)
                {
                    if( barAction<0)
                    {
                        fOption = subOptions[i];
                        if( isTopOfMenu==false || isContext)
                        {
                            if( isContext)
                            {
                                fOption->set_width(optionBox.w);
                                subPosX = optionBox.x;
                            }
                            else
                            {
                                subPosX = optionBox.x+optionBox.w;
                            }
                            if( menuCountSize > selfDistanceToBottom)
                            {
                                if( menuCountSize > maxOptionsToView)
                                {
                                    //scroller will be required here
                                    fOption->set_position(subPosX,(i-subMenuStartPos)*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING );
                                }
                                else
                                {
                                    //offset box, no scroller needed
                                    fOption->set_position(subPosX ,optionBox.y+(i-(menuCountSize-selfDistanceToBottom) )*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING );
                                }
                            }
                            else
                            {
                                fOption->set_position(subPosX ,optionBox.y+i*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING);
                            }
                        }
                        else if( isTopOfMenu)
                        {
                            fOption->set_position(optionBox.x+extraRenderSpace ,optionBox.y+optionBox.h+i*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING);
                        }

                        barAction = fOption->process_menu_option();
                        if( userInput->mouseMovementInputReceivedInFrame )
                        {
                            if( point_between(userInput->mouse_x, userInput->mouse_y,fOption->optionBox.x,fOption->optionBox.y,fOption->optionBox.x+fOption->optionBox.w,fOption->optionBox.y+fOption->optionBox.h) )
                            {
                                reset_suboptions();
                                hoverOption = i;
                                fOption->subMenuIsOpen = true;
                            }
                        }
                        if(barAction!=-1)
                        {
                            returnAction = barAction;
                        }
                    }
                }

            }
        }
        else
        {
            upDelay = -1;
            downDelay = -1;
            leftDelay = -1;
            rightDelay = -1;
        }

        if(  isTopOfMenu==false && point_between(userInput->mouse_x, userInput->mouse_y,optionBox.x+1,optionBox.y+1,optionBox.x+optionBox.w-1,optionBox.y+optionBox.h-1) )
        {
            if( (int)subOptions.size()>0)
            {
                if( userInput->mouseMovementInputReceivedInFrame )
                {
                    reset_suboptions();
                    subMenuIsOpen = true;
                    GPE_PopUpMenu_Option * fOptionOpened = NULL;
                    for( int iN = 0; iN < (int)subOptions.size(); iN++)
                    {
                        fOptionOpened = subOptions.at(iN);
                        if( fOptionOpened!=NULL)
                        {
                            fOptionOpened->optionBox.x = optionBox.x+optionBox.w;
                        }
                    }
                }
            }
            else if( userInput->check_mouse_released(0) || userInput->released[kb_enter] )
            {
                //actual action happened...
                if(isSelectable)
                {
                    returnAction = opId; //select, execute and exit
                    update_popup_info(opName,opId, isContext);
                }
                else
                {
                    returnAction = -3; //unselectable
                }
            }
        }
        if( returnAction==1)
        {
            hoverOption = -1;
            selectedOption = -1;
            subMenuIsOpen = false;
            reset_suboptions();
        }
    }
    return returnAction;
}

void GPE_PopUpMenu_Option::open_menu()
{
    reset_suboptions();
    subMenuIsOpen = true;
    if( (int)subOptions.size() > 0 )
    {
        hoverOption = selectedOption = 0;
    }
}
void GPE_PopUpMenu_Option::reset_suboptions()
{
    GPE_PopUpMenu_Option * gOption = NULL;
    for(int j=0; j<(int)subOptions.size(); j++)
    {
        gOption = subOptions[j];
        gOption->selectedOption = -1;
        gOption->hoverOption = -1;
        gOption->subMenuIsOpen = false;
        gOption->subMenuStartPos = 0;
        gOption->reset_suboptions();
    }
    /*subMenuIsOpen = false;
    selectedOption = -1;
    hoverOption = -1;*/
}

void GPE_PopUpMenu_Option::set_image_data(GPE_Sprite * newSprite,int newId)
{
    opSprite = newSprite;
    spriteFrameNumber = newId;
}

void GPE_PopUpMenu_Option::set_position(int xPos, int yPos)
{
    if( xPos !=-1)
    {
        optionBox.x = xPos;
    }
    if( yPos !=-1)
    {
        optionBox.y = yPos;
    }
    GPE_PopUpMenu_Option* cOption = NULL;
    int subBoxTotal = (int)subOptions.size();
    for( int i=0; i< subBoxTotal;i++)
    {
        cOption = subOptions[i];
        if(cOption!=NULL)
        {
            cOption->set_position(optionBox.x+optionBox.w,optionBox.y+i*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING);
        }
    }
}

void GPE_PopUpMenu_Option::set_texture(GPE_Texture * newTexture)
{
    opTexture = newTexture;
}

void GPE_PopUpMenu_Option::set_width(int newWidth)
{
    optionBox.w = newWidth;
    if(!isTopOfMenu)
    {
        GPE_PopUpMenu_Option * cOption = NULL;
        int subBoxTotal = (int)subOptions.size();
        for( int i=0; i< subBoxTotal;i++)
        {
            cOption = subOptions[i];
            if(cOption!=NULL)
            {
                cOption->set_position(optionBox.x+optionBox.w,optionBox.y+i*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING);
                if( isContext)
                {
                    cOption->set_position(optionBox.x+subOptionWidthSpace,-1);
                    cOption->set_width(newWidth);
                }
            }
        }
    }
}

void GPE_PopUpMenu_Option::render_self(GPE_Renderer * cRender, SDL_Rect *cam, bool forceRedraw)
{
    if( forceRedraw )
    {
        int i = 0;
        if(sectionBottom )
        {
            render_line(cRender,optionBox.x,optionBox.y+optionBox.h,optionBox.x+optionBox.w,optionBox.y+optionBox.h,c_dkgray);
        }
        if( (int)opName.size()>0 )
        {
            if( (int)subOptions.size()>0)
            {
                if( subMenuIsOpen)
                {
                    GPE_PopUpMenu_Option * fOption = NULL;
                    int menuCountSize = (int)subOptions.size();
                    int subRenderYPos = optionBox.y;
                    int subRenderHeight = (int)subOptions.size()*GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING;
                    if( menuCountSize > selfDistanceToBottom)
                    {
                        if( menuCountSize > maxOptionsToView)
                        {
                            //scroller will be required here
                            subRenderYPos = 0;
                            subRenderHeight = SCREEN_HEIGHT;
                        }
                        else
                        {
                            //offset box, no scroller needed
                            if( isTopOfMenu && isContext==false)
                            {
                                subRenderYPos = optionBox.y+optionBox.h;
                            }
                            else
                            {
                                subRenderYPos = optionBox.y- ( abs(menuCountSize-selfDistanceToBottom) *GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING);
                            }
                        }
                    }
                    else
                    {
                        if( isTopOfMenu && isContext==false )
                        {
                            subRenderYPos = optionBox.y+optionBox.h;
                        }
                        else if( isContext)
                        {
                            subRenderYPos = optionBox.y;
                        }
                    }

                    if( isTopOfMenu || isContext)
                    {
                        if( isContext)
                        {
                            render_rectangle(cRender,optionBox.x,subRenderYPos,optionBox.x+optionBox.w,subRenderYPos+subRenderHeight,GPE_MAIN_TEMPLATE->PopUp_Box_Color, false);
                        }
                        else
                        {
                            render_rectangle(cRender,optionBox.x,subRenderYPos,optionBox.x+optionWidthSpace,subRenderYPos+subRenderHeight,GPE_MAIN_TEMPLATE->Program_Color, false);
                        }
                        for( i=subMenuStartPos; i<(int)subOptions.size() && i < subMenuStartPos+maxOptionsToView; i++)
                        {
                            fOption = subOptions[i];
                            if( fOption!=NULL)
                            {
                                if( hoverOption == i && hoverOption>=0)
                                {
                                    render_rect(cRender,&fOption->optionBox,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color, false);
                                }
                                fOption->render_self(cRender,cam, true);
                            }
                        }
                        if( isContext)
                        {
                            render_rectangle(cRender,optionBox.x,subRenderYPos,optionBox.x+optionBox.w,subRenderYPos+subRenderHeight,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color, true);
                        }
                        else
                        {
                            render_rectangle(cRender,optionBox.x,subRenderYPos,optionBox.x+subOptionWidthSpace,subRenderYPos+subRenderHeight,GPE_MAIN_TEMPLATE->Main_Border_Color, true);
                        }
                    }
                    else
                    {
                        render_rectangle(cRender,optionBox.x+optionBox.w,subRenderYPos,optionBox.x+optionBox.w+subOptionWidthSpace,subRenderYPos+subRenderHeight,GPE_MAIN_TEMPLATE->PopUp_Box_Color, false);
                        for( i=subMenuStartPos; i<(int)subOptions.size() && i < subMenuStartPos+maxOptionsToView; i++)
                        {
                            fOption = subOptions[i];
                            if( hoverOption == i  && hoverOption>=0)
                            {
                                render_rect(cRender,&fOption->optionBox,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color, false);
                            }
                            fOption->render_self(cRender, cam,true);
                        }
                        render_rectangle(cRender,optionBox.x+optionBox.w,subRenderYPos,optionBox.x+optionBox.w+subOptionWidthSpace,subRenderYPos+subRenderHeight,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color, true);
                        render_rectangle(cRender,optionBox.x,optionBox.y,optionBox.x+optionBox.w,optionBox.y+optionBox.h,GPE_MAIN_TEMPLATE->PopUp_Box_Color, false);
                     }
                }
                if( !isTopOfMenu)
                {
                    render_new_text(cRender,optionBox.x+optionBox.w-GENERAL_GPE_PADDING,optionBox.y+16,">",GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TOOLBAR,FA_RIGHT,FA_MIDDLE);
                }
            }

            if( isTopOfMenu )
            {
                render_new_text(cRender,optionBox.x+4,optionBox.y+4,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_TOOLBAR,FA_LEFT,FA_TOP);
            }
            else
            {
                if(subMenuIsOpen  )
                {
                    render_rectangle(cRender,optionBox.x,optionBox.y,optionBox.x+optionBox.w,optionBox.y+optionBox.h,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color, false);
                    render_new_text(cRender,optionBox.x+GENERAL_ICON_WIDTH_AND_PADDING,optionBox.y+GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING/2,opName,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,FONT_TOOLBAR,FA_LEFT,FA_MIDDLE);
                }
                /*else if( )
                {
                    render_new_text(cRender,optionBox.x+GENERAL_ICON_WIDTH_AND_PADDING,optionBox.y+GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING/2,opName,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,FONT_TOOLBAR,FA_LEFT,FA_MIDDLE);

                }*/
                else
                {
                    render_new_text(cRender,optionBox.x+GENERAL_ICON_WIDTH_AND_PADDING,optionBox.y+GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING/2,opName,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TOOLBAR,FA_LEFT,FA_MIDDLE);
                    //opTexture->render_tex(cRender,optionBox.x+GENERAL_ICON_WIDTH_AND_PADDING, optionBox.y+16-(opTexture->get_height()/2),NULL,NULL);
                }
                if ( opSprite!=NULL && opSprite->spriteTexture!=NULL )
                {
                    render_sprite_resized(cRender,opSprite,spriteFrameNumber,optionBox.x+GENERAL_GPE_PADDING,optionBox.y+optionBox.h/4,optionBox.h/2,optionBox.h/2);
                }
                else if( opTexture!=NULL)
                {
                    if( isFolderOption)
                    {
                        render_texture_resized(cRender,opTexture,optionBox.x+GENERAL_GPE_PADDING,optionBox.y+optionBox.h/4,optionBox.h/2,optionBox.h/2,NULL,NULL,FA_LEFT,FA_TOP,GPE_MAIN_TEMPLATE->Main_Folder_Color );
                    }
                    else if( isResourceOption || renderWhite)
                    {
                        render_texture_resized(cRender,opTexture,optionBox.x+GENERAL_GPE_PADDING,optionBox.y+optionBox.h/4,optionBox.h/2,optionBox.h/2,NULL,NULL,FA_LEFT,FA_TOP, c_white );
                    }
                    else
                    {
                        render_texture_resized(cRender,opTexture,optionBox.x+GENERAL_GPE_PADDING,optionBox.y+optionBox.h/4,optionBox.h/2,optionBox.h/2,NULL,NULL,FA_LEFT,FA_TOP, GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color  );
                    }
                }
                if( (int)shortcutString.size()>0 )
                {
                    render_new_text(cRender,optionBox.x+optionBox.w-GENERAL_GPE_PADDING,optionBox.y+16,shortcutString,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TOOLBAR,FA_RIGHT,FA_MIDDLE);
                }
            }
        }
        else
        {
            render_new_text(cRender,optionBox.x+GENERAL_ICON_WIDTH_AND_PADDING,optionBox.y+optionBox.h/2,"null",GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TOOLBAR,FA_LEFT,FA_MIDDLE);
        }
    }
}

void GPE_PopUpMenu_Option::update_selectability( bool selectable )
{
    if( selectable!=isSelectable)
    {
        isSelectable = selectable;
    }
}

GPE_Toolbar::GPE_Toolbar()
{
    guiListTypeName = "toolbar";
    opName = "untitled";
    barBox.x = 0;
    barBox.y = 0;
    barBox.w = SCREEN_WIDTH;
    barBox.h = 24;

    barWidthTotal = 0;
    hoverOption = -1;
    selectedOption = -1;
    toolBarIsOpen = false;
    upDelay = 0;
    downDelay = 0;
    leftDelay = 0;
    rightDelay = 0;
}

GPE_Toolbar::GPE_Toolbar(std::string bName,SDL_Rect bRect)
{
    upDelay = 0;
    downDelay = 0;
    leftDelay = 0;
    rightDelay = 0;
    barBox.x = 0;
    barBox.y = 0;
    barBox.w = SCREEN_WIDTH;
    barBox.h = 24;
    guiListTypeName = "toolbar";
    opName = bName;
    bRect = barBox;
    barWidthTotal = 0;
    hoverOption = -1;
    selectedOption = -1;
    toolBarIsOpen = false;
}

GPE_Toolbar::~GPE_Toolbar()
{

}

void GPE_Toolbar::close_toolbar()
{
    reset_options();
    hoverOption = -1;
    selectedOption = -1;
    toolBarIsOpen = false;
    upDelay = 0;
    downDelay = 0;
    leftDelay = 0;
    rightDelay = 0;
}

bool GPE_Toolbar::is_open()
{
    return toolBarIsOpen;
}

GPE_PopUpMenu_Option * GPE_Toolbar::add_menu_option( std::string name, int id)
{
    GPE_PopUpMenu_Option * newOp = new GPE_PopUpMenu_Option(name,id);
    if( id<0)
    {
        newOp->set_id( (int)barOptions.size() );
    }
    newOp->set_position(barWidthTotal,barBox.y);
    newOp->optionBox.h = barBox.h;
    barOptions.push_back(newOp);
    barWidthTotal+=newOp->get_width()+TOOLKEY_OPTION_PADDING;
    return newOp;
}

void GPE_Toolbar::set_width(int newWid)
{
    barBox.w = newWid;
}

void GPE_Toolbar::reset_options()
{
    GPE_PopUpMenu_Option * gOption = NULL;
    for(int j=0; j<(int)barOptions.size(); j++)
    {
        gOption = barOptions[j];
        gOption->subMenuIsOpen = false;
        gOption->hoverOption = -1;
        gOption->selectedOption = -1;
        gOption->reset_suboptions();
    }
}

void GPE_Toolbar::open_toolbar()
{
    if( toolBarIsOpen==false)
    {
        toolBarIsOpen = true;
        GPE_MAIN_GUI->take_frozen_screenshot();
    }
}

void GPE_Toolbar::prerender_self( GPE_Renderer * cRender)
{
    GPE_PopUpMenu_Option * tempOption = NULL;
    for( int i = 0; i < (int)barOptions.size(); i++)
    {
        tempOption = barOptions[i];
        tempOption->prerender_self(cRender);
    }
}

void GPE_Toolbar::process_toolbar()
{
    int i;
    int drawXPos;
    int actionHappened = false;
    int barAction = -1;

    update_popup_info(); //resets the popup option to process
    if( userInput->windowEventHappendInFrame == true)
    {
        hoverOption = -1;
        selectedOption = -1;
        reset_options();
        toolBarIsOpen = false;
    }

    GPE_PopUpMenu_Option * fOption = NULL;
    if( userInput->released[kb_alt] & userInput->down[kb_ctrl]==false && userInput->down[kb_shift]==false )
    {
        if( toolBarIsOpen)
        {
            hoverOption = -1;
            selectedOption = -1;
            reset_options();
            toolBarIsOpen = false;
        }
        else
        {
            reset_options();
            hoverOption = 0;

            selectedOption = 0;
            //resets the bar options
            if( (int)barOptions.size()>0)
            {
                fOption = barOptions[0];
                fOption->open_menu();
            }
            actionHappened = 2;
            open_toolbar();
            /*
            reset_options();
            hoverOption = 0;
            selectedOption = 0;
            toolBarIsOpen = true;
            if( barOptions.size()>0)
            {
                fOption = barOptions[0];
                fOption->subMenuIsOpen = true;
            }
            if( GPE_MAIN_GUI!=NULL )
            {
                //GPE_MAIN_GUI->take_frozen_screenshot();
            }
            */

        }
    }


    if( barOptions.size()>0)
    {
        /*
        if( point_between_rect(userInput->mouse_x, userInput->mouse_y,&barBox) )
        {
            if( userInput->check_mouse_released(0) )
            {
                close_toolbar();
            }
        }*/

        drawXPos = barBox.x;
        if( toolBarIsOpen )
        {
            if( userInput->down[kb_up] && userInput->pressed[kb_up]==false && userInput->released[kb_up]==false )
            {
                upDelay+=0.5;
            }
            else
            {
                upDelay = -1;
            }

            if( userInput->down[kb_down] && userInput->pressed[kb_down]==false && userInput->released[kb_down]==false )
            {
                downDelay+=0.5;
            }
            else
            {
                downDelay = -1;
            }

            if( userInput->down[kb_left] && userInput->pressed[kb_left]==false && userInput->released[kb_left]==false )
            {
                leftDelay+=0.5;
            }
            else
            {
                leftDelay = -1;
            }

            if( userInput->down[kb_right] && userInput->pressed[kb_right]==false && userInput->released[kb_right]==false )
            {
                rightDelay+=0.5;
            }
            else
            {
                rightDelay = -1;
            }
        }
        else
        {
            upDelay = -1;
            downDelay = -1;
            leftDelay = -1;
            rightDelay = -1;
        }

        int currentCursorPos = 0;
        if( selectedOption>=0 && selectedOption < (int)barOptions.size() )
        {
            fOption = barOptions[selectedOption];
            currentCursorPos = selectedOption;
        }
        else if( hoverOption>=0 && hoverOption < (int)barOptions.size() )
        {
            fOption = barOptions[hoverOption];
            currentCursorPos = hoverOption;
        }

        bool toolBarActionHappened = false;
        if( toolBarIsOpen )
        {
            if( leftDelay >= (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO  || ( !userInput->pressed[kb_left] && userInput->released[kb_left] ) )
            {
                leftDelay = -1;
                toolBarActionHappened = true;
                if( fOption!=NULL)
                {
                    if( fOption->push_left() ==false)
                    {
                        currentCursorPos--;
                        if( currentCursorPos < 0)
                        {
                            currentCursorPos = (int)barOptions.size()-1;
                        }
                        if(currentCursorPos < 0 )
                        {
                            currentCursorPos = 0;
                        }
                        reset_options();
                        hoverOption = selectedOption = currentCursorPos;
                        if( hoverOption>=0 && hoverOption < (int)barOptions.size() )
                        {
                            fOption = barOptions[currentCursorPos];
                            if( fOption!=NULL)
                            {
                                fOption->subMenuIsOpen = true;
                            }
                        }
                    }
                }
            }
            else if( rightDelay >= (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO  || ( !userInput->pressed[kb_right] && userInput->released[kb_right] ) )
            {
                toolBarActionHappened = true;
                rightDelay = -1;
                if( fOption!=NULL)
                {
                    if( fOption->push_right() ==false )
                    {
                        currentCursorPos++;
                        if( currentCursorPos >=(int)barOptions.size() )
                        {
                            currentCursorPos = 0;
                        }
                        reset_options();
                        hoverOption = selectedOption = currentCursorPos;
                        if( hoverOption>=0 && hoverOption < (int)barOptions.size() )
                        {
                            fOption = barOptions[currentCursorPos];
                            if( fOption!=NULL)
                            {
                                fOption->subMenuIsOpen = true;
                            }
                        }
                    }
                }
            }
            else if( upDelay >= (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO  || ( !userInput->pressed[kb_up] && userInput->released[kb_up] ) )
            {
                toolBarActionHappened = true;
                if( fOption!=NULL)
                {
                    if( fOption->push_up() ==false )
                    {
                    }
                }
                upDelay = -1;
            }
            else if( downDelay >= (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO  || ( !userInput->pressed[kb_down] && userInput->released[kb_down] ) )
            {
                toolBarActionHappened = true;
                if( fOption!=NULL)
                {
                    if( fOption->push_down() ==false )
                    {

                    }
                }
                downDelay = -1;
            }
            else if( userInput->released[kb_enter] || userInput->released[kb_space] && toolBarIsOpen  )
            {
                toolBarActionHappened = true;
                if( fOption!=NULL)
                {
                    if( fOption->activate_hovered() )
                    {
                        hoverOption = -1;
                        selectedOption = -1;
                        reset_options();
                        toolBarIsOpen = false;
                        close_toolbar();
                    }
                }
            }
        }

        if( !toolBarActionHappened )
        {
            for(i=0; i<(int)barOptions.size(); i++)
            {
                fOption = barOptions[i];
                if( point_between(userInput->mouse_x, userInput->mouse_y,drawXPos,barBox.y,drawXPos+fOption->get_width()+TOOLKEY_OPTION_PADDING,barBox.y+barBox.h) )
                {
                    if( userInput->mouseMovementInputReceivedInFrame || hoverOption < 0 )
                    {
                        hoverOption = i;
                    }
                    if( selectedOption>=0 && toolBarIsOpen && userInput->mouseMovementInputReceivedInFrame )
                    {
                        reset_options();
                        hoverOption = i;

                        selectedOption = i;
                        //resets the bar options
                        fOption->open_menu();
                        actionHappened = 2;
                        open_toolbar();
                    }
                    else if( userInput->check_mouse_released(0) )
                    {
                        //resets the bar options
                        reset_options();
                        fOption->open_menu();
                        open_toolbar();
                        selectedOption=i;
                        hoverOption = -1;
                        actionHappened = 2;
                    }
                }

                barAction = fOption->process_menu_option();
                if(barAction!=-1)
                {
                    actionHappened = barAction;
                }
                drawXPos+=fOption->get_width()+TOOLKEY_OPTION_PADDING;
            }

            if( userInput->check_mouse_released(0) )
            {
                //resets the toolbar if the user clicks on the far right side of it.
                if(actionHappened==false || actionHappened==1)
                {
                    close_toolbar();
                }
            }
        }
    }

    if( userInput->check_mouse_released(1) || userInput->check_keyboard_released(kb_esc) )
    {
        close_toolbar();
    }

    if((int)GPE_Action_Message.size() > 0 )
    {
        close_toolbar();
        userInput->reset_all_input();
    }
}

void GPE_Toolbar::render_toolbar(GPE_Renderer *rendTarget, SDL_Rect *renderCam, bool forceRedraw)
{
    if( rendTarget==NULL)
    {
        rendTarget = MAIN_RENDERER;
    }

    if( forceRedraw)
    {
        if( toolBarIsOpen)
        {
            GPE_MAIN_GUI->render_frozen_screenshot(rendTarget);
        }
        render_rect(rendTarget,&barBox,GPE_MAIN_TEMPLATE->Program_Header_Color,false);
        if( barOptions.size()==0)
        {
            render_new_text(rendTarget,barBox.x+4,barBox.y+8,"Empty Toolbar();",GPE_MAIN_TEMPLATE->Main_Box_Font_Color,NULL,FA_LEFT,FA_TOP);
        }
        else
        {
            GPE_PopUpMenu_Option * fOption = NULL;
            int drawXPos = 0;
            int y2 = barBox.y+barBox.h;
            for(int i=0; i<(int)barOptions.size(); i++)
            {
                fOption = barOptions[i];
                if(fOption->subMenuIsOpen || hoverOption==i)
                {
                    render_rectangle(rendTarget,drawXPos,barBox.y,drawXPos+fOption->get_width()+TOOLKEY_OPTION_PADDING,y2,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color, false);
                }
                fOption->render_self(rendTarget,NULL,true);
                drawXPos+=fOption->get_width()+TOOLKEY_OPTION_PADDING;
            }
        }
    }
}

GPE_DropDown_Menu::GPE_DropDown_Menu(int xPos, int yPos,std::string name, bool justOptions)
{
    guiListTypeName = "dropdown";
    barBox.x = xPos;
    barBox.y = yPos;
    barBox.w = 228;
    //int nameMinSize = name.size()*
    barBox.h = 32;
    dropdownName = opName = name;
    opId = -1;
    selectedId = -1;
    isSelectable = true;
    showJustOptions = justOptions;
    if( showJustOptions)
    {
        opId = 0;
        selectedId = 0;
    }
    isOpen = false;
    isClicked = false;
    justActivated = false;
}

GPE_DropDown_Menu::~GPE_DropDown_Menu()
{
    GPE_KeyPair * kp = NULL;
    for( int i = subOptions.size()-1; i >=0; i--)
    {
        kp = subOptions[i];
        if( kp!=NULL )
        {
            delete kp;
            kp = NULL;
        }
    }
    subOptions.clear();
}

std::string GPE_DropDown_Menu::get_data()
{
    std::string dataString = guiListTypeName+":"+dropdownName+"==|||==[menu]";
    GPE_KeyPair * tPair = NULL;
    for( int i = 0; i < (int)subOptions.size(); i++ )
    {
        tPair = subOptions[i];
        if( tPair!=NULL)
        {
            dataString+="[option]"+tPair->keyString+":"+tPair->keySubString+":"+int_to_string(tPair->keyValue)+"[/option]";
        }
    }
    dataString+="[/menu]"+int_to_string(selectedId)+","+int_to_string(showJustOptions)+",";
    return dataString;
}

void GPE_DropDown_Menu::load_data(std::string dataString)
{
    if( (int)dataString.size() > 0 )
    {
        std::string optionTag = "[option]";
        int optionTagSize = (int)optionTag.size();

        std::string allOptionsString = "";
        std::string newOptionData = "";
        std::string newOptionString = "";
        std::string newOptionName = "";
        std::string newOptionSubame = "";
        int newOptionId = -1;
        int beginOptionPos=dataString.find_first_of(optionTag);
        if(beginOptionPos!=(int)std::string::npos)
        {
            allOptionsString = split_first_string(dataString,"[/menu]");

            newOptionData = split_first_string(allOptionsString,"[menu]");
            while( (int)allOptionsString.size() > 0)
            {
                newOptionString = split_first_string(allOptionsString,"[/option]");

                beginOptionPos=newOptionString.find_first_of(optionTag);
                if(beginOptionPos!=(int)std::string::npos)
                {
                    //if the beginOptionPos is present, then parse on through and carryon
                    if( (int)newOptionString.size() > beginOptionPos+optionTagSize )
                    {
                        newOptionData = get_substring(newOptionString, beginOptionPos+optionTagSize );

                        newOptionName = split_first_string(newOptionData,":");
                        newOptionSubame = split_first_string(newOptionData,":");
                        newOptionId = string_to_int(newOptionData,-1);
                        if( (int)newOptionName.size() > 0)
                        {
                            add_menu_option(newOptionName,newOptionSubame,newOptionId,false);
                        }
                    }
                    else
                    {
                        return;
                    }
                }
            }
            set_id( split_first_int(dataString,',') );
            showJustOptions = is_bool( split_first_string(dataString,",") );
        }
    }
}

void GPE_DropDown_Menu::remove_data(std::string dataString)
{
    if( (int)dataString.size() > 0)
    {
        std::string optionTag = "[option]";
        int optionTagSize = (int)optionTag.size();

        std::string newOptionData = "";
        std::string newOptionString = "";
        std::string foundOptionName = "";
        int beginOptionPos = -1;
        while( (int)dataString.size() > 0)
        {
            newOptionString = split_first_string(dataString,"[/option]");

            beginOptionPos=newOptionString.find_first_of(optionTag);
            if(beginOptionPos!=(int)std::string::npos)
            {
                //if the beginOptionPos is present, then parse on through and carryon
                foundOptionName = newOptionString.substr(beginOptionPos+optionTagSize,newOptionString.length());
                if( (int)foundOptionName.size() > 0)
                {
                    remove_option(foundOptionName);
                }
            }
        }
    }
}

void GPE_DropDown_Menu::remove_option(std::string optionToRemove)
{
    GPE_KeyPair * tOption = NULL;
    for( int i = (int)subOptions.size()-1; i>=0; i--)
    {
        tOption = subOptions[i];
        if( tOption!=NULL )
        {
            if( tOption->keyString==optionToRemove)
            {
                delete tOption;
                tOption = NULL;
                subOptions.erase( subOptions.begin()+i);

                if( selectedId==i)
                {
                    set_selection(-1);
                }
            }
        }
    }
}

void GPE_DropDown_Menu::add_menu_option(std::string optionName, std::string optionSubStr,double optionValue, bool selectOption)
{
    bool optionExists = false;
    GPE_KeyPair * tOption = NULL;
    for( int i = 0; i < (int)subOptions.size(); i++)
    {
        tOption = subOptions[i];
        if( tOption!=NULL )
        {
            if( tOption->keyString==optionName)
            {
                optionExists = false;
                return;
            }
        }
    }
    if( !optionExists)
    {
        GPE_KeyPair * kp = new GPE_KeyPair(optionValue,optionName,optionSubStr);
        subOptions.push_back(kp);
        if( selectOption )
        {
            set_id( (int)subOptions.size()-1 );
        }
    }
}

std::string GPE_DropDown_Menu::get_menu_option(int atNumb)
{
    GPE_KeyPair * kp = NULL;
    if( atNumb >=0 && atNumb < (int)subOptions.size() )
    {
        kp = subOptions.at(atNumb);
        return kp->keyString;
    }
    return "";
}

std::string GPE_DropDown_Menu::get_plain_string()
{
    GPE_KeyPair * kp = NULL;
    if( selectedId >=0 && selectedId < (int)subOptions.size() )
    {
        kp = subOptions[selectedId];
        return "'"+kp->keyString+"'";
    }
    return "''";
}

int GPE_DropDown_Menu::get_selected_id()
{
    return selectedId;
}

std::string GPE_DropDown_Menu::get_selected_name()
{
    GPE_KeyPair * kp = NULL;
    if( selectedId >=0 && selectedId < (int)subOptions.size() )
    {
        kp = subOptions[selectedId];
        return kp->keyString;
    }
    return opName;
}


std::string GPE_DropDown_Menu::get_selected_tag()
{
    GPE_KeyPair * kp = NULL;
    if( selectedId >=0 && selectedId < (int)subOptions.size() )
    {
        kp = subOptions[selectedId];
        return kp->keySubString;
    }
    return "";
}

double GPE_DropDown_Menu::get_selected_value()
{
    GPE_KeyPair * kp = NULL;
    if( selectedId >=0 && selectedId < (int)subOptions.size() )
    {
        kp = subOptions[selectedId];
        return kp->keyValue;
    }
    return 0;
}

bool GPE_DropDown_Menu::just_activated()
{
    return justActivated;
}

void GPE_DropDown_Menu::process_self(SDL_Rect * viewedSpace, SDL_Rect * cam)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    isHovered = false;
    justActivated = false;
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isHovered || isInUse)
    {
        GPE_MAIN_GUI->update_tooltip(dropdownName);
    }
    if( isInUse)
    {
        hasArrowkeyControl = true;
    }
    else
    {
        hasArrowkeyControl = false;
    }
    if( isInUse &&( userInput->check_keyboard_down( kb_enter ) || userInput->check_keyboard_down( kb_space )  ) )
    {
        isClicked = true;
    }

    if( isClicked && cam!=NULL && viewedSpace!=NULL)
    {
        if( MAIN_CONTEXT_MENU!=NULL)
        {
            if( MAIN_CONTEXT_MENU->subMenuIsOpen == false)
            {
                isOpen = true;
                GPE_open_context_menu(viewedSpace->x+barBox.x-cam->x, viewedSpace->y+barBox.y+barBox.h-cam->y);
                MAIN_CONTEXT_MENU->set_width(barBox.w);
                GPE_KeyPair * kp = NULL;
                if( (int)subOptions.size() > 0)
                {
                    if( showJustOptions ==false)
                    {
                        MAIN_CONTEXT_MENU->add_menu_option(dropdownName,-1);
                    }
                    for( int i = 0; i < (int)subOptions.size(); i++)
                    {
                        kp = subOptions[i];
                        MAIN_CONTEXT_MENU->add_menu_option(kp->keyString,i);
                    }
                    if( showJustOptions ==false)
                    {
                        MAIN_CONTEXT_MENU->add_menu_option(dropdownName,-1);
                    }
                }
                else
                {
                    MAIN_CONTEXT_MENU->add_menu_option(dropdownName,-1);
                }
                isOpen = false;
                isClicked = false;
                justActivated = true;
                int foundResult = get_popupmenu_result();
                if( foundResult>=0)
                {
                    selectedId = foundResult;
                    opName = GPE_Action_Message;
                }
                else if(showJustOptions==false)
                {
                    selectedId=-1;
                    opName=dropdownName;
                }
                GPE_close_context_menu();
            }
        }
    }
    else if( hasArrowkeyControl)
    {
        if( userInput->check_keyboard_down(kb_up) && selectedId > 0)
        {
            selectedId--;
        }
        else if( userInput->check_keyboard_down(kb_down) && selectedId < (int)subOptions.size()-1)
        {
            selectedId++;
        }
    }
}

void GPE_DropDown_Menu::render_self(GPE_Renderer * cRender,SDL_Rect * viewedSpace, SDL_Rect * cam,bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && cam!=NULL && viewedSpace!=NULL)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Color,false);

        if( selectedId >= 0)
        {
            if( selectedId < (int)subOptions.size() )
            {
                GPE_KeyPair * kp = subOptions[selectedId];
                render_new_text_ext(cRender,barBox.x+GENERAL_GPE_PADDING-cam->x,barBox.y+GENERAL_GPE_PADDING-cam->y,kp->keyString,GPE_MAIN_TEMPLATE->Input_Font_Color,FONT_POPUP,FA_LEFT,FA_TOP,barBox.w-barBox.h-12,-1);
            }
            else
            {
                render_new_text_ext(cRender,barBox.x+GENERAL_GPE_PADDING-cam->x,barBox.y+GENERAL_GPE_PADDING-cam->y,opName,GPE_MAIN_TEMPLATE->Input_Font_Color,FONT_POPUP,FA_LEFT,FA_TOP,barBox.w-barBox.h-12,-1);
                selectedId = 0;
            }
        }
        else
        {
            render_new_text_ext(cRender,barBox.x+GENERAL_GPE_PADDING-cam->x,barBox.y+GENERAL_GPE_PADDING-cam->y,opName,GPE_MAIN_TEMPLATE->Input_Font_Color,FONT_POPUP,FA_LEFT,FA_TOP,barBox.w-barBox.h-12,-1);
        }
        if( isInUse)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Highlight_Outline_Color,true);
        }
        else if( isHovered)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Highlight_Alt_Color,true);
        }
        else
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Outline_Color,true);
        }

        render_rectangle(cRender,barBox.x+barBox.w-barBox.h*3/4-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Outline_Color ,false);
        render_sprite_ext(cRender,GPE_TRIANGLE,3,barBox.x+barBox.w-barBox.h/2-cam->x,barBox.y+barBox.h/3 - cam->y,barBox.h/3,barBox.h/3,GPE_MAIN_TEMPLATE->Input_Color );
    }
}

void GPE_DropDown_Menu::set_id(int newId)
{
    set_selection(newId);
}

void GPE_DropDown_Menu::set_selection(int newId, bool autoCorrect)
{
    if( newId>=0)
    {
        if( newId < (int)subOptions.size() )
        {
            GPE_KeyPair * kp = subOptions.at(newId);
            selectedId = newId;
            opName = kp->keyString;
        }
        else if( autoCorrect && (int)subOptions.size() >0 )
        {
            selectedId = (int)subOptions.size()-1;
            GPE_KeyPair * kp = subOptions.at(selectedId);
            opName = kp->keyString;
        }
        else
        {
            selectedId = -1;
            opName = dropdownName;
        }
    }
    else if( autoCorrect && (int)subOptions.size() >0 )
    {
        selectedId = 0;
        GPE_KeyPair * kp = subOptions.at(selectedId);
        opName = kp->keyString;
    }
    else
    {
        selectedId = -1;
        opName = dropdownName;
    }
}

void GPE_DropDown_Menu::set_name(std::string newName)
{
    dropdownName = opName = newName;
}

void GPE_DropDown_Menu::set_value(int valueToFind )
{
    GPE_KeyPair * kp = NULL;
    for( int i =(int)subOptions.size()-1; i>=0; i--)
    {
        kp = subOptions[i];
        if( kp!=NULL)
        {
            if( kp->keyValue==valueToFind )
            {
                selectedId = i;
                opName = kp->keyString;
                break;
            }
        }
    }
}

void GPE_DropDown_Menu::show_just_options(bool justOptions)
{
    showJustOptions = justOptions;
}

GPE_DropDown_Resouce_Menu::GPE_DropDown_Resouce_Menu(int xPos, int yPos, std::string name, GPE_ResourceContainer * cTree,int id,bool selectable )
{
    guiListTypeName = "resourcedropdown";
    barBox.x = xPos;
    barBox.y = yPos;
    barBox.w = 228;
    //int nameMinSize = name.size()*
    barBox.h = 32;
    displayedResult = dropdownName = opName = name;
    containerTree = cTree;
    opId = id;
    isSelectable = selectable;
    selectedId = -1;
    isOpen = false;
    isClicked = false;
    justActivated = false;
    selectedResource= NULL;
}

GPE_DropDown_Resouce_Menu::~GPE_DropDown_Resouce_Menu()
{

}

std::string GPE_DropDown_Resouce_Menu::get_data()
{
    if( containerTree!=NULL)
    {
        std::string dataString = guiListTypeName+":"+dropdownName+"==|||==";
        dataString+= containerTree->get_name()+",,,";
        if( selectedResource!=NULL)
        {
            dataString+=int_to_string(selectedResource->get_global_id() )+",";
        }
        else
        {
            dataString+="-1,";
        }
        return dataString;
    }
    return "";
}

void GPE_DropDown_Resouce_Menu::load_data(std::string dataString)
{
    if( (int)dataString.size() > 0)
    {
        std::string projectResourceFolder = "";
        int projectSelectedContainer = -1;
        GPE_ProjectFolder * foundProjectFolder = GPE_MAIN_GUI->find_project_from_filename(CURRENT_PROJECT_NAME);
        if( foundProjectFolder!=NULL)
        {
            if( foundProjectFolder->RESC_PROJECT_FOLDER!=NULL)
            {
                projectResourceFolder = split_first_string(dataString,",,,");

                GPE_ResourceContainer * foundResContainer  = foundProjectFolder->RESC_PROJECT_FOLDER->find_resource_from_name(projectResourceFolder );
                if( foundResContainer!=NULL)
                {
                    containerTree = foundResContainer;
                    projectSelectedContainer = split_first_int(dataString,',');
                    set_selection( projectSelectedContainer);
                }
                else
                {
                    record_error("Can't find project resource container using...["+CURRENT_PROJECT_NAME+"]");
                }
            }
            else
            {
                record_error("Can't find project GPE resource container using...["+CURRENT_PROJECT_NAME+"]");
            }
        }
        else
        {
            record_error("Can't find project using...["+CURRENT_PROJECT_NAME+"]");
        }
    }
}

void GPE_DropDown_Resouce_Menu::add_folder_contents(GPE_ResourceContainer * fFolder, GPE_PopUpMenu_Option * fOptionFolder)
{
    if( fFolder!=NULL && fOptionFolder!=NULL)
    {
        GPE_ResourceContainer * cContainer = NULL;
        GPE_PopUpMenu_Option * cOption = NULL;
        for( int i = 0; i < fFolder->get_size(); i++)
        {
            cContainer = fFolder->get_resource_at(i);
            if( cContainer!=NULL)
            {
                cOption = fOptionFolder->add_menu_option(cContainer->get_name(),cContainer->get_global_id(),cContainer->get_resource_texture(),0,cContainer->get_resource_sprite(),false,true,true);
                cOption->isResourceOption = true;
                if( cContainer->is_folder() )
                {
                    cOption->isFolderOption = true;
                    add_folder_contents(cContainer,cOption);
                }
            }
        }
    }
}


GPE_ResourceContainer * GPE_DropDown_Resouce_Menu::get_selected_container()
{
    if( containerTree!=NULL)
    {
        return containerTree->find_resource_from_id(selectedId,true,false);
    }
    return NULL;
}

std::string GPE_DropDown_Resouce_Menu::get_selected_name()
{
    if( containerTree!=NULL)
    {
        GPE_ResourceContainer * fRes = containerTree->find_resource_from_id(selectedId,true,false);
        if( fRes!=NULL)
        {
            std::string fStr = fRes->get_name();
            if( is_alnum( fStr, false, true) )
            {
                return fStr;
            }
            else
            {
                //defaults to the object's id instead.
                return int_to_string(fRes->get_global_id() );
            }
        }
    }
    return "";
}

std::string GPE_DropDown_Resouce_Menu::get_plain_string()
{
    if( selectedResource!=NULL)
    {
        if( selectedResource->get_resource_type()==RESOURCE_TYPE_FUNCTION)
        {
            return ""+selectedResource->get_name()+"()";
        }
        else
        {
            return selectedResource->get_name();
        }
    }
    return "''";
}

int GPE_DropDown_Resouce_Menu::get_selected_id()
{
    return selectedId;
}

bool GPE_DropDown_Resouce_Menu::just_activated()
{
    return justActivated;
}

void GPE_DropDown_Resouce_Menu::process_self(SDL_Rect * viewedSpace, SDL_Rect * cam)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    isHovered = false;
    justActivated = false;
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isHovered || isInUse)
    {
        GPE_MAIN_GUI->update_tooltip(dropdownName);
    }
    if( isInUse &&( userInput->check_keyboard_down( kb_enter ) || userInput->check_keyboard_down( kb_space )  ) )
    {
        isClicked = true;
    }

    if( isClicked && cam!=NULL && viewedSpace!=NULL && containerTree!=NULL )
    {
        if( RESOURCE_TO_DRAG!=NULL)
        {
            if( RESOURCE_TO_DRAG->is_folder()==false && RESOURCE_TO_DRAG->projectParentFileName.compare(CURRENT_PROJECT_NAME)==0 )
            {
                set_selection(RESOURCE_TO_DRAG->get_global_id() );
                isOpen = false;
                isClicked = false;
                justActivated = true;
            }
            RESOURCE_TO_DRAG = NULL;
        }
        else if( MAIN_CONTEXT_MENU!=NULL)
        {
            if( MAIN_CONTEXT_MENU->subMenuIsOpen == false)
            {
                isOpen = true;
                GPE_open_context_menu(viewedSpace->x+barBox.x-cam->x, viewedSpace->y+barBox.y+barBox.h-cam->y);
                int estimatedMenuSize = containerTree->get_options_width()+GENERAL_ICON_WIDTH_AND_PADDING ;
                int dropdownNameWidth = 0;
                int dropdownNameHeight = 0;
                if( (int)opName.size()>0 && FONT_TOOLBAR!=NULL)
                {
                    FONT_TOOLBAR->get_metrics(dropdownName,&dropdownNameWidth, &dropdownNameHeight);
                }
                dropdownNameWidth+=GENERAL_ICON_WIDTH_AND_PADDING+GENERAL_GPE_PADDING;
                estimatedMenuSize = std::max( estimatedMenuSize, dropdownNameWidth );
                MAIN_CONTEXT_MENU->set_width( estimatedMenuSize );
                MAIN_CONTEXT_MENU->add_menu_option(dropdownName,-1,NULL,-1,NULL,false,true);
                GPE_ResourceContainer * cContainer = NULL;
                GPE_PopUpMenu_Option * cOption = NULL;
                if(containerTree!=NULL)
                {
                    for( int i = 0; i < containerTree->get_size(); i++)
                    {
                        cContainer = containerTree->get_resource_at(i);
                        if( cContainer!=NULL)
                        {
                            cOption = MAIN_CONTEXT_MENU->add_menu_option(cContainer->get_name(),cContainer->get_global_id(),cContainer->get_resource_texture(),cContainer->get_resource_image_frame(),cContainer->get_resource_sprite(),false,true);
                            cOption->isResourceOption = true;
                            if( cContainer->is_folder() )
                            {
                                add_folder_contents(cContainer,cOption);
                                cOption->isFolderOption = true;
                            }
                        }
                    }
                }
                isOpen = false;
                isClicked = false;
                justActivated = true;
                int foundResult = get_popupmenu_result();
                if( foundResult>=0)
                {
                    selectedId = foundResult;
                    selectedResource = containerTree->find_resource_from_id(selectedId);
                    displayedResult = GPE_Action_Message;
                }
                else
                {
                    selectedId=-1;
                    displayedResult=dropdownName;
                }
                GPE_close_context_menu();
            }
        }
    }
}

void GPE_DropDown_Resouce_Menu::render_self(GPE_Renderer * cRender,SDL_Rect * viewedSpace, SDL_Rect * cam,bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && cam!=NULL && viewedSpace!=NULL)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Color,false);
        if( selectedId >= 0)
        {
            selectedResource = containerTree->find_resource_from_id(selectedId);
            if( selectedResource!=NULL)
            {
                render_new_text_ext(cRender,barBox.x+32+GENERAL_GPE_PADDING-cam->x,barBox.y+barBox.h/2-cam->y,selectedResource->get_name(),GPE_MAIN_TEMPLATE->Input_Font_Color,FONT_POPUP,FA_LEFT,FA_MIDDLE,barBox.w-barBox.h-12,-1);
                selectedResource->render_image(cRender,barBox.x,barBox.y,barBox.h-2,barBox.h-2,viewedSpace,cam);
            }
            else
            {
                render_new_text_ext(cRender,barBox.x-cam->x,barBox.y+barBox.h/2-cam->y,opName,GPE_MAIN_TEMPLATE->Input_Font_Color,FONT_POPUP,FA_LEFT,FA_MIDDLE,barBox.w-barBox.h-12,-1);
            }
        }
        else
        {
            render_new_text_ext(cRender,barBox.x+GENERAL_GPE_PADDING-cam->x,barBox.y+barBox.h/2-cam->y,opName,GPE_MAIN_TEMPLATE->Input_Font_Color,FONT_POPUP,FA_LEFT,FA_MIDDLE,barBox.w-barBox.h-12,-1);
        }
        render_rectangle(cRender,barBox.x+barBox.w-barBox.h*3/4-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Outline_Color ,false);
        render_sprite_ext(cRender,GPE_TRIANGLE,3,barBox.x+barBox.w-barBox.h/2-cam->x,barBox.y+barBox.h/3 - cam->y,barBox.h/3,barBox.h/3,GPE_MAIN_TEMPLATE->Input_Color );
        if( isInUse)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Highlight_Outline_Color,true);
        }
        else if( isHovered)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Highlight_Alt_Color,true);
        }
        else
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Outline_Color,true);
        }
    }
}

void GPE_DropDown_Resouce_Menu::set_name(std::string newName)
{
    opName = newName;
}

void GPE_DropDown_Resouce_Menu::set_selection(int newId)
{
    if( newId>0 && containerTree!=NULL)
    {
        GPE_ResourceContainer * tRes = containerTree->find_resource_from_id(newId,true);
        if( tRes!=NULL)
        {
            selectedId = newId;
            displayedResult = tRes->get_name();
            selectedResource = tRes;
        }
    }
    else
    {
        selectedId = -1;
        displayedResult = opName = dropdownName;
        selectedResource = NULL;
    }
}

void GPE_DropDown_Resouce_Menu::set_selected_target(std::string newName)
{
    int newId = string_to_int(newName, -1);
    if( newId > 0 && containerTree!=NULL)
    {
        GPE_ResourceContainer * tRes = containerTree->find_resource_from_id(newId,true);
        if( tRes!=NULL)
        {
            selectedId = newId;
            displayedResult = tRes->get_name();
            selectedResource = tRes;
        }
    }
    else
    {
        GPE_ResourceContainer * tRes = containerTree->find_resource_from_name(newName,true);
        if( tRes!=NULL)
        {
            selectedId = tRes->get_global_id();
            displayedResult = tRes->get_name();
            selectedResource = tRes;
        }
        else
        {
            selectedId = -1;
            displayedResult = opName = dropdownName;
            selectedResource = NULL;
        }
    }
}

GPE_ToolIconButton::GPE_ToolIconButton(int buttonX, int buttonY,std::string buttonImgFile,std::string name, int id, int buttonSize, bool lastInCol)
{
    guiListTypeName = "iconbutton";
    endsSection = lastInCol;
    opName = name;
    descriptionText = name;
    opId = id;
    buttonTexture = rsm->texture_add(buttonImgFile);
    barBox.x = buttonX;
    barBox.y = buttonY;
    barBox.w = buttonSize;
    barBox.h = buttonSize;
    isTabbed = false;
    usesTabs = false;
}

GPE_ToolIconButton::~GPE_ToolIconButton()
{

}

std::string GPE_ToolIconButton::get_data()
{
    if( buttonTexture!=NULL)
    {
        return guiListTypeName+":"+opName+"==|||=="+int_to_string(barBox.w)+","+buttonTexture->get_filename()+",,,"+int_to_string(barBox.w)+","+int_to_string(barBox.h)+","+int_to_string(opId);
    }
    else
    {
        return guiListTypeName+":"+opName+"==|||=="+int_to_string(barBox.w)+",0,,,0,0,"+int_to_string(opId);
    }
}

void GPE_ToolIconButton::load_data(std::string dataString)
{
    int buttonSize = split_first_int(dataString,',');
    if( buttonSize <=0)
    {
        barBox.w = buttonSize;
        barBox.h = buttonSize;
    }
    std::string textureFileName = split_first_string(dataString,",,,");
    int spriteWidth = split_first_int(dataString,',');
    int spriteHeight = split_first_int(dataString,',');
    barBox.w = spriteWidth;
    barBox.h = spriteHeight;
    opId = split_first_int(dataString,',');
    buttonTexture = rsm->texture_add(textureFileName);
}

bool GPE_ToolIconButton::ends_section()
{
    return endsSection;
}

int GPE_ToolIconButton::get_id()
{
    return opId;
}

void GPE_ToolIconButton::process_self(SDL_Rect * viewedSpace, SDL_Rect * cam)
{
    isClicked = false;
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isInUse &&( userInput->check_keyboard_down( kb_enter ) || userInput->check_keyboard_down( kb_space )  ) )
    {
        isClicked = true;
    }
    else if( clickedOutside)
    {
        isClicked = false;
    }
    if( isClicked && usesTabs )
    {
        isTabbed = true;
    }
}

void GPE_ToolIconButton::set_id(int newId)
{
    opId = newId;
}

void GPE_ToolIconButton::set_image( std::string buttonImgFile)
{
    if( buttonTexture!=NULL)
    {
        buttonTexture->load_new_texture(MAIN_RENDERER,buttonImgFile,-1,true);
    }
    else
    {
        buttonTexture = rsm->texture_add(buttonImgFile);
    }
}

void GPE_ToolIconButton::render_self(GPE_Renderer * cRender,SDL_Rect * viewedSpace, SDL_Rect * cam,bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( cRender==NULL)
    {
        cRender = MAIN_RENDERER;
    }
    cam = GPE_find_camera(cam);
    viewedSpace = GPE_find_camera(viewedSpace);
    if( forceRedraw && cam!=NULL && viewedSpace!=NULL)
    {
        if( buttonTexture!=NULL)
        {
            GPE_Color * renderColor = GPE_MAIN_TEMPLATE->Icon_Font_Color;
            if( isInUse)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Icon_Box_Highlighted_Color,false);
                renderColor = GPE_MAIN_TEMPLATE->Icon_Font_Highlighted_Color;
            }
            else if(isHovered)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Icon_Box_Highlighted_Color,false);
                renderColor = GPE_MAIN_TEMPLATE->Icon_Font_Highlighted_Color;
            }
            else if(isTabbed)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Icon_Box_Selected_Color,false);
                renderColor = GPE_MAIN_TEMPLATE->Icon_Font_Selected_Color;
            }
            render_texture_resized(cRender,buttonTexture,barBox.x-cam->x,barBox.y-cam->y,barBox.w,barBox.h,NULL,NULL,FA_LEFT,FA_TOP,renderColor);
        }
        if( endsSection)
        {
            render_rectangle(cRender,barBox.x+barBox.w-cam->x,barBox.y-cam->y,barBox.x+barBox.w+4-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Icon_Font_Color);
        }
    }
}

GPE_ToolIconButtonBar::GPE_ToolIconButtonBar(int xPos, int yPos,int buttonSize,bool useTabs)
{
    guiListTypeName = "iconbuttonbar";
    if( buttonSize<=0)
    {
        buttonSize = 24;
    }

    hoverOption = 0;
    barBox.x = xPos;
    barBox.y = yPos;
    barBox.w = 32;
    barBox.h = buttonSize;
    barPadding = 8;
    xPadding = 4;
    newButtonXPos = barPadding;
    isTabBar = useTabs;
    tabPosition = 0;
    widthAutoResizes = false;
}

GPE_ToolIconButtonBar::~GPE_ToolIconButtonBar()
{
    for( int i = barOptions.size()-1; i >=0; i--)
    {
        if( barOptions[i]!=NULL)
        {
            delete barOptions[i];
            barOptions[i] = NULL;
            barOptions.erase(barOptions.begin()+i);
        }
    }
    barOptions.clear();
}

std::string GPE_ToolIconButtonBar::get_data()
{
    return "";
}

void GPE_ToolIconButtonBar::load_data(std::string dataString)
{

}

void GPE_ToolIconButtonBar::limit_width( bool isLimited)
{
    widthIsLimited = isLimited;
    if( widthIsLimited)
    {
        barBox.w = xPadding*3+( (int)barOptions.size() )*(xPadding+barBox.h);
    }
}

void GPE_ToolIconButtonBar::set_width(int newWid)
{
    barBox.w = newWid;
}

GPE_ToolIconButton * GPE_ToolIconButtonBar::adkb_dton( std::string buttonImgFile,std::string name, int id, bool endsSection)
{
    int barSize = (int)barOptions.size();
    GPE_ToolIconButton * newOp = new GPE_ToolIconButton( barBox.x+newButtonXPos, barBox.y,buttonImgFile,name,id,barBox.h, endsSection);
    newOp->descriptionText =  name;
    newOp->usesTabs = isTabBar;
    if( isTabBar && barSize==0)
    {
        newOp->isTabbed = true;
        tabPosition = 0;
    }
    if( id<0 )
    {
        newOp->set_id( barSize );
    }
    barOptions.push_back(newOp);
    newButtonXPos+= xPadding+barBox.h;
    if( endsSection)
    {
        newButtonXPos+=xPadding;
    }
    if( widthAutoResizes)
    {
        barBox.w = barPadding*2+(xPadding+barBox.h)*( (int)barOptions.size() );
    }
    return newOp;
}


int GPE_ToolIconButtonBar::get_tab_pos()
{
    return tabPosition;
}

int GPE_ToolIconButtonBar::get_tab_id()
{
    if( tabPosition >=0 && tabPosition < (int)barOptions.size() )
    {
        if( barOptions[tabPosition]!=NULL)
        {
            return barOptions[tabPosition]->get_id();
        }
    }
    return 0;
}

void GPE_ToolIconButtonBar::process_self(SDL_Rect *viewedSpace , SDL_Rect *cam)
{
    cam = GPE_find_camera(cam);
    viewedSpace = GPE_find_camera(viewedSpace);
    GPE_ToolIconButton * cButton = NULL;
    GPE_ToolIconButton * dButton = NULL;
    int i=0;
    int j=0;

    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isTabBar)
    {
        if( isClicked)
        {
            hasArrowkeyControl = true;
        }
        else if( clickedOutside)
        {
            hasArrowkeyControl = false;
        }
        else if( isInUse)
        {
            hasArrowkeyControl = true;
        }
        else
        {
            hasArrowkeyControl = false;
        }
    }
    else
    {
        selectedOption = -1;
        hasArrowkeyControl = false;
    }
    for(i=0; i<(int)barOptions.size(); i++)
    {
        cButton = barOptions[i];
        if(cButton!=NULL)
        {
            if( !isTabBar)
            {
                cButton->set_clicked(false);
                cButton->switch_inuse(false);
            }
            cButton->process_self(viewedSpace, cam);
            if( cButton->is_clicked()  )
            {
                selectedOption = cButton->get_id();
                if( isTabBar)
                {
                    tabPosition = i;
                    for( j=0; j<(int)barOptions.size(); j++)
                    {
                        dButton = barOptions[j];
                        if(dButton!=NULL)
                        {
                            dButton->isTabbed = false;
                        }
                    }
                    cButton->isTabbed = true;
                }
            }
            else if( cButton->is_hovered() )
            {
                GPE_MAIN_GUI->update_tooltip( cButton->get_name() );
            }
        }
    }
    if( isTabBar && hasArrowkeyControl)
    {
        bool tabMoved = false;
        if( tabPosition > 0 && (userInput->check_keyboard_pressed(kb_left) || userInput->check_keyboard_pressed(kb_up) ) )
        {
            tabPosition--;
            tabMoved = true;
        }
        else if(userInput->check_keyboard_pressed(kb_right) || userInput->check_keyboard_pressed(kb_down) )
        {
            if( tabPosition < (int)barOptions.size()-1 )
            {
                tabPosition++;
                tabMoved = true;
            }
        }
        if( tabMoved )
        {
            for( i=0; i<(int)barOptions.size(); i++)
            {
                cButton = barOptions[i];
                if(cButton!=NULL)
                {
                    if(i==tabPosition)
                    {
                        cButton->isTabbed =  true;
                        selectedOption = cButton->get_id();
                    }
                    else
                    {
                        cButton->isTabbed =  false;
                        cButton->set_clicked( false );
                        cButton->switch_inuse( false );
                    }
                }
            }
        }
    }
}

void GPE_ToolIconButtonBar::render_self(GPE_Renderer *cRender,SDL_Rect * viewedSpace, SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( cRender==NULL)
    {
        cRender = MAIN_RENDERER;
    }
    if( forceRedraw && barBox.h > 0)
    {
        //render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);
        GPE_ToolIconButton * cButton = NULL;
        for(int i=0; i<(int)barOptions.size(); i++)
        {
            cButton = barOptions[i];
            if(cButton!=NULL)
            {
                cButton->render_self(cRender,viewedSpace, cam,forceRedraw);
            }
        }
        if( isInUse)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,true);
        }
        //render_rectangle(rendTarget,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
    }
}

void GPE_ToolIconButtonBar::set_coords(int newX, int newY)
{
    int pastX = barBox.x;
    int pastY = barBox.y;
    GPE_GeneralGuiElement::set_coords(newX,newY);
    if( barBox.x!=pastX || barBox.y!=pastY)
    {
        GPE_ToolIconButton * cButton = NULL;
        int xNewPos = barBox.x+barPadding;
        for( int i = 0; i < (int)barOptions.size(); i++)
        {
            cButton = barOptions[i];
            if( cButton!=NULL)
            {
                cButton->set_coords(xNewPos, barBox.y);
                cButton->set_height( barBox.h);
                xNewPos+=xPadding+barBox.h;
                if( cButton->ends_section() )
                {
                    xNewPos+=xPadding;
                }
            }
        }
    }
    if( widthAutoResizes)
    {
        barBox.w = barPadding*2+(xPadding+barBox.h)*( (int)barOptions.size() );
    }
}


void GPE_ToolIconButtonBar::set_height(int newHeight)
{
    int pastH = barBox.h;
    if( barBox.h!=newHeight)
    {
        barBox.h = newHeight;
        newButtonXPos = xPadding;
        GPE_ToolIconButton * cButton = NULL;
        for( int i = 0; i < (int)barOptions.size(); i++)
        {
            cButton = barOptions[i];
            if( cButton!=NULL)
            {
                cButton->set_coords(barBox.x+newButtonXPos,barBox.y);
                cButton->set_width(newHeight);
                cButton->set_height(newHeight);
                newButtonXPos+=barBox.h;
                if( cButton->ends_section() )
                {
                    newButtonXPos+=xPadding;
                }
            }
        }
        if( widthAutoResizes)
        {
            barBox.w = newButtonXPos;
        }
    }
}

void GPE_ToolIconButtonBar::set_selection(int newSelection)
{
    GPE_ToolIconButton * cButton= NULL;
    for(int i=0; i<(int)barOptions.size(); i++)
    {
        cButton = barOptions[i];
        if(cButton!=NULL)
        {
            if( cButton->get_id()==newSelection)
            {
                tabPosition = i;
                cButton->switch_inuse( true );
            }
            else
            {
                cButton->switch_inuse( false );
            }
        }
    }
}

GPE_ToolLabelButton::GPE_ToolLabelButton(int buttonX, int buttonY,std::string name, std::string description,int id, int buttonSize)
{
    guiListTypeName = "labelbutton";
    opName = name;
    descriptionText = description;
    opId = -1;

    barBox.x = buttonX;
    barBox.y = buttonY;
    barBox.w = 228;
    barBox.h = buttonSize;
    if( DEFAULT_FONT!=NULL)
    {
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(name,&textW, &textH);
        //opStringTexture->loadFromRenderedText(MAIN_RENDERER,newName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_POPUP);
        if( textH > barBox.h)
        {
            barBox.h=textH+GENERAL_GPE_PADDING*2;
        }
    }
    isEnabled = true;
}

GPE_ToolLabelButton::~GPE_ToolLabelButton()
{

}



void GPE_ToolLabelButton::prerender_self(GPE_Renderer * cRender)
{

    if( DEFAULT_FONT!=NULL)
    {
        /*
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(opName,&textW, &textH);
        //barBox.w=textW+GENERAL_GPE_PADDING*2;
        //opStringTexture->loadFromRenderedText(MAIN_RENDERER,newName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_POPUP);
        */
    }
}

void GPE_ToolLabelButton::process_self(SDL_Rect * viewedSpace, SDL_Rect  * cam )
{
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isHovered)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
    }
    if( isInUse &&( userInput->check_keyboard_down( kb_enter ) || userInput->check_keyboard_down( kb_space )  ) )
    {
        isClicked = true;
    }
}

void GPE_ToolLabelButton::render_self(GPE_Renderer * cRender, SDL_Rect * viewedSpace, SDL_Rect  * cam,bool forceRedraw )
{
    if( forceRedraw && isEnabled)
    {
        cam = GPE_find_camera(cam);
        viewedSpace = GPE_find_camera(viewedSpace);
        if(cam!=NULL && viewedSpace!=NULL )
        {
            if( isClicked)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,false);
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Border_Selected_Color,true);
            }
            else if( isHovered)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,false);
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Border_Highlighted_Color,true);
            }
            else
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Box_Color,false);
            }
            if(DEFAULT_FONT!=NULL)
            {
                if( isHovered)
                {
                    render_new_text(cRender,barBox.x-cam->x+barBox.w/2, barBox.y-cam->y+barBox.h/2,opName,GPE_MAIN_TEMPLATE->Button_Font_Highlighted_Color,DEFAULT_FONT,FA_CENTER,FA_MIDDLE);
                }
                else
                {
                    render_new_text(cRender,barBox.x-cam->x+barBox.w/2, barBox.y-cam->y+barBox.h/2,opName,GPE_MAIN_TEMPLATE->Button_Font_Color,DEFAULT_FONT,FA_CENTER,FA_MIDDLE);
                }
                /*if( barBox.w > opStringTexture->get_width()+GENERAL_GPE_PADDING*2 )
                {
                    opStringTexture->render_tex(cRender,barBox.x-cam->x+(barBox.w-opStringTexture->get_width() )/2,barBox.y-cam->y+GENERAL_GPE_PADDING,NULL,NULL);
                }
                else
                {
                    opStringTexture->render_tex(cRender,barBox.x-cam->x+GENERAL_GPE_PADDING,barBox.y-cam->y+GENERAL_GPE_PADDING,NULL,NULL);
                }*/
            }
            /*
            if( isInUse)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Border_Highlighted_Color,true);
            }
            else if( isHovered)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Border_Highlighted_Color,true);
            }
            else
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
            }
            */

            if( isInUse )
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Main_Border_Highlighted_Color,true);
            }
        }
    }
}


void GPE_ToolLabelButton::set_name(std::string newName)
{
    if( DEFAULT_FONT!=NULL)
    {
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(newName,&textW, &textH);
        //opStringTexture->loadFromRenderedText(MAIN_RENDERER,newName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT);
        barBox.w=textW+GENERAL_GPE_PADDING*2;
        barBox.h=textH+GENERAL_GPE_PADDING*2;
    }
    opName = newName;
}

///
GPE_ToolPushButton::GPE_ToolPushButton(int buttonX, int buttonY,std::string imgLocation,std::string name, std::string description,int id, int buttonSize)
{
    guiListTypeName = "pushbutton";
    if( buttonSize <=0)
    {
        buttonSize = 16;
    }
    opName = name;
    descriptionText = description;
    opId = -1;
    opTexture = rsm->texture_add(imgLocation);
    iconPadding = 8;
    barBox.x = buttonX;
    barBox.y = buttonY;
    barBox.w = 228;
    if(buttonSize <=0)
    {
        barBox.h = 32;
    }
    else
    {
        barBox.h = buttonSize;
    }
    if( DEFAULT_FONT!=NULL)
    {
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(name,&textW, &textH);
        if( textW + iconPadding*2 +barBox.h > barBox.w)
        {
            barBox.w = textW+iconPadding*2 + barBox.h;
        }
        //opStringTexture->loadFromRenderedText(MAIN_RENDERER,newName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT);
    }
    isEnabled = true;
    wasClicked = false;
    webUrl = "";
    showBackground = true;
    showBorder = true;
    prerender_self(MAIN_RENDERER);
}

GPE_ToolPushButton::~GPE_ToolPushButton()
{

}

void GPE_ToolPushButton::change_texture( GPE_Texture * newTexture)
{
    opTexture = newTexture;
}

void GPE_ToolPushButton::enable_background( bool enableValue)
{
    if( showBackground!=enableValue)
    {
        showBackground = enableValue;
        prerender_self(MAIN_RENDERER);
    }
}

void GPE_ToolPushButton::enable_border( bool enableValue)
{
    if( showBorder!=enableValue)
    {
        showBorder=enableValue;
        prerender_self(MAIN_RENDERER);
    }
}

void GPE_ToolPushButton::prerender_self(GPE_Renderer * cRender)
{
    /*
    int prevWidth = 0;

    if( DEFAULT_FONT!=NULL)
    {
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(opName,&textW, &textH);
        barBox.w = iconPadding*3+barBox.h+textW;
    }
    */
}

void GPE_ToolPushButton::process_self(SDL_Rect * viewedSpace, SDL_Rect  * cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if(viewedSpace!=NULL && cam!=NULL)
    {
        GPE_GeneralGuiElement::process_self(viewedSpace,cam);
        if( isHovered)
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
        }
        if( isInUse &&( userInput->check_keyboard_down( kb_enter ) || userInput->check_keyboard_down( kb_space )  ) )
        {
            isClicked = true;
        }
        if( isClicked && (int)webUrl.size() > 3)
        {
            GPE_OpenURL(webUrl);
        }
    }
}

void GPE_ToolPushButton::render_self(GPE_Renderer * cRender, SDL_Rect * viewedSpace, SDL_Rect  * cam,bool forceRedraw )
{
    if( forceRedraw && isEnabled)
    {
        viewedSpace = GPE_find_camera(viewedSpace);
        cam = GPE_find_camera(cam);
        if(viewedSpace!=NULL && cam!=NULL)
        {
            if( isClicked )
            {
                if( showBackground)
                {
                    render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,false);
                }
                //if( showBorder)
                {
                    render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,true);
                }
            }
            else
            {
                if( showBackground)
                {
                    if( isHovered)
                    {
                        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,false);
                        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Button_Border_Highlighted_Color,true);
                    }
                    else
                    {
                        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Color,false);
                    }
                }
                else if( isHovered)
                {
                    render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
                }
            }
            int iconSize = 0;
            if( showBackground)
            {
                iconSize = std::min(barBox.w,barBox.h);
                iconPadding = 0;
            }
            else
            {
                iconSize = std::min(barBox.w,barBox.h);
                iconPadding = 0;
            }
            GPE_Color * renderColor = GPE_MAIN_TEMPLATE->Button_Font_Color;
            if( isHovered)
            {
                renderColor = GPE_MAIN_TEMPLATE->Button_Font_Highlighted_Color;
            }
            if( showBackground==false)
            {
                if( wasClicked)
                {
                    renderColor = GPE_MAIN_TEMPLATE->Main_Box_Faded_Font_Color;
                }
                else
                {
                    renderColor = GPE_MAIN_TEMPLATE->Main_Box_Faded_Font_Color;
                }
            }
            if( opTexture!=NULL)
            {
                render_texture_resized(cRender,opTexture,barBox.x-cam->x+iconPadding*2, barBox.y-cam->y,iconSize,iconSize,NULL,NULL,FA_LEFT,FA_TOP,renderColor);
                if( DEFAULT_FONT!=NULL)
                {
                    render_new_text(cRender,barBox.x-cam->x+iconSize+iconPadding*2, barBox.y-cam->y+barBox.h/2,opName,renderColor,DEFAULT_FONT,FA_LEFT,FA_MIDDLE);
                }
            }
            else if(DEFAULT_FONT!=NULL)
            {
                render_new_text(cRender,barBox.x-cam->x+iconSize+iconPadding*2, barBox.y-cam->y+barBox.h/2,opName,renderColor,DEFAULT_FONT,FA_LEFT,FA_MIDDLE);
            }

            if( isInUse )
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Main_Border_Highlighted_Color,true);
            }
        }
    }
}

void GPE_ToolPushButton::set_name(std::string newName)
{
    opName = newName;
    prerender_self(MAIN_RENDERER);
}

void GPE_ToolPushButton::set_website(std::string urlIn)
{
    webUrl = urlIn;
    wasClicked = false;
    prerender_self(MAIN_RENDERER);
}

///
GPE_ToolPushButtonMultiLine::GPE_ToolPushButtonMultiLine(int buttonX, int buttonY, std::string imgLocation, std::string parsedLines, std::string strValue, int id, int buttonSize)
{
    int ww = 0;
    lineHeight = 0;
    if(DEFAULT_FONT !=NULL)
    {
        DEFAULT_FONT->get_numbered_metrics("A",&ww,&lineHeight);
    }
    guiListTypeName = "multilinepushbutton";
    if( buttonSize <=0)
    {
        buttonSize = 16;
    }
    opName = parsedLines;

    if( (int)parsedLines.size() > 0 )
    {
        int newLinePos=parsedLines.find_first_of("\n");
        if(newLinePos!=(int)std::string::npos)
        {
            std::string cbNLString = split_first_string(parsedLines,'\n');
            buttonLines.push_back(cbNLString);
            newLinePos=parsedLines.find_first_of('\n');
            while (newLinePos!=(int)std::string::npos)
            {
                cbNLString = split_first_string(parsedLines,'\n');
                newLinePos=parsedLines.find_first_of('\n');
                buttonLines.push_back(cbNLString);
            }
            if( (int)parsedLines.size() > 0 )
            {
                buttonLines.push_back(parsedLines);
            }
        }
        else
        {
            buttonLines.push_back(parsedLines);
        }
    }

    descriptionText = strValue;
    opId = -1;
    opTexture = rsm->texture_add(imgLocation);
    iconPadding = 8;
    barBox.x = buttonX;
    barBox.y = buttonY;
    barBox.w = 228;

    barBox.h = GENERAL_GPE_PADDING+( (int)buttonLines.size() *(lineHeight+GENERAL_GPE_PADDING) );

    isEnabled = true;
    wasClicked = false;
    webUrl = "";
    showBackground = true;
    showBorder = true;
    prerender_self(MAIN_RENDERER);
}

GPE_ToolPushButtonMultiLine::~GPE_ToolPushButtonMultiLine()
{

}

void GPE_ToolPushButtonMultiLine::change_texture( GPE_Texture * newTexture)
{
    opTexture = newTexture;
}

void GPE_ToolPushButtonMultiLine::enable_background( bool enableValue)
{
    if( showBackground!=enableValue)
    {
        showBackground = enableValue;
        prerender_self(MAIN_RENDERER);
    }
}

void GPE_ToolPushButtonMultiLine::enable_border( bool enableValue)
{
    if( showBorder!=enableValue)
    {
        showBorder=enableValue;
        prerender_self(MAIN_RENDERER);
    }
}

void GPE_ToolPushButtonMultiLine::prerender_self(GPE_Renderer * cRender)
{
    /*
    int prevWidth = 0;

    if( DEFAULT_FONT!=NULL)
    {
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(opName,&textW, &textH);
        barBox.w = iconPadding*3+barBox.h+textW;
    }
    */
}

void GPE_ToolPushButtonMultiLine::process_self(SDL_Rect * viewedSpace, SDL_Rect  * cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if(viewedSpace!=NULL && cam!=NULL)
    {
        GPE_GeneralGuiElement::process_self(viewedSpace,cam);
        if( isHovered)
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
        }
        if( isInUse &&( userInput->check_keyboard_down( kb_enter ) || userInput->check_keyboard_down( kb_space )  ) )
        {
            isClicked = true;
        }
        if( isClicked && (int)webUrl.size() > 3)
        {
            GPE_OpenURL(webUrl);
        }
    }
}

void GPE_ToolPushButtonMultiLine::render_self(GPE_Renderer * cRender, SDL_Rect * viewedSpace, SDL_Rect  * cam,bool forceRedraw )
{
    if( forceRedraw && isEnabled)
    {
        viewedSpace = GPE_find_camera(viewedSpace);
        cam = GPE_find_camera(cam);

        if(viewedSpace!=NULL && cam!=NULL)
        {
            GPE_Color * textRenderColor = GPE_MAIN_TEMPLATE->Button_Font_Color;
            GPE_Color * bgRenderColor = GPE_MAIN_TEMPLATE->Button_Box_Color;
            GPE_Color * textureRenderColor = c_white;
            if( isHovered || isInUse)
            {
                textRenderColor = GPE_MAIN_TEMPLATE->Button_Font_Highlighted_Color;
            }
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w+GENERAL_GPE_PADDING/2,barBox.y-cam->y+barBox.h+GENERAL_GPE_PADDING/2,c_black,false,64);

            if( showBackground)
            {
                if( isClicked )
                {
                   bgRenderColor = GPE_MAIN_TEMPLATE->Button_Box_Selected_Color;
                   textRenderColor= GPE_MAIN_TEMPLATE->Button_Font_Highlighted_Color;
                }
                else if( isHovered)
                {
                    bgRenderColor = GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color;
                    textRenderColor= GPE_MAIN_TEMPLATE->Button_Font_Highlighted_Color;
                }
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,bgRenderColor,false);
            }
            else
            {
                textRenderColor= GPE_MAIN_TEMPLATE->Button_Box_Color;
                if( isClicked )
                {
                   textRenderColor= GPE_MAIN_TEMPLATE->Button_Box_Selected_Color;
                }
                else if( isHovered)
                {
                    textRenderColor= GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color;
                }
            }
            if(  isInUse )
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Button_Border_Selected_Color,true);
            }
            else if(isHovered)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Button_Border_Highlighted_Color,true);
            }
            int iconSize = 0;
            if( showBackground)
            {
                iconSize = std::min(barBox.w,barBox.h);
                iconPadding = 0;
            }
            else
            {
                iconSize = std::min(barBox.w,barBox.h);
                iconPadding = 0;
            }
            if( opTexture!=NULL)
            {

                /*if( showBackground==false)
                {
                    if( wasClicked)
                    {
                        renderColor = GPE_MAIN_TEMPLATE->Main_Box_Faded_Font_Color;
                    }
                    else
                    {
                        renderColor = GPE_MAIN_TEMPLATE->Main_Box_Faded_Font_Color;
                    }
                }*/
                render_texture_resized(cRender,opTexture,barBox.x-cam->x+iconPadding*2, barBox.y-cam->y,iconSize,iconSize,NULL,NULL,FA_LEFT,FA_TOP,textureRenderColor );
            }


            if(DEFAULT_FONT!=NULL)
            {
                for( int ipLine = 0; ipLine < (int)buttonLines.size(); ipLine++)
                {
                    render_new_text(cRender,barBox.x-cam->x+iconSize+iconPadding*2+GENERAL_GPE_PADDING, barBox.y-cam->y+GENERAL_GPE_PADDING*2+(ipLine * (GENERAL_GPE_PADDING+lineHeight) ),buttonLines[ipLine] ,textRenderColor,DEFAULT_FONT,FA_LEFT,FA_MIDDLE);
                }
            }

            if( isInUse )
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x-cam->x+barBox.w,barBox.y-cam->y+barBox.h,GPE_MAIN_TEMPLATE->Main_Border_Highlighted_Color,true);
            }
        }
    }
}

void GPE_ToolPushButtonMultiLine::set_name(std::string newName)
{
    if( (int)newName.size() > 0 )
    {
        buttonLines.clear();
        int newLinePos=newName.find_first_of("\n");
        if(newLinePos!=(int)std::string::npos)
        {
            std::string cbNLString = split_first_string(newName,'\n');
            buttonLines.push_back(cbNLString);
            newLinePos=newName.find_first_of('\n');
            while (newLinePos!=(int)std::string::npos)
            {
                buttonLines.push_back(cbNLString);
                cbNLString = split_first_string(newName,'\n');
                newLinePos=newName.find_first_of('\n');
            }
            if( (int)newName.size() > 0 )
            {
                buttonLines.push_back(newName);
            }
        }
        else
        {
            buttonLines.push_back(newName);
        }
    }
    //barBox.h = GENERAL_GPE_PADDING*4+( (int)buttonLines.size() ) * (GENERAL_GPE_PADDING+lineHeight);
    barBox.h = GENERAL_GPE_PADDING+( (int)buttonLines.size() *(lineHeight+GENERAL_GPE_PADDING) );
    prerender_self(MAIN_RENDERER);
}

void GPE_ToolPushButtonMultiLine::set_website(std::string urlIn)
{
    webUrl = urlIn;
    wasClicked = false;
    prerender_self(MAIN_RENDERER);
}

GPE_SelectBoxBasic_Option::GPE_SelectBoxBasic_Option()
{
    optionValue = 0;
    optionName = "";
    optionTexture = NULL;
    optionSprite = NULL;
    subimageIndex = 0;
    isChecked = true;
    useGuiColor= false;
    sectionHasContent = true;
}

GPE_SelectBoxBasic_Option::~GPE_SelectBoxBasic_Option()
{

}


void GPE_SelectBoxBasic_Option::prerender_self(GPE_Renderer * cRender )
{
    if( cRender!=NULL)
    {
        //optionNameTexture->loadFromRenderedText(MAIN_RENDERER,optionName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_CATEGORY_BAR);
    }
}

GPE_SelectBoxBasic::GPE_SelectBoxBasic(int x, int y, std::string name)
{
    upDelay = 0;
    downDelay = 0;
    guiListTypeName = "selectbox";
    barBox.x = x;
    barBox.y = y;
    barBox.w = 228;
    barBox.h = GENERAL_GPE_PADDING;
    maxHeight = -1;
    opName = name;
    pos = 0;
    startPos = 0;
    maxOptionsInView = 10;
    optionHeight = GPE_TITLE_BPADDING+GENERAL_GPE_PADDING*2;
    optionIconWidth = GPE_AVERAGE_LINE_HEIGHT;
    showCheckboxes = false;
    showHideOthersCheckboxToggle= true;
}

GPE_SelectBoxBasic::~GPE_SelectBoxBasic()
{
    GPE_SelectBoxBasic_Option * tOption = NULL;
    for( int i = subOptions.size()-1; i>=0; i--)
    {
        tOption = subOptions[i];
        if( tOption!=NULL)
        {
            delete tOption;
            tOption = NULL;
        }
    }
    subOptions.clear();
}

std::string GPE_SelectBoxBasic::get_data()
{
    return "";
}

void GPE_SelectBoxBasic::load_data(std::string dataString)
{

}


void GPE_SelectBoxBasic::add_option(std::string newOptionName, double newOpValue,GPE_Texture * evRepIcon, GPE_Sprite * evRepSprite, int subimageInIndex, bool selectNew, bool useGuiColor )
{
    if( (int)newOptionName.size() > 0 || evRepIcon!=NULL || evRepSprite!=NULL )
    {
        GPE_SelectBoxBasic_Option * newOption = new GPE_SelectBoxBasic_Option();
        newOption->optionName = newOptionName;
        newOption->optionValue = newOpValue;
        newOption->optionSprite = evRepSprite;
        newOption->optionTexture = evRepIcon;
        newOption->useGuiColor = useGuiColor;
        //newOption->optionNameTexture->loadFromRenderedText(MAIN_RENDERER,newOptionName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_CATEGORY_BAR);

        newOption->subimageIndex = subimageInIndex;

        subOptions.push_back(newOption);
        if( maxHeight < 0)
        {
            barBox.h+=optionHeight;
        }
        if( selectNew)
        {
            set_selection( (int)subOptions.size() - 1 );
        }
    }
}

void GPE_SelectBoxBasic::clear_list()
{
    GPE_SelectBoxBasic_Option * tempOption = NULL;
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        tempOption = subOptions[i];
        if( tempOption!=NULL)
        {
            delete tempOption;
            tempOption = NULL;
        }
    }
    subOptions.clear();
    pos = 0;
    startPos = 0;
}

GPE_SelectBoxBasic_Option * GPE_SelectBoxBasic::get_option(int optionId)
{
    if( optionId >=0 && optionId < (int)subOptions.size() )
    {
        GPE_SelectBoxBasic_Option * tOption = subOptions.at(optionId);
        if( tOption!=NULL)
        {
            return tOption;
        }
    }
    return NULL;
}

std::string GPE_SelectBoxBasic::get_option_name(int optionId)
{
    if( optionId >=0 && optionId < (int)subOptions.size() )
    {
        GPE_SelectBoxBasic_Option * tOption = subOptions.at(optionId);
        if( tOption!=NULL)
        {
            return tOption->optionName;
        }
    }
    return "";
}

std::string GPE_SelectBoxBasic::get_selected_name()
{
    if( pos >=0 && pos < (int)subOptions.size() )
    {
        GPE_SelectBoxBasic_Option * nOption = subOptions[pos];
        if( nOption!=NULL)
        {
            return nOption->optionName;
        }
    }
    return "";
}

double GPE_SelectBoxBasic::get_selected_value()
{
    if( pos >=0 && pos < (int)subOptions.size() )
    {
        GPE_SelectBoxBasic_Option * nOption = subOptions[pos];
        if( nOption!=NULL)
        {
            return nOption->optionValue;
        }
    }
    return 0;
}

int GPE_SelectBoxBasic::get_selection()
{
    return pos;
}

int GPE_SelectBoxBasic::get_size()
{
    return (int)subOptions.size();
}

void GPE_SelectBoxBasic::insert_option(int optionId, std::string newOptionName, GPE_Texture * evRepIcon, GPE_Sprite * evRepSprite, int subimageInIndex, bool selectNew )
{
    if( (int)newOptionName.size() > 0 || evRepIcon!=NULL || evRepSprite!=NULL )
    {
        GPE_SelectBoxBasic_Option * newOption = new GPE_SelectBoxBasic_Option();
        newOption->optionName = newOptionName;
        newOption->optionSprite = evRepSprite;
        newOption->optionTexture = evRepIcon;
        newOption->subimageIndex = subimageInIndex;

        if( optionId >=0 && optionId < (int)subOptions.size() )
        {
            subOptions.insert( subOptions.begin()+optionId ,newOption );
        }
        else
        {
            subOptions.push_back( newOption );
        }
        if( maxHeight < 0)
        {
            barBox.h+=optionHeight;
        }
        if( selectNew)
        {
            set_selection( optionId+1);
        }
    }
}

void GPE_SelectBoxBasic::limit_height(int newH)
{
    if( newH >=0)
    {
        maxHeight = newH;
        barBox.h = newH;
    }
    else
    {
        maxHeight = -1;
    }
    maxOptionsInView = ceil( (float)barBox.h / (float)optionHeight );
}

void GPE_SelectBoxBasic::alter_content( int optionId, bool sectionHasContent)
{
    if( optionId >=0 && optionId < (int)subOptions.size() )
    {
        if( subOptions[optionId]!=NULL)
        {
            subOptions[optionId]->sectionHasContent = sectionHasContent;
        }
    }
}

void GPE_SelectBoxBasic::alter_content_from_value( double valueId, bool sectionHasContent)
{
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        if( subOptions[i]!=NULL && subOptions[i]->optionValue==valueId)
        {
            subOptions[i]->sectionHasContent = sectionHasContent;
            break;
        }
    }
}

bool GPE_SelectBoxBasic::move_down_space()
{
    if( pos +1 < (int)subOptions.size() )
    {
        GPE_SelectBoxBasic_Option * tempVar = subOptions[pos+1];
        subOptions[pos+1] = subOptions[pos];
        subOptions[pos] = tempVar;
        pos++;
        return true;
    }
    return false;
}

bool GPE_SelectBoxBasic::move_up_space()
{
    if( pos > 0 && (int)subOptions.size() > pos-1)
    {
        GPE_SelectBoxBasic_Option * tempVar = subOptions[pos-1];
        subOptions[pos-1] = subOptions[pos];
        subOptions[pos] = tempVar;
        pos--;
        return true;
    }
    return false;
}

void GPE_SelectBoxBasic::prerender_self(GPE_Renderer * cRender )
{

    GPE_SelectBoxBasic_Option * tOption = NULL;
    for( int i = 0; i < (int)subOptions.size() && i < (int)subOptions.size(); i++)
    {
        tOption = subOptions[i];
        if( tOption!=NULL)
        {
            tOption->prerender_self(cRender);
        }
    }

}

void GPE_SelectBoxBasic::process_self(SDL_Rect * viewedSpace, SDL_Rect * cam)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    maxOptionsInView = ceil( (float)barBox.h / (float)optionHeight );

    if( isInUse)
    {
        hasArrowkeyControl = true;
        hasScrollControl = true;
        if( userInput->released[kb_up] )
        {
            pos-=1;
            if( pos < 0 )
            {
                pos= 0;
            }
            if( pos == startPos)
            {
                startPos--;
            }
        }
        else if( userInput->released[kb_down] )
        {
            pos+=1;
            if( pos >= (int)subOptions.size() )
            {
                pos=(int)subOptions.size()-1;
            }
            if( pos>=startPos+maxOptionsInView)
            {
                startPos = pos;
                if( startPos+maxOptionsInView >= (int)subOptions.size() )
                {
                    startPos = (int)subOptions.size()-maxOptionsInView;
                    if( startPos < 0)
                    {
                        startPos = 0;
                    }
                }
            }
        }
        else if( userInput->check_keyboard_released(kb_space ) && showCheckboxes)
        {
            if( pos >=0 && pos < (int)subOptions.size() )
            {
                GPE_SelectBoxBasic_Option *  optionToChange = subOptions[pos];
                optionToChange->isChecked = !optionToChange->isChecked;
            }
        }
    }

    if( isInUse && hasScrollControl )
    {
        if( userInput->mouseScrollingUp > 0)
        {
            startPos-=1;
        }
        if( userInput->mouseScrollingDown > 0)
        {
            startPos+=1;
        }
    }

    if( startPos >= (int)subOptions.size()-maxOptionsInView )
    {
        startPos=(int)subOptions.size()-maxOptionsInView;
    }

    if( startPos < 0 )
    {
        startPos= 0;
    }

    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isClicked)
    {
        isInUse = true;
        int checkBoxWidth = optionHeight+GENERAL_GPE_PADDING;
        int checkBoxHeight = optionHeight;
        if( showCheckboxes==false)
        {
            checkBoxWidth = 0;
            checkBoxHeight = 0;
        }
        //if( userInput->check_mouse_released(0) )
        {
            int relativeOptionX = viewedSpace->x+barBox.x-cam->x;
            int relativeOptionY = viewedSpace->y+barBox.y-cam->y;
            for( int i = 0; i <= maxOptionsInView && i < (int)subOptions.size(); i++)
            {
                if( point_between(userInput->mouse_x,userInput->mouse_y,relativeOptionX,relativeOptionY+(i)*optionHeight,
                                  relativeOptionX+barBox.w,relativeOptionY+(i+1)*optionHeight) )
                {
                    if( showCheckboxes)
                    {
                        if( point_between(userInput->mouse_x,userInput->mouse_y,relativeOptionX,relativeOptionY+(i)*optionHeight,
                                  relativeOptionX+checkBoxWidth,relativeOptionY+(i+1)*optionHeight) )
                        {
                            GPE_SelectBoxBasic_Option * tOp = NULL;
                            int tPos = i+startPos;
                            if( tPos >=0 && tPos < (int)subOptions.size() )
                            {
                                tOp = subOptions.at(tPos);
                                if( tOp!=NULL)
                                {
                                    tOp->isChecked = !tOp->isChecked;
                                }
                            }
                        }
                        else
                        {
                            pos = i+startPos;
                        }
                    }
                    else
                    {
                        pos = i+startPos;
                    }
                }
            }
        }
    }
    else if(clickedOutside)
    {
        isInUse = false;
        hasScrollControl = false;
        hasArrowkeyControl = false;
    }
}

void GPE_SelectBoxBasic::render_self(GPE_Renderer * cRender,SDL_Rect * viewedSpace, SDL_Rect * cam,bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && cam!=NULL && viewedSpace!=NULL )
    {
        int relativeOptionX = barBox.x-cam->x;
        int relativeOptionY = barBox.y-cam->y;
        int foundIconWidth = std::min( optionIconWidth,optionHeight );
        render_rectangle(cRender,relativeOptionX,relativeOptionY,relativeOptionX+barBox.w,relativeOptionY+barBox.h,GPE_MAIN_TEMPLATE->PopUp_Box_Color, false);
        if( pos>=startPos && pos <= startPos+maxOptionsInView )
        {
            if(pos==0 && (int)subOptions.size() > 0)
            {
                render_rectangle(cRender,relativeOptionX,relativeOptionY+(pos-startPos)*optionHeight,relativeOptionX+barBox.w,relativeOptionY+(pos-startPos+1)*optionHeight,GPE_MAIN_TEMPLATE->Button_Border_Color,false);
            }
            else if( pos > 0)
            {
                render_rectangle(cRender,relativeOptionX,relativeOptionY+(pos-startPos)*optionHeight,relativeOptionX+barBox.w,relativeOptionY+(pos-startPos+1)*optionHeight,GPE_MAIN_TEMPLATE->Button_Border_Color,false);
            }
        }
        GPE_SelectBoxBasic_Option * tOption = NULL;
        int checkBoxWidth = optionHeight+GENERAL_GPE_PADDING;
        int checkBoxHeight = optionHeight;
        if( showCheckboxes==false)
        {
            checkBoxWidth = 0;
            checkBoxHeight = 0;
        }

        GPE_Color * fontRenderColor = GPE_MAIN_TEMPLATE->Main_Box_Faded_Font_Color;
        for( int i = startPos; i < startPos+maxOptionsInView &&  i < (int)subOptions.size(); i++)
        {
            tOption = subOptions.at( i );
            if( tOption!=NULL)
            {
                if( !tOption->sectionHasContent && pos!=i)
                {
                    fontRenderColor = GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color;
                    render_rectangle(cRender,relativeOptionX,relativeOptionY+(i-startPos)*optionHeight,relativeOptionX+barBox.w,relativeOptionY+(i-startPos+1)*optionHeight,GPE_MAIN_TEMPLATE->Program_Header_Color,false,228);
                }
                else if( pos ==i )
                {
                    fontRenderColor = GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color;
                }
                else
                {
                    fontRenderColor = GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color;
                }

                if( showCheckboxes)
                {
                    render_rectangle(cRender,relativeOptionX+relativeOptionX+GENERAL_GPE_PADDING,relativeOptionY+1+(i-startPos)*optionHeight,relativeOptionX+relativeOptionX+GENERAL_GPE_PADDING+optionHeight,relativeOptionY+(i-startPos+1)*optionHeight,GPE_MAIN_TEMPLATE->Button_Box_Color, false);
                    if( tOption->isChecked)
                    {
                        render_texture_resized(cRender, GPE_CHECKMARK_IMAGE, relativeOptionX+relativeOptionX+GENERAL_GPE_PADDING,relativeOptionY+(i-startPos)*optionHeight,optionHeight,optionHeight,NULL,NULL,-1,-1,GPE_MAIN_TEMPLATE->Checkbox_Color );
                    }
                    render_rectangle(cRender,relativeOptionX+relativeOptionX+GENERAL_GPE_PADDING,relativeOptionY+1+(i-startPos)*optionHeight,relativeOptionX+relativeOptionX+GENERAL_GPE_PADDING+optionHeight,relativeOptionY+(i-startPos+1)*optionHeight,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color, true);
                    render_new_text(cRender,relativeOptionX+GENERAL_GPE_PADDING+checkBoxWidth,relativeOptionY+(i-startPos)*optionHeight+optionHeight/2,tOption->optionName,fontRenderColor,FONT_CATEGORY_BAR,FA_LEFT,FA_CENTER,255);
                }
                else
                {
                    render_new_text(cRender,relativeOptionX+optionIconWidth+GENERAL_GPE_PADDING*2+checkBoxWidth,relativeOptionY+(i-startPos)*optionHeight+optionHeight/2,tOption->optionName,fontRenderColor,FONT_CATEGORY_BAR,FA_LEFT,FA_CENTER,255);
                }
                if( tOption->optionTexture!=NULL)
                {
                    if( tOption->useGuiColor)
                    {
                        render_texture_resized(cRender,tOption->optionTexture,relativeOptionX+GENERAL_GPE_PADDING+checkBoxWidth,relativeOptionY+(i-startPos)*optionHeight+foundIconWidth/4,foundIconWidth,foundIconWidth,NULL,NULL,FA_LEFT,FA_TOP,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color );
                    }
                    else
                    {
                        render_texture_resized(cRender,tOption->optionTexture,relativeOptionX+GENERAL_GPE_PADDING+checkBoxWidth,relativeOptionY+(i-startPos)*optionHeight+foundIconWidth/4,foundIconWidth,foundIconWidth );
                    }
                }
                else if( tOption->optionSprite!=NULL)
                {
                    if( tOption->useGuiColor)
                    {
                        render_sprite_ext(cRender,tOption->optionSprite,tOption->subimageIndex,relativeOptionX+GENERAL_GPE_PADDING+checkBoxWidth,relativeOptionY+(i-startPos)*optionHeight +(optionHeight-foundIconWidth)/2,foundIconWidth,foundIconWidth,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,NULL,cam);
                    }
                    else
                    {
                        render_sprite_resized(cRender,tOption->optionSprite,tOption->subimageIndex,relativeOptionX+GENERAL_GPE_PADDING+checkBoxWidth,relativeOptionY+(i-startPos)*optionHeight +(optionHeight-foundIconWidth)/2,foundIconWidth,foundIconWidth,NULL,cam);
                    }
                }
            }
        }

        if( startPos > 0)
        {
            render_rectangle(cRender,relativeOptionX,relativeOptionY,relativeOptionX+barBox.w,relativeOptionY+4,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,false,228);
        }
        else if( startPos+maxOptionsInView < (int)subOptions.size() )
        {
            render_rectangle(cRender,relativeOptionX,relativeOptionY+barBox.h-4,relativeOptionX+barBox.w,relativeOptionY+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,false,228);
        }
        if( isInUse)
        {
            render_rectangle(cRender,relativeOptionX,relativeOptionY,relativeOptionX+barBox.w,relativeOptionY+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color, true);
        }
        else
        {
            render_rectangle(cRender,relativeOptionX,relativeOptionY,relativeOptionX+barBox.w,relativeOptionY+barBox.h,GPE_MAIN_TEMPLATE->Main_Border_Color, true );
        }
    }
}

void GPE_SelectBoxBasic::rename_option(int optionId, std::string newName)
{
    if( optionId >=0 && optionId < (int)subOptions.size() )
    {
        GPE_SelectBoxBasic_Option * tOption = subOptions.at(optionId);
        if(tOption!=NULL )
        {
            tOption->optionName = newName;
        }
    }
}

void GPE_SelectBoxBasic::remove_option(int optionId)
{
    if( optionId>=0 && optionId < (int)subOptions.size() )
    {
        GPE_SelectBoxBasic_Option * tOption = subOptions.at(optionId);
        if(tOption!=NULL )
        {
            delete tOption;
            tOption = NULL;
        }
        subOptions.erase(subOptions.begin() + optionId);
        set_selection(pos);
    }
}

void GPE_SelectBoxBasic::set_option_height( int newOptionHeight)
{
    if( newOptionHeight > 0)
    {
        optionHeight = newOptionHeight;
    }
    maxOptionsInView = ceil( (float)barBox.h / (float)optionHeight );
}

void GPE_SelectBoxBasic::set_selected_option( std::string optionToSelect)
{
    GPE_SelectBoxBasic_Option * tempOption = NULL;
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        tempOption = subOptions[i];
        if( tempOption!=NULL)
        {
            if( tempOption->optionName==optionToSelect)
            {
                pos = i;
                if( i < startPos)
                {
                    startPos = i;
                }
                else
                {
                    startPos = i;
                }
            }
        }
    }
}

void GPE_SelectBoxBasic::set_selection( int selId)
{
    if( selId >= (int)subOptions.size() )
    {
        selId = (int)subOptions.size()-1;
    }

    if( selId < 0)
    {
        selId = 0;
    }
    pos = selId;

    startPos = pos-maxOptionsInView;
    if( startPos < 0)
    {
        startPos = 0;
    }
}

void GPE_SelectBoxBasic::toggle_others_checked()
{
    showHideOthersCheckboxToggle = !showHideOthersCheckboxToggle;
    GPE_SelectBoxBasic_Option * tOption = NULL;
    for(int i = 0; i < (int)subOptions.size(); i++)
    {
        if( i!=pos)
        {
            tOption = subOptions[i];
            if( tOption!=NULL)
            {
                tOption->isChecked = showHideOthersCheckboxToggle;
            }
        }
    }
}


GPE_Input_Field_Color::GPE_Input_Field_Color(int newX, int newY, int boxW, int boxH,std::string startName,std::string placeHolderText)
{
    opName = startName;
    guiListTypeName = "colorpicker";
    guiListTypeId = 2;
    storedColor = new GPE_Color();
    barBox.x = 0;
    barBox.y = 0;
    barBox.w = 228;
    barBox.h = 24;
    fieldBarBox.x = barBox.x;
    fieldBarBox.y = barBox.y;
    fieldBarBox.w = barBox.w;
    fieldBarBox.h = barBox.h;
    prevBarBoxW = barBox.w;
    prevBarBoxH = barBox.h;

    fontSizeH = 12;
    fontSizeW = 12;
    FONT_TEXTINPUT->get_metrics("A",&fontSizeW,&fontSizeH);
    if( fontSizeW<=0)
    {
        fontSizeW = 12;
    }
    if( fontSizeH<=0)
    {
        fontSizeH = 12;
    }
}

GPE_Input_Field_Color::~GPE_Input_Field_Color()
{
    if( storedColor!=NULL)
    {
        delete storedColor;
        storedColor = NULL;
    }
}

std::string GPE_Input_Field_Color::get_data()
{
    return guiListTypeName+":"+opName+"==|||=="+get_rgb_string()+",,,";
}

void GPE_Input_Field_Color::load_data(std::string dataString)
{
    std::string rgbColor = split_first_string(dataString,",,,");
    set_color_from_rgb(rgbColor);
}

GPE_Color * GPE_Input_Field_Color::get_color()
{
    if( storedColor!=NULL)
    {
        return storedColor->duplicate_color();
    }
    return NULL;
}

std::string GPE_Input_Field_Color::get_hex_string()
{
    if( storedColor!=NULL)
    {
        return RGBtoHEX(storedColor->get_r(),storedColor->get_g(),storedColor->get_b() );
    }
    return "000";
}

std::string GPE_Input_Field_Color::get_rgb_string()
{
    if( storedColor!=NULL)
    {
        return int_to_string(storedColor->get_r() )+","+int_to_string(storedColor->get_g() )+","+int_to_string(storedColor->get_b() );
    }
    return "0,0,0";
}

std::string GPE_Input_Field_Color::get_plain_string()
{
    return "\""+get_hex_string()+"\"";

}

int GPE_Input_Field_Color::get_r()
{
    if( storedColor!=NULL)
    {
        return storedColor->get_r();
    }
    return 0;
}

int GPE_Input_Field_Color::get_g()
{
    if( storedColor!=NULL)
    {
        return storedColor->get_g();
    }
    return 0;
}

int GPE_Input_Field_Color::get_b()
{
    if( storedColor!=NULL)
    {
        return storedColor->get_b();
    }
    return 0;
}

void GPE_Input_Field_Color::set_label(std::string newLabel)
{
    if( (int)newLabel.size() > 0)
    {
        inputLabel = newLabel;
        showLabel = true;

        barBox.h=prevBarBoxH+fontSizeH;
        barBox.w = std::max( prevBarBoxW, ( fontSizeW *(int)inputLabel.size()  ) );
        fieldBarBox.x = barBox.x;
        fieldBarBox.y = barBox.y+fontSizeH;
        fieldBarBox.w = prevBarBoxW;
        fieldBarBox.h = prevBarBoxH;
    }
    else
    {
        /*if( showLabel==true)
        {
            barBox.w = ;
            barBox.h =
        }*/
        inputLabel = "";
        showLabel = false;
    }
}

void GPE_Input_Field_Color::set_name(std::string newName)
{
    if( (int)newName.size() > 0)
    {
        if( opName == inputLabel)
        {
            set_label(newName);
        }
        opName = newName;
    }
}

void GPE_Input_Field_Color::set_string(std::string newString)
{

}

void GPE_Input_Field_Color::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    fieldBarBox.x = barBox.x;
    fieldBarBox.y = barBox.y;
    fieldBarBox.w = prevBarBoxW;
    fieldBarBox.h = prevBarBoxH;
    if( showLabel)
    {
        set_label(inputLabel);
    }
    /*
    Old Protocol for Label Fields
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);

    New Protocol for labeled fields

    */
    //
    if( isEnabled)
    {
        isClicked = false;
        isHovered = false;
        clickedOutside = false;
        viewedSpace = GPE_find_camera(viewedSpace);
        cam = GPE_find_camera(cam);
        if(viewedSpace!=NULL && cam!=NULL)
        {
            if( point_between(userInput->mouse_x,userInput->mouse_y,viewedSpace->x,viewedSpace->y,viewedSpace->x+viewedSpace->w,viewedSpace->y+viewedSpace->h) )
            {
                if (point_between(userInput->mouse_x,userInput->mouse_y,fieldBarBox.x+viewedSpace->x-cam->x,fieldBarBox.y+viewedSpace->y-cam->y,fieldBarBox.x+fieldBarBox.w+viewedSpace->x-cam->x,fieldBarBox.y+fieldBarBox.h+viewedSpace->y-cam->y) )
                {
                    isHovered = true;
                    if( (int)descriptionText.size()>0 )
                    {
                        GPE_MAIN_GUI->update_tooltip(descriptionText);
                    }
                    else
                    {
                        GPE_MAIN_GUI->update_tooltip(opName);
                    }
                    if( userInput->check_mouse_released(0) )
                    {
                        isClicked = true;
                    }
                }
                else if( userInput->check_mouse_released(-1) )
                {
                    clickedOutside = true;
                }
            }
            else if( userInput->check_mouse_released(-1) )
            {
                clickedOutside = true;
            }
        }
    }

    //
    if( isInUse &&( userInput->check_keyboard_down( kb_enter ) || userInput->check_keyboard_down( kb_space )  ) )
    {
        isClicked = true;
    }
    if( isClicked)
    {
        std::string popUpString = "";
        if( (int)inputLabel.size() > 0)
        {
            popUpString = "Change "+inputLabel;
        }
        else
        {
            popUpString = "Select a Color";
        }
        GPE_Color * nColor = GPE_Get_Color_PopUp(popUpString,storedColor);
        if( nColor!=NULL)
        {
            delete storedColor;
            storedColor = nColor;
        }
    }
}

void GPE_Input_Field_Color::render_self(GPE_Renderer * cRender ,SDL_Rect *viewedSpace , SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && isEnabled && cam!=NULL)
    {
        if( cRender->screen_was_cleared() || userInput->input_received() || forceRedraw)
        {
            if( showLabel && (int)inputLabel.size() > 0)
            {
                render_new_text_ext(cRender,barBox.x-cam->x,barBox.y-cam->y,inputLabel,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_TEXTINPUT,FA_LEFT,FA_TOP);
            }
            render_rectangle(cRender,fieldBarBox.x-cam->x,fieldBarBox.y-cam->y,fieldBarBox.x+fieldBarBox.w-cam->x,fieldBarBox.y+fieldBarBox.h-cam->y,storedColor,false);
            if( isInUse)
            {
                render_rectangle(cRender,fieldBarBox.x-cam->x,fieldBarBox.y-cam->y,fieldBarBox.x+fieldBarBox.w-cam->x,fieldBarBox.y+fieldBarBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,true);
            }
            else if( isHovered )
            {
                    render_rectangle(cRender,fieldBarBox.x-cam->x,fieldBarBox.y-cam->y,fieldBarBox.x+fieldBarBox.w-cam->x,fieldBarBox.y+fieldBarBox.h-cam->y,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,true);
            }
            else
            {
                    render_rectangle(cRender,fieldBarBox.x-cam->x,fieldBarBox.y-cam->y,fieldBarBox.x+fieldBarBox.w-cam->x,fieldBarBox.y+fieldBarBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
            }
        }
    }
}

void GPE_Input_Field_Color::set_color_from_rgb(GPE_Color *newColor)
{
    if( storedColor==NULL)
    {
        storedColor = new GPE_Color();
    }
    if( storedColor!=NULL)
    {
        if( newColor!=NULL)
        {
            storedColor->change_rgba(newColor->get_r(),newColor->get_g(),newColor->get_b() );
        }
    }
}

void GPE_Input_Field_Color::set_color_from_rgb(std::string newColorStr)
{
    int r = split_first_int(newColorStr,',');
    int g = split_first_int(newColorStr,',');
    int b = string_to_int(newColorStr,0);

    if( r < 0 || r > 255)
    {
        r = 0;
    }
    if( g < 0 || g > 255)
    {
        g = 0;
    }
    if( b < 0 || g > 255)
    {
        b = 0;
    }
    if( storedColor==NULL)
    {
        storedColor = new GPE_Color();
    }
    if( storedColor!=NULL)
    {
        storedColor->change_rgba(r,g,b);
    }
}

void GPE_Input_Field_Color::set_color_from_hex(std::string newColorStr)
{
    int r = 0, g = 0, b = 0;
    HEXtoRGB(newColorStr,r, g, b);
    if( storedColor==NULL)
    {
        storedColor = new GPE_Color();
    }
    if( storedColor!=NULL)
    {
        storedColor->change_rgba(r,g,b);
    }
}

void GPE_Input_Field_Color::set_r(int r)
{
    if( r < 0 || r > 255)
    {
        r = 0;
    }
    if( storedColor!=NULL)
    {
        storedColor->change_r(r);
    }
}

void GPE_Input_Field_Color::set_g(int g)
{
    if( g < 0 || g > 255)
    {
        g = 0;
    }
    if( storedColor!=NULL)
    {
        storedColor->change_g(g);
    }
}

void GPE_Input_Field_Color::set_b(int b)
{
    if( b < 0 || b > 255)
    {
        b = 0;
    }
    if( storedColor!=NULL)
    {
        storedColor->change_b(b);
    }
}

void GPE_Input_Field_Color::set_rgb(int r, int g, int b)
{
    if( r < 0 || r > 255)
    {
        r = 0;
    }

    if( g < 0 || g > 255)
    {
        g = 0;
    }

    if( b < 0 || b > 255)
    {
        b = 0;
    }
    if( storedColor!=NULL)
    {
        storedColor->change_rgba(r,g,b,255);
    }
}

void GPE_Input_Field_Color::set_height(int newHeight)
{
    if( showLabel)
    {
        fieldBarBox.h = newHeight;
    }
    else
    {
        barBox.h = newHeight;
        fieldBarBox.h = newHeight;
    }
    prevBarBoxH = newHeight;
}

void GPE_Input_Field_Color::set_width(int newWidth)
{
    if( showLabel)
    {
        fieldBarBox.w = newWidth;
    }
    else
    {
        barBox.w = newWidth;
        fieldBarBox.w = newWidth;
    }
    prevBarBoxW = newWidth;
}


GPE_TextInputBasic::GPE_TextInputBasic( std::string startName,std::string placeHolderText)
{
    resubmissionAllowed = false;
    opName = "";
    lastDoubleClickAction = 0;
    guiListTypeName = "inputtext";
    cursorPos = 0;
    prevCursorPos =0;
    cursorHistoryPos = -1;
    showPlaceHolder = true;
    if( (int)startName.size()>512)
    {
        startName = startName.substr(0,512);
    }
    textInputString = startName;
    cursorPos = (int) textInputString.size();
    showLabel = false;
    inputLabel = "";
    if( (int)placeHolderText.size()>512)
    {
        inputLabel = placeHolderText = placeHolderText.substr(0,512);
    }
    placeHolderString = placeHolderText;
    barBox.x = 0;
    barBox.y = 0;
    barBox.w = 192;
    barBox.h = 24;

    FONT_TEXTINPUT->get_metrics("A",&fontSizeW,&fontSizeH);
    if( fontSizeW<=0)
    {
        fontSizeW = 12;
    }
    maxCharactersInView = barBox.w/fontSizeW;

    inputFieldPos = 0;
    hasValidInput = true;
    showCursor = false;
    cursorTimer = 0;
    startXPos = 0;
    upArrowDelay = 0;
    downArrowDelay = 0;
    leftArrowDelay = 0;
    rightArrowDelay = 0;
    enterDelay = 0;
    bscDelay = 0;
    delDelay = 0;
    selectionCursorPos = selectionEndCursorPos = 0;
    fieldBarBox.x = barBox.x;
    fieldBarBox.y = barBox.y;
    prevBarBoxW = fieldBarBox.w = barBox.w;
    prevBarBoxH = fieldBarBox.h = barBox.h;
}

GPE_TextInputBasic::~GPE_TextInputBasic()
{

}

std::string GPE_TextInputBasic::get_data()
{
    return guiListTypeName+":"+opName+"==|||=="+textInputString;
}

void GPE_TextInputBasic::load_data(std::string dataString)
{
    textInputString = dataString;
}

void GPE_TextInputBasic::copy_selection()
{
    if( selectionCursorPos >=0 && selectionCursorPos < (int)textInputString.size() && selectionEndCursorPos >=0 && selectionEndCursorPos <= (int)textInputString.size() )
    {
        int minHighlightPos = std::min(selectionCursorPos,selectionEndCursorPos);
        int maxHighlightPos = std::max(selectionCursorPos,selectionEndCursorPos);
        std::string strToCopy = get_substring(textInputString,minHighlightPos,maxHighlightPos-minHighlightPos);
        SDL_SetClipboardText(strToCopy.c_str() );
        //GPE_MAIN_GUI->update_temporary_message("Selection copied","","",0.25);
    }
}

void GPE_TextInputBasic::cut_selection()
{
    copy_selection();
    delete_selection();
}

void GPE_TextInputBasic::delete_selection()
{
    if(  (int)textInputString.size() > 0 && selectionCursorPos!=selectionEndCursorPos )
    {
        int minHighlightPos = std::min(selectionCursorPos,selectionEndCursorPos);
        int maxHighlightPos = std::max(selectionCursorPos,selectionEndCursorPos);
        if(minHighlightPos >=0 && minHighlightPos < (int)textInputString.size() && maxHighlightPos >0 && maxHighlightPos <= (int)textInputString.size() )
        {
            std::string leftSideString = get_substring(textInputString,0,minHighlightPos);
            std::string rightSideString = get_substring(textInputString,maxHighlightPos);
            textInputString = leftSideString+rightSideString;
            selectionCursorPos = 0;
            selectionEndCursorPos = 0;
            cursorPos = minHighlightPos;
            if( startXPos >minHighlightPos)
            {
                startXPos = minHighlightPos;
            }
        }
    }
}

void GPE_TextInputBasic::get_cursor_from_mouse( SDL_Rect *viewedSpace, SDL_Rect *cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    cursorPos = floor( startXPos+(userInput->mouse_x-viewedSpace->x-fieldBarBox.x)/fontSizeW);
    if( cursorPos < 0)
    {
        cursorPos = 0;
    }
    if( cursorPos > (int)textInputString.size() )
    {
        cursorPos = (int)textInputString.size();
    }
}

std::string GPE_TextInputBasic::get_plain_string()
{
    if( is_alnum(textInputString,true,true) )
    {
        return textInputString;
    }
    else
    {
        return "''";
    }
}

std::string GPE_TextInputBasic::get_label()
{
    return inputLabel;
}

std::string GPE_TextInputBasic::get_string()
{
    return textInputString;
}

bool GPE_TextInputBasic::has_content()
{
    return ( (int)textInputString.size() > 0);
}

bool GPE_TextInputBasic::is_valid()
{
    return hasValidInput;
}

void GPE_TextInputBasic::move_left(int xToMove )
{
    if( xToMove > 0)
    {
        startXPos-=xToMove;
        if( startXPos < 0 )
        {
            startXPos = 0;
        }
    }
}

void GPE_TextInputBasic::move_right(int xToMove )
{
    int currStrSize = (int)textInputString.size();
    if( xToMove > 0 && currStrSize > maxCharactersInView )
    {
        startXPos+=xToMove;
        if( startXPos >= currStrSize-maxCharactersInView )
        {
            startXPos = currStrSize-maxCharactersInView;
        }
        if( startXPos >= currStrSize )
        {
            startXPos = currStrSize-1;
        }
        if( startXPos < 0 )
        {
            startXPos = 0;
        }
    }
}

void GPE_TextInputBasic::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    prevCursorPos = cursorPos;
    inputSubmitted = false;
    bool pasteCommandGiven = false;
    viewedSpace = GPE_find_camera(viewedSpace);
    maxCharactersInView = barBox.w/fontSizeW;
    cam = GPE_find_camera(cam);
    fieldBarBox.x = barBox.x;
    fieldBarBox.y = barBox.y;
    fieldBarBox.w = prevBarBoxW;
    fieldBarBox.h = prevBarBoxH;
    if( showLabel)
    {
        set_label(inputLabel);
    }
    /*
    Old Protocol for Label Fields
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);

    New Protocol for labeled fields

    */
    //
    if( isEnabled)
    {
        isClicked = false;
        isHovered = false;
        clickedOutside = false;
        viewedSpace = GPE_find_camera(viewedSpace);
        cam = GPE_find_camera(cam);
        if(viewedSpace!=NULL && cam!=NULL)
        {
            if( point_between(userInput->mouse_x,userInput->mouse_y,viewedSpace->x,viewedSpace->y,viewedSpace->x+viewedSpace->w,viewedSpace->y+viewedSpace->h) )
            {
                if (point_between(userInput->mouse_x,userInput->mouse_y,fieldBarBox.x+viewedSpace->x-cam->x,fieldBarBox.y+viewedSpace->y-cam->y,fieldBarBox.x+fieldBarBox.w+viewedSpace->x-cam->x,fieldBarBox.y+fieldBarBox.h+viewedSpace->y-cam->y) )
                {
                    isHovered = true;
                    if( (int)descriptionText.size()>0 )
                    {
                        GPE_MAIN_GUI->update_tooltip(descriptionText);
                    }
                    else
                    {
                        GPE_MAIN_GUI->update_tooltip(opName);
                    }
                    if( userInput->check_mouse_released(0) )
                    {
                        isClicked = true;
                        hasArrowkeyControl = true;
                        hasScrollControl = false;
                    }
                }
                else if( userInput->check_mouse_released(-1) )
                {
                    clickedOutside = true;
                    hasScrollControl = false;
                    hasArrowkeyControl = false;
                }
            }
            else if( userInput->check_mouse_released(-1) )
            {
                clickedOutside = true;
                hasScrollControl = false;
                hasArrowkeyControl = false;
            }
        }
    }

    //
    if( isClicked)
    {
        isInUse = true;
        inputFieldPos = 0;
        userInput->inkeys = "";
        get_cursor_from_mouse(viewedSpace,cam);
    }
    if( isHovered)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_IBEAM);
    }
    if(clickedOutside)
    {
        isInUse = false;
        reset_selection();
    }
    if( isHovered)
    {
        if( userInput->check_mouse_doubleclicked(0) )
        {
            if( lastDoubleClickAction ==0)
            {
                get_cursor_from_mouse(viewedSpace,cam);
                selectionCursorPos = cursorPos;
                selectionEndCursorPos = cursorPos;
                int iPrev = 0;
                int jNext = 0;
                if( cursorPos>=0 &&  cursorPos <= (int)textInputString.size() )
                {
                    if( textInputString[cursorPos]==' ')
                    {
                        for(iPrev = cursorPos-1; iPrev >=0; iPrev-- )
                        {
                            if( textInputString[iPrev]==' ')
                            {
                                selectionCursorPos--;
                            }
                            else
                            {
                                break;
                            }
                        }
                        for(jNext = cursorPos; jNext < (int)textInputString.size(); jNext++ )
                        {
                            if( textInputString[jNext]==' ')
                            {
                                selectionEndCursorPos++;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    else if( char_is_alnum( textInputString[cursorPos],false,false) )
                    {
                        for(iPrev = cursorPos-1; iPrev >=0; iPrev-- )
                        {
                            if( char_is_alnum( textInputString[iPrev],false,false) )
                            {
                                selectionCursorPos--;
                            }
                            else
                            {
                                break;
                            }
                        }

                        for(jNext = cursorPos; jNext < (int)textInputString.size(); jNext++ )
                        {
                            if( char_is_alnum( textInputString[jNext],false,false) )
                            {
                                selectionEndCursorPos++;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        //for symbols
                        for(iPrev = cursorPos-1; iPrev >=0; iPrev-- )
                        {
                            if( char_is_alnum( textInputString[iPrev],false,false)==false)
                            {
                                selectionCursorPos--;
                            }
                            else
                            {
                                break;
                            }
                        }
                        for(jNext = cursorPos; jNext < (int)textInputString.size(); jNext++ )
                        {
                            if( char_is_alnum( textInputString[jNext],false,false)==false)
                            {
                                selectionEndCursorPos++;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }
                lastDoubleClickAction = 1;
            }
            else
            {
                select_all();
                lastDoubleClickAction = 0;
            }
            userInput->reset_all_input();

        }
        else if( userInput->check_mouse_pressed(0) && RESOURCE_TO_DRAG==NULL )
        {
            get_cursor_from_mouse(viewedSpace,cam);
            selectionCursorPos = cursorPos;
            selectionEndCursorPos = cursorPos;
        }
        else if( userInput->check_mouse_down(0)  && RESOURCE_TO_DRAG==NULL )
        {
            get_cursor_from_mouse(viewedSpace,cam);
            selectionEndCursorPos = cursorPos;
        }
        else if( userInput->check_mouse_down(1) )
        {
            GPE_open_context_menu();
            MAIN_CONTEXT_MENU->set_width(128);
            MAIN_CONTEXT_MENU->add_menu_option("Undo",0,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/backward.png"),-1,NULL,true,true);
            MAIN_CONTEXT_MENU->add_menu_option("Cut",1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/cut.png"),-1,NULL,false,true);
            MAIN_CONTEXT_MENU->add_menu_option("Copy",2,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/copy.png"),-1,NULL,false,true);
            MAIN_CONTEXT_MENU->add_menu_option("Paste",3,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/paste.png"),-1,NULL,false,true);
            MAIN_CONTEXT_MENU->add_menu_option("Delete",4,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/remove.png"),-1,NULL,true,true);
            MAIN_CONTEXT_MENU->add_menu_option("Select All",5,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/sticky-note.png"),-1,NULL,true,true);
            int menuSelection = get_popupmenu_result();
            if( menuSelection==5)
            {
                select_all();
            }
            else
            {
                switch(menuSelection)
                {
                    case 1:
                        cut_selection();
                    break;
                    case 2:
                        copy_selection();
                    break;
                    case 3:
                        pasteCommandGiven = true;
                    break;
                    case 4:
                        delete_selection();
                    break;
                    default:
                    break;
                }
                reset_selection();
            }
        }
        else if( RESOURCE_TO_DRAG!=NULL )
        {
            if( userInput->check_mouse_released(0) )
            {
                GPE_change_cursor(SDL_SYSTEM_CURSOR_IBEAM);
                get_cursor_from_mouse(viewedSpace, cam);
                if( cursorPos >=0 && cursorPos <= (int)textInputString.size() )
                {
                    set_string( get_substring(textInputString,0,cursorPos)+RESOURCE_TO_DRAG->get_name()+get_substring(textInputString,cursorPos) );
                    RESOURCE_TO_DRAG = NULL;
                }
            }
        }
    }

    //limit_space_to_rect(viewedSpace,&INP_MOUSE_X,&INP_MOUSE_Y);
    if( isEnabled &&  isInUse )
    {
        cursorTimer+=1;
        if( cursorTimer > 15*FPS_RATIO )
        {
            showCursor = true;
        }
        if( cursorTimer > 30*FPS_RATIO )
        {
            showCursor = false;
            cursorTimer = 0;
        }
        //special control action happening
        //Process Input Field delay timers
        if( userInput->down[kb_backspace]  && !userInput->pressed[kb_backspace]  )
        {
            bscDelay+=0.5;
        }
        else
        {
            bscDelay = -1;
        }
        if( userInput->down[kb_delete] && !userInput->pressed[kb_delete] )
        {
            delDelay+=0.5;
        }
        else
        {
            delDelay = -1;
        }
        if( userInput->down[kb_up] && !userInput->released[kb_up] && !userInput->pressed[kb_up] )
        {
            upArrowDelay+=0.5;
        }
        else
        {
            upArrowDelay = -1;
        }
        if( userInput->down[kb_down] && !userInput->released[kb_down] && !userInput->pressed[kb_down] )
        {
            downArrowDelay+=0.5;
        }
        else
        {
            downArrowDelay = -1;
        }
        if( userInput->down[kb_left] && !userInput->released[kb_left] && !userInput->pressed[kb_left] )
        {
            leftArrowDelay+=0.5;
        }
        else
        {
            leftArrowDelay = -1;
        }
        if( userInput->down[kb_right] && !userInput->released[kb_right] && !userInput->pressed[kb_right] )
        {
            rightArrowDelay+=0.5;
        }
        else
        {
            rightArrowDelay = -1;
        }
        if( userInput->down[kb_enter] && !userInput->released[kb_enter] && !userInput->pressed[kb_enter] )
        {
            enterDelay+=0.5;
        }
        else
        {
            enterDelay = -1;
        }
        if( userInput->down[kb_ctrl]  )
        {
            if( userInput->down[kb_a])
            {
                select_all();
                showCursor = true;
                cursorTimer = 0;
            }
            else if( userInput->down[kb_c])
            {
                copy_selection();
                showCursor = true;
                cursorTimer = 0;
            }
            else if( userInput->released[kb_v])
            {
                pasteCommandGiven = true;
                showCursor = true;
                cursorTimer = 0;
            }
            else if( userInput->down[kb_x])
            {
                cut_selection();
                showCursor = true;
                cursorTimer = 0;
            }
            else if( userInput->mouseScrollingUp > 0)
            {
                move_left(4);
                showCursor = true;
                cursorTimer = 0;
            }
            else if( userInput->mouseScrollingDown > 0)
            {
                move_right(4);
                showCursor = true;
                cursorTimer = 0;
            }
            else if( leftArrowDelay > (GPE_MAIN_GUI->textInputDelayTime+1)*2*FPS_RATIO || ( userInput->pressed[kb_left]  && !userInput->released[kb_left]  ) )
            {
                if( userInput->shiftKeyIsPressed)
                {
                    if( selectionCursorPos==selectionEndCursorPos )
                    {
                        selectionCursorPos = cursorPos;
                    }
                }
                if( cursorPos >=0 && cursorPos <= (int)textInputString.size() )
                {
                    if( cursorPos >=(int)textInputString.size() )
                    {
                        cursorPos = (int)textInputString.size()-1;
                    }
                    if( cursorPos < 0)
                    {
                        cursorPos = 0;
                    }
                    else if( cursorPos < (int)textInputString.size() )
                    {
                        int iNCursorX = cursorPos-1;
                        for( iNCursorX = cursorPos-1; iNCursorX >=0; iNCursorX--)
                        {
                            if( char_is_alnum(textInputString[iNCursorX],false,false)==false )
                            {
                                break;
                            }
                        }
                        if( iNCursorX< 0)
                        {
                            iNCursorX = 0;
                        }
                        cursorPos = iNCursorX;
                    }
                    else
                    {
                        cursorPos = 0;
                    }
                }
                //scroll_to_cursor();
                showCursor = true;
                cursorTimer = 0;
                if( userInput->shiftKeyIsPressed)
                {
                    selectionEndCursorPos = cursorPos;
                }
                leftArrowDelay = 0;
            }
            else if( rightArrowDelay > (GPE_MAIN_GUI->textInputDelayTime+1)*2*FPS_RATIO || ( userInput->pressed[kb_right]  && !userInput->released[kb_right]  ) )
            {
                if( userInput->shiftKeyIsPressed)
                {
                    if( selectionCursorPos==selectionEndCursorPos )
                    {
                        selectionCursorPos = cursorPos;
                    }
                }
                if( cursorPos >=0 && cursorPos < (int)textInputString.size() )
                {
                    if( cursorPos >=(int)textInputString.size() )
                    {
                        cursorPos = (int)textInputString.size()-1;
                    }
                    if( cursorPos < 0)
                    {
                        cursorPos = 0;
                    }
                    else if( cursorPos < (int)textInputString.size()-1 )
                    {
                        int iNCursorX = cursorPos-1;
                        for( iNCursorX = cursorPos+1; iNCursorX < (int)textInputString.size(); iNCursorX++)
                        {
                            if( char_is_alnum(textInputString[iNCursorX],false,false)==false )
                            {
                                break;
                            }
                        }
                        if( iNCursorX< 0)
                        {
                            iNCursorX = 0;
                        }
                        cursorPos = iNCursorX;
                    }
                    else
                    {
                        cursorPos = 0;
                    }
                }
                //scroll_to_cursor();
                showCursor = true;
                cursorTimer = 0;
                if( userInput->shiftKeyIsPressed)
                {
                    selectionEndCursorPos = cursorPos;
                }
                rightArrowDelay = 0;
            }
        }
        else if( userInput->mouseScrollingUp > 0)
        {
            move_left(4);
            showCursor = true;
            cursorTimer = 0;
        }
        else if( userInput->mouseScrollingDown > 0)
        {
            move_right(4);
            showCursor = true;
            cursorTimer = 0;
        }
        else if( userInput->down[kb_alt])
        {
            //special alt action
            showCursor = true;
            cursorTimer = 0;
        }
        else if( bscDelay > (GPE_MAIN_GUI->textInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_backspace]  && !userInput->released[kb_backspace] ) )
        {
            bscDelay = 0;
            if( selectionCursorPos!=selectionEndCursorPos)
            {
                delete_selection();
            }
            else
            {
                int prevSize = (int)textInputString.size();
                if( prevSize>0  && cursorPos>0)
                {
                    cursorPos-=1;
                    std::string lineToEdit = textInputString+"";
                    textInputString = get_substring(lineToEdit,0,cursorPos );
                    std::string rightSide = get_substring(lineToEdit,cursorPos+1);
                    textInputString+=rightSide;
                    startXPos-=1;
                    if( startXPos < 0)
                    {
                        startXPos=0;
                    }
                }
            }
            showCursor = true;
            cursorTimer = 0;
            bscDelay = 0;
            //userInput->reset_all_input();
        }
        else if( delDelay > (GPE_MAIN_GUI->textInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_delete] && !userInput->released[kb_delete] ) )
        {
            if( selectionCursorPos!=selectionEndCursorPos)
            {
                delete_selection();
            }
            else
            {
                int prevSize = (int)textInputString.size();
                if( prevSize>0  && cursorPos>0)
                {
                    std::string lineToEdit = textInputString+"";
                    textInputString = get_substring(lineToEdit,0,cursorPos );
                    std::string rightSide = get_substring(lineToEdit,cursorPos+1);
                    textInputString+=rightSide;
                    startXPos-=1;
                    if( startXPos < 0)
                    {
                        startXPos=0;
                    }
                }
                delDelay = 0;
                userInput->released[kb_delete] = false;
            }
            showCursor = true;
            cursorTimer = 0;
        }
        else if( leftArrowDelay > (GPE_MAIN_GUI->textInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_left]  && !userInput->released[kb_left]  ) )
        {
            reset_selection();
            if( cursorPos > 0)
            {
                cursorPos-=1;
                if( cursorPos <= startXPos)
                {
                    move_left(1);
                    showCursor = true;
                    cursorTimer = 0;
                }
            }
            showCursor = true;
            cursorTimer = 0;
            leftArrowDelay = 0;
        }
        else if( rightArrowDelay > (GPE_MAIN_GUI->textInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_right]  && !userInput->released[kb_right] ) )
        {
            reset_selection(1);
            if( cursorPos < (int)textInputString.size() )
            {
                cursorPos+=1;
                if( cursorPos >= startXPos+maxCharactersInView)
                {
                    move_right(1);
                    showCursor = true;
                    cursorTimer = 0;
                }
            }
            showCursor = true;
            cursorTimer = 0;
            rightArrowDelay = 0;
        }
        else if( (upArrowDelay > (GPE_MAIN_GUI->textInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_up]  && !userInput->released[kb_up] ) ) && cursorHistoryPos >0 )
        {
            cursorHistoryPos--;
            cursorPos = 0;
            if( cursorHistoryPos >=0 && (int)listOfPastStrings.size() > 0 )
            {
                record_string(textInputString);
                set_string(listOfPastStrings[cursorHistoryPos]);
                select_all();
                showCursor = true;
                cursorTimer = 0;
            }
            showCursor = true;
            cursorTimer = 0;
            upArrowDelay = 0;
        }
        else if( downArrowDelay > (GPE_MAIN_GUI->textInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_down]  )  )
        {
            if( (int)listOfPastStrings.size() >0 && cursorHistoryPos>=-1 && cursorHistoryPos < (int)listOfPastStrings.size() -1 )
            {
                cursorHistoryPos++;
                cursorPos = 0;
                record_string(textInputString);
                set_string(listOfPastStrings[cursorHistoryPos]);
                select_all();
            }
            else
            {
                record_error("Unable to navigate from ["+int_to_string(cursorHistoryPos)+" with ["+int_to_string( (int)listOfPastStrings.size() )+"] past strings....");
            }
            showCursor = true;
            cursorTimer = 0;
            downArrowDelay = 0;
        }
        else if( userInput->pressed[kb_enter] )
        {
            isInUse = resubmissionAllowed;
            inputSubmitted = true;
            showCursor = true;
            cursorTimer = 0;
            enterDelay = 0;
            //record_error("Submitting self data...");
        }
        else
        {
            int moreStringSize = (int)userInput->inkeys.size();
            if( moreStringSize > 0)
            {
                delete_selection();
                textInputString=get_substring(textInputString,0,cursorPos)+userInput->inkeys+get_substring(textInputString,cursorPos);
                cursorPos+=(int)userInput->inkeys.size();
                if( cursorPos>startXPos+maxCharactersInView)
                {
                    startXPos+=moreStringSize;
                }
                showCursor = true;
                cursorTimer = 0;
            }
            userInput->inkeys = "";
        }

        if( pasteCommandGiven && SDL_HasClipboardText()==SDL_TRUE )
        {
            delete_selection();
            std::string clipboardStr = SDL_GetClipboardText();
            clipboardStr = string_replace_all(clipboardStr,"\r\n","\n");
            clipboardStr = string_replace_all(clipboardStr,"\r","\n");
            clipboardStr = string_replace_all(clipboardStr,"\t","    ");
            std::string leftBeforePaste = get_substring(textInputString,0,cursorPos);
            std::string rightBeforePaste = "";
            if( cursorPos < (int)textInputString.size() )
            {
                rightBeforePaste = get_substring(textInputString,cursorPos+1);
            }
            textInputString=leftBeforePaste+clipboardStr+rightBeforePaste;
            cursorPos+=(int)clipboardStr.size();
            move_right( (int)clipboardStr.size() );
            showCursor = true;
            cursorTimer = 0;
        }
    }
}

void GPE_TextInputBasic::record_string( std::string strToRecord)
{
    if( (int)strToRecord.size() > 0)
    {
        int recordListSize = (int)listOfPastStrings.size();
        if( recordListSize > 0)
        {
            bool duplicateStr = false;
            for( int i = 0; i < recordListSize; i++)
            {
                if( strToRecord ==listOfPastStrings[i])
                {
                    duplicateStr = true;
                }
            }
            if( !duplicateStr )
            {
                listOfPastStrings.insert( listOfPastStrings.begin(),strToRecord);
                /*if( recordListSize > MAX_STORED_TEXT_PREVIOUS_ENTRIES)
                {
                    listOfPastStrings.erase(listOfPastStrings.begin() );
                }*/

            }
        }
        else
        {
            listOfPastStrings.push_back( strToRecord);
        }
    }
}

void GPE_TextInputBasic::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace , SDL_Rect *cam ,bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( isEnabled && cam!=NULL)
    {
        if( forceRedraw)
        {
            if(showBorderBox)
            {
                if( hasValidInput )
                {
                    render_rectangle(cRender,fieldBarBox.x - cam->x,fieldBarBox.y - cam->y,fieldBarBox.x+fieldBarBox.w - cam->x,fieldBarBox.y+fieldBarBox.h - cam->y,GPE_MAIN_TEMPLATE->Input_Color,false);
                }
                else
                {
                    render_rectangle(cRender,fieldBarBox.x - cam->x,fieldBarBox.y - cam->y,fieldBarBox.x+fieldBarBox.w - cam->x,fieldBarBox.y+fieldBarBox.h - cam->y,GPE_MAIN_TEMPLATE->Input_Error_Box_Color,false);
                }
            }
            if( showLabel && (int)inputLabel.size() > 0)
            {
                render_new_text(cRender,barBox.x-cam->x,barBox.y-2-cam->y,inputLabel,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_TEXTINPUT,FA_LEFT,FA_TOP);
            }
            if(selectionCursorPos!=selectionEndCursorPos )
            {
                int minHighlightPos = std::min(selectionCursorPos, selectionEndCursorPos);
                if( minHighlightPos < startXPos)
                {
                    minHighlightPos = startXPos;
                }
                int maxHighlightPos = std::max(selectionCursorPos, selectionEndCursorPos);
                if( maxHighlightPos < startXPos)
                {
                    maxHighlightPos = startXPos;
                }
                maxHighlightPos = std::min(startXPos+maxCharactersInView,maxHighlightPos);

                render_rectangle(cRender,
                     fieldBarBox.x+(minHighlightPos-startXPos)*fontSizeW - cam->x,
                     fieldBarBox.y+1 - cam->y,
                     fieldBarBox.x+2+(maxHighlightPos-startXPos)*fontSizeW- cam->x,
                     fieldBarBox.y+fieldBarBox.h-1 - cam->y,
                     GPE_MAIN_TEMPLATE->Input_Selected_Color,false);
            }
            int subLength = 0;
            if( (int)textInputString.size() > maxCharactersInView)
            {
                subLength = (int)textInputString.size()-startXPos;
                if( subLength >maxCharactersInView)
                {
                    subLength = maxCharactersInView;
                }
            }
            else
            {
                subLength =  (int)textInputString.size();
            }

            if( subLength < 0)
            {
                subLength = 0;
            }
            if( (int)textInputString.size()>0)
            {
                render_new_text(cRender,fieldBarBox.x+4-cam->x,fieldBarBox.y+fieldBarBox.h/2- cam->y,get_substring(textInputString,startXPos,subLength),GPE_MAIN_TEMPLATE->Input_Font_Color,FONT_TEXTINPUT,FA_LEFT,FA_MIDDLE,255);
            }
            else if(showPlaceHolder && (int)placeHolderString.size() > 0 )
            {
                if( (int)placeHolderString.size() > maxCharactersInView)
                {
                    subLength = (int)placeHolderString.size()-startXPos;
                    if( subLength >maxCharactersInView)
                    {
                        subLength = maxCharactersInView;
                    }
                }
                else
                {
                    subLength =  (int)placeHolderString.size();
                }
                render_new_text(cRender,fieldBarBox.x+4-cam->x,fieldBarBox.y+fieldBarBox.h/2 - cam->y,get_substring(placeHolderString,0,subLength),GPE_MAIN_TEMPLATE->Input_Faded_Font_Color,FONT_TEXTINPUT,FA_LEFT,FA_MIDDLE);
            }
            if(showBorderBox)
            {
                if( isInUse )
                {
                    render_rectangle(cRender,fieldBarBox.x - cam->x,fieldBarBox.y - cam->y,fieldBarBox.x+fieldBarBox.w - cam->x,fieldBarBox.y+fieldBarBox.h - cam->y,GPE_MAIN_TEMPLATE->Input_Highlight_Outline_Color,true);
                }
                else if( isHovered )
                {
                    render_rectangle(cRender,fieldBarBox.x - cam->x,fieldBarBox.y - cam->y,fieldBarBox.x+fieldBarBox.w - cam->x,fieldBarBox.y+fieldBarBox.h - cam->y,GPE_MAIN_TEMPLATE->Input_Highlight_Alt_Color,true);
                }
                else
                {
                    render_rectangle(cRender,fieldBarBox.x - cam->x,fieldBarBox.y - cam->y,fieldBarBox.x+fieldBarBox.w - cam->x,fieldBarBox.y+fieldBarBox.h - cam->y,GPE_MAIN_TEMPLATE->Input_Outline_Color,true);
                }
            }
        }

        if(isInUse && prevCursorPos!=cursorPos && prevCursorPos >=startXPos && prevCursorPos <= startXPos+maxCharactersInView )
        {
            render_vertical_line_color(cRender,fieldBarBox.x+GENERAL_GPE_PADDING/2+(prevCursorPos-startXPos)*fontSizeW- cam->x,fieldBarBox.y - cam->y,fieldBarBox.y+fieldBarBox.h - cam->y,GPE_MAIN_TEMPLATE->Input_Color);
        }

        if(isInUse && cursorPos >=startXPos && cursorPos <= startXPos+maxCharactersInView )
        {
            if(showCursor)
            {
                render_vertical_line_color(cRender,fieldBarBox.x+GENERAL_GPE_PADDING/2+(cursorPos-startXPos)*fontSizeW- cam->x,fieldBarBox.y - cam->y,fieldBarBox.y+fieldBarBox.h - cam->y,GPE_MAIN_TEMPLATE->Input_Font_Color);
            }
            else
            {
                render_vertical_line_color(cRender,fieldBarBox.x+GENERAL_GPE_PADDING/2+(cursorPos-startXPos)*fontSizeW- cam->x,fieldBarBox.y - cam->y,fieldBarBox.y+fieldBarBox.h - cam->y,GPE_MAIN_TEMPLATE->Input_Color);
            }
        }
    }
}

void GPE_TextInputBasic::reset_selection(int resetDirection)
{
    if( selectionCursorPos!=selectionEndCursorPos )
    {
        if( resetDirection < 0)
        {
            cursorPos = std::min(selectionCursorPos, selectionEndCursorPos);
        }
        else
        {
            cursorPos = std::max(selectionCursorPos, selectionEndCursorPos);
        }
    }
    selectionCursorPos =0;
    selectionEndCursorPos = 0;
}

void GPE_TextInputBasic::select_all()
{
    selectionCursorPos = 0;
    selectionEndCursorPos = textInputString.size();
    cursorPos = 0;
    userInput->reset_all_input();
}

void GPE_TextInputBasic::set_height(int newHeight)
{
    if( showLabel)
    {
        fieldBarBox.h = newHeight;
    }
    else
    {
        barBox.h = newHeight;
        fieldBarBox.h = newHeight;
    }
    prevBarBoxH = newHeight;
}

void GPE_TextInputBasic::set_label(std::string newLabel)
{
    if( (int)newLabel.size() > 0)
    {
        inputLabel = newLabel;
        showLabel = true;

        barBox.h=prevBarBoxH+fontSizeH;
        barBox.w = std::max( prevBarBoxW, ( fontSizeW *(int)inputLabel.size()  ) );
        fieldBarBox.x = barBox.x;
        fieldBarBox.y = barBox.y+fontSizeH;
        fieldBarBox.w = prevBarBoxW;
        fieldBarBox.h = prevBarBoxH;
    }
    else
    {
        inputLabel = "";
        showLabel = false;
    }
}

void GPE_TextInputBasic::set_name(std::string newName)
{
    if( (int)newName.size() > 0)
    {
        if( opName == inputLabel)
        {
            set_label(newName);
        }
        opName = newName;
    }
}

void GPE_TextInputBasic::set_number( double numberIn)
{
    std::string newString = double_to_string(numberIn);
    textInputString = newString;
    record_string(textInputString);
    cursorPos = (int) textInputString.size();

}

void GPE_TextInputBasic::set_string(std::string newString)
{
    if( (int)textInputString.size() > 0)
    {
        record_string( textInputString );
    }
    if( (int)newString.size() > 0)
    {
        record_string( newString );
    }
    textInputString = newString;
    cursorPos = (int) textInputString.size();
}

void GPE_TextInputBasic::set_placeholder(std::string newString)
{
        placeHolderString = newString;
}

void GPE_TextInputBasic::set_width(int newWidth)
{
    if( showLabel)
    {
        fieldBarBox.w = newWidth;
    }
    else
    {
        barBox.w = newWidth;
        fieldBarBox.w = newWidth;
    }
    prevBarBoxW = newWidth;
}

void GPE_TextInputBasic::set_max_width( int nMW)
{
    maxWidth = nMW;
    if( maxWidth > 0 )
    {
        if( barBox.w > maxWidth || fieldBarBox.w > maxWidth)
        {
            fieldBarBox.w = maxWidth;
            barBox.w = maxWidth;
            prevBarBoxW = maxWidth;
        }
    }
}

void GPE_TextInputBasic::set_max_height( int nMH)
{
    maxHeight = nMH;
    if( maxHeight > 0 && barBox.h > maxHeight)
    {
        barBox.h = maxHeight;
    }
}

bool GPE_TextInputBasic::was_submitted()
{
    return inputSubmitted;
}

GPE_TextInputNumber::GPE_TextInputNumber( std::string placeHolderText, bool onlyWholeNums,int hMin, int hMax)
{
    resubmissionAllowed = false;
    textInputString = "";
    guiListTypeName = "inputnumber";
    guiListTypeId = 5;
    forceValidNumber = false;
    showLabel = false;
    inputLabel = "";
    if( (int)placeHolderText.size()>512)
    {
        inputLabel = placeHolderText = placeHolderText.substr(0,512);
    }
    placeHolderString = placeHolderText;
    showPlaceHolder = true;
    barBox.x = 0;
    barBox.y = 0;
    barBox.w = 192;
    barBox.h = 24;

    inputFieldPos = 0;
    onlyWholeNumbers = onlyWholeNums;

    minInputNumber = hMin;
    maxInputNumber = hMax;


    fontSizeH = 12;
    fontSizeW = 12;
    FONT_TEXTINPUT->get_metrics("A",&fontSizeW,&fontSizeH);
    if( fontSizeW<=0)
    {
        fontSizeW = 12;
    }
    maxCharactersInView = barBox.w/fontSizeW;

    hasValidInput = true;
    heldNumber = 0;
    startXPos = 0;
    cursorPos = 0;
}

GPE_TextInputNumber::~GPE_TextInputNumber()
{

}

int GPE_TextInputNumber::get_held_number()
{
    heldNumber = string_to_int(textInputString, INT_MIN);
    return heldNumber;
}

std::string GPE_TextInputNumber::get_plain_string()
{
    heldNumber = string_to_int(textInputString, INT_MIN);
    return int_to_string(heldNumber);
}

int GPE_TextInputNumber::make_valid_number(int fallbackInt)
{
    heldNumber = string_to_int(textInputString, INT_MIN);
    if( heldNumber== INT_MIN || heldNumber < minInputNumber || heldNumber > maxInputNumber)
    {
        heldNumber = fallbackInt;
        hasValidInput = true;
        set_string(""+int_to_string(fallbackInt) );
    }
    return heldNumber;
}

void GPE_TextInputNumber::process_self(SDL_Rect * viewedSpace, SDL_Rect * cam)
{
    hasValidInput = true;
    GPE_TextInputBasic::process_self(viewedSpace,cam);
    if( (int)textInputString.size() > 0)
    {
        heldNumber = string_to_int(textInputString, INT_MIN);
        if( heldNumber== INT_MIN || heldNumber < minInputNumber || heldNumber > maxInputNumber)
        {
            heldNumber = 0;
            if( forceValidNumber)
            {
                set_string("0");
            }
            hasValidInput = false;
        }
    }
    else
    {
        heldNumber = 0;
        if( forceValidNumber)
        {
            set_string("0");
        }
        hasValidInput = false;
    }
}

GPE_ParsedText::GPE_ParsedText(int nStart, int nEnd)
{
    textStart = nStart;
    textEnd = nEnd;
}

GPE_ParsedText::~GPE_ParsedText()
{

}

GPE_SynthaxLine::GPE_SynthaxLine()
{
    firstPos = -1;
    lastPos = -1;
}

GPE_SynthaxLine::~GPE_SynthaxLine()
{
    for( int i = (int)foundParses.size()-1; i >=0; i--)
    {
        if( foundParses[i]!=NULL)
        {
            delete foundParses[i];
            foundParses[i] = NULL;
        }
    }
    foundParses.clear();
}

std::string GPE_SynthaxLine::get_parsed_line(std::string sIn)
{
    int startParsingPos = 0;
    int maxParseSize = (int)sIn.size();
    GPE_ParsedText* tempParseContent = NULL;
    if( maxParseSize>0 && (int)foundParses.size()>0)
    {
        std::string rString = "";
        for( int i = 0; i < (int)foundParses.size(); i++)
        {
            tempParseContent = foundParses[i];
            if( tempParseContent!=NULL)
            {
                if( tempParseContent->textStart < 0 || tempParseContent->textStart > maxParseSize )
                {
                    tempParseContent->textStart = 0;
                }
                if( tempParseContent->textStart < tempParseContent->textEnd && tempParseContent->textEnd >0 && tempParseContent->textEnd <= maxParseSize && tempParseContent->textStart >= startParsingPos  && tempParseContent->textEnd > startParsingPos )
                {
                    rString+=string_repeat(" ",tempParseContent->textStart-startParsingPos)+sIn.substr(tempParseContent->textStart,tempParseContent->textEnd-tempParseContent->textStart);
                    startParsingPos = tempParseContent->textEnd;
                }
            }
        }
        return rString;
    }
    return "";
}

void GPE_SynthaxLine::render_tokens(GPE_Renderer * cRender,GPE_Font * fontIn, std::string sIn,int xPos, int yPos, int lineStartPos, int lineMaxPos, GPE_Color * renderColor, bool isNumber)
{
    if( cRender!=NULL )
    {
        int maxParseSize = (int)foundParses.size();
        if( maxParseSize > 0)
        {
            std::string rString = "";
            GPE_ParsedText* tempParseContent = NULL;
            if( renderColor==NULL)
            {
                renderColor = GPE_MAIN_TEMPLATE->Text_Box_Font_Color;
            }
            int fontWidth = fontIn->get_mono_width();
            for( int i = 0; i < maxParseSize; i++)
            {
                tempParseContent = foundParses[i];
                if( tempParseContent!=NULL)
                {
                    if( tempParseContent->textEnd >= lineStartPos )
                    {
                        rString = get_substring(sIn,tempParseContent->textStart,tempParseContent->textEnd-tempParseContent->textStart );
                        if( isNumber)
                        {
                            render_bitmap_text(cRender,xPos+fontWidth*(tempParseContent->textStart-lineStartPos),yPos, rString,renderColor,fontIn,FA_LEFT,FA_TOP );
                        }
                        else
                        {
                            render_new_text(cRender,xPos+fontWidth*(tempParseContent->textStart-lineStartPos),yPos, rString,renderColor,fontIn,FA_LEFT,FA_TOP );
                        }
                    }
                }
            }
        }
    }
}

void GPE_SynthaxLine::reset_self()
{
    for( int i = (int)foundParses.size()-1; i >=0; i--)
    {
        if( foundParses[i]!=NULL)
        {
            delete foundParses[i];
            foundParses[i] = NULL;
        }
    }
    foundParses.clear();
    firstPos = -1;
    lastPos = -1;
}

GPE_TextAnchor::GPE_TextAnchor(int lineN, int charN, std::string messageIn, std::string alertInfo, int anchorType)
{
    anchorType = anchorType;
    lineNumber = lineN;
    characterNumber = charN;
    lineMessage = messageIn;
    lineAlert = alertInfo;
    if( GPE_MAIN_GUI!=NULL)
    {
        anchorProjectName = GPE_MAIN_GUI->searchResultProjectName;
        anchorProjectResourceId = GPE_MAIN_GUI->searchResultResourceId;
        anchorProjectResourceName = GPE_MAIN_GUI->searchResultResourceName;
    }
    else
    {
        anchorProjectName = "";
        anchorProjectResourceId = 0;
        anchorProjectResourceName = "";
    }
    if( (int)anchorProjectResourceName.size() > 0 )
    {
        opName = "["+anchorProjectResourceName+"]["+lineMessage+"]";
    }
    else
    {
        opName = "["+lineMessage+"]";
    }
    opName+=" Ln "+int_to_string(lineN+1)+"Col "+int_to_string(charN+1);
    barBox.x = 0;
    barBox.y = 0;
    if( FONT_LABEL_ANCHOR!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL_ANCHOR->get_metrics(opName.c_str(), &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt+GENERAL_GPE_PADDING*2;
    }
}

GPE_TextAnchor::~GPE_TextAnchor()
{

}

void GPE_TextAnchor::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);

    if( isHovered)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
    }
    if( isInUse)
    {
        if( userInput->check_keyboard_down(kb_ctrl) && userInput->check_keyboard_released(kb_c) )
        {
            SDL_SetClipboardText(opName.c_str() );
        }
    }

    if( isClicked  && GPE_MAIN_GUI )
    {
        if( (int)anchorProjectName.size() > 0 )
        {
            GPE_ProjectFolder * foundProject = GPE_MAIN_GUI->find_project_from_filename(anchorProjectName);
            GPE_ResourceContainer * foundResContainer = NULL;
            generalGameResource * foundGameResource = NULL;
            if( foundProject!=NULL && foundProject->RESC_PROJECT_FOLDER!=NULL )
            {
                if( anchorProjectResourceId >=0 )
                {
                    foundResContainer = foundProject->RESC_PROJECT_FOLDER->find_resource_from_id(anchorProjectResourceId,true,false);
                }
                else if( anchorProjectResourceId < 0 )
                {
                    foundResContainer = foundProject->RESC_PROJECT_SETTINGS;
                }
            }

            if( foundResContainer!=NULL)
            {
                foundGameResource = foundResContainer->get_held_resource();
            }
            if( foundGameResource!=NULL)
            {
                foundGameResource->open_code(lineNumber, characterNumber, lineMessage );
                if( GPE_Main_TabManager!=NULL)
                {
                    GPE_Main_TabManager->add_new_tab(foundGameResource);
                }
            }
        }
        //userInput->reset_all_input();
    }
}

void GPE_TextAnchor::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && (int)opName.size() > 0 && viewedSpace!=NULL && cam!=NULL )
    {
        if( isInUse)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Highlighted_Color,true);
        }
        else if( isHovered)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Highlighted_Color,false);
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Highlighted_Color,false);
        }
        else
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Color,false);
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
        }
        render_new_text(cRender,barBox.x-cam->x+GENERAL_GPE_PADDING,barBox.y-cam->y+GENERAL_GPE_PADDING,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_LABEL_ANCHOR,FA_LEFT,FA_MIDDLE);
    }
}

//
GPE_Label_Image::GPE_Label_Image(GPE_Texture * imgIn)
{
    autoResizes = false;
    allowOverSize = false;
    resizeAspect = 1;
    guiListTypeName = "labelimage";
    opName = "";
    descriptionText = "";
    wasClicked = false;
    isHoldingCustomTexture = false;
    webUrl = "";
    imgSrc = imgIn;
    if( imgSrc!=NULL )
    {
        barBox.w = imgSrc->get_width();
        barBox.h = imgSrc->get_height();
    }
    else
    {
        barBox.w = 32;
        barBox.h = 32;
        imgSrc = NULL;
    }
}

GPE_Label_Image::GPE_Label_Image(GPE_Texture * imgIn,std::string nameIn, std::string description, std::string urlIn)
{
    allowOverSize = false;
    resizeAspect = 1;
    guiListTypeName = "labelimage";
    opName = nameIn;
    descriptionText = description;
    wasClicked = false;
    isHoldingCustomTexture = false;
    webUrl = urlIn;
    imgSrc = imgIn;
    if( imgSrc!=NULL )
    {
        barBox.w = imgSrc->get_width();
        barBox.h = imgSrc->get_height();
    }
    else
    {
        barBox.w = 32;
        barBox.h = 32;
        imgSrc = NULL;
    }
}

GPE_Label_Image::~GPE_Label_Image()
{

}

void GPE_Label_Image::load_label_image(std::string fileNameIn)
{
    if( isHoldingCustomTexture)
    {
        if( imgSrc==NULL )
        {
            imgSrc = new GPE_Texture();
        }
    }
    else
    {
        imgSrc = new GPE_Texture();
        isHoldingCustomTexture = true;
    }
    if( imgSrc!=NULL )
    {
        imgSrc->load_new_texture(MAIN_RENDERER,fileNameIn);
        barBox.w = imgSrc->get_width();
        barBox.h = imgSrc->get_height();
    }
}

void GPE_Label_Image::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isHovered && (int)webUrl.size() > 3)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
    }
    if( isClicked )
    {
        wasClicked = true;
        if( (int)webUrl.size() > 3)
        {
            GPE_OpenURL(webUrl);
        }
    }
}

void GPE_Label_Image::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && imgSrc!=NULL && cam!=NULL )
    {
        render_texture_resized(cRender,imgSrc,barBox.x-cam->x,barBox.y-cam->y,barBox.w ,barBox.h,NULL,NULL,FA_LEFT,FA_TOP);
    }
    else
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,true);
    }

    if( isInUse)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,true);
    }
}

void GPE_Label_Image::set_image( GPE_Texture * imgIn )
{
    imgSrc = imgIn;
    if( imgSrc!=NULL )
    {
        barBox.w = imgSrc->get_width();
        barBox.h = imgSrc->get_height();
    }
}

void GPE_Label_Image::set_width( int newW)
{
    //if( newW!=barBox.w)
    {
        if( newW > 0)
        {
            if( imgSrc!=NULL && !allowOverSize)
            {
                if( newW > imgSrc->get_width() )
                {
                    newW = imgSrc->get_width();
                }
            }
            barBox.w = (float)newW*resizeAspect;
            if( imgSrc!=NULL )
            {
                barBox.h = ceil( (float)newW * (float)imgSrc->get_height()/(float)imgSrc->get_width() );
            }
        }
        else
        {
            barBox.w = 0;
            barBox.h = 0;
        }
    }
}

void GPE_Label_Image::set_height( int newH)
{
    if( newH > 0)
    {
        if( imgSrc!=NULL && !allowOverSize)
        {
            if( newH > imgSrc->get_height() )
            {
                newH = imgSrc->get_height();
            }
        }
        barBox.h = (float)newH*resizeAspect;
        if( imgSrc!=NULL )
        {
            barBox.w = ceil( (float)newH * (float)imgSrc->get_width()/(float)imgSrc->get_height() );
        }
    }
    else
    {
        barBox.w = 0;
        barBox.h = 0;
    }
}

void GPE_Label_Image::set_size( int newW, int newH)
{
    barBox.w = newW;
    barBox.h = newH;
}

void GPE_Label_Image::set_name(std::string nameIn)
{
    opName = nameIn;
}

//

//

GPE_Label_Text::GPE_Label_Text(std::string nameIn, std::string description)
{
    guiListTypeName = "labeltext";
    guiListTypeId = 7;
    opName = nameIn;
    descriptionText = descriptionText;
    if( FONT_LABEL!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL->get_metrics(nameIn.c_str(), &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt;
    }
    opName = nameIn;
    hasLineBreak = true;
}

GPE_Label_Text::~GPE_Label_Text()
{

}

std::string GPE_Label_Text::get_data()
{
    return guiListTypeName+":"+opName+"==|||=="+descriptionText;
}

std::string GPE_Label_Text::get_plain_string()
{
    return "\""+opName+"\"";
}

void GPE_Label_Text::load_data(std::string dataString)
{
    descriptionText = dataString;
}

void GPE_Label_Text::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    /*
    if( isHovered)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
    }
    if( isClicked )
    {
        wasClicked = true;
        if( (int)webUrl.size() > 3)
        {
            GPE_OpenURL(webUrl);
        }
    }
    */
    if( isInUse)
    {
        if( userInput->check_keyboard_down(kb_ctrl) && userInput->check_keyboard_released(kb_c) )
        {
            SDL_SetClipboardText(opName.c_str() );
        }
    }
}

void GPE_Label_Text::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && (int)opName.size() > 0 && viewedSpace!=NULL && cam!=NULL )
    {
        render_new_text(cRender,barBox.x-cam->x,barBox.y-cam->y,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_LABEL,FA_LEFT,FA_TOP);
    }
    if( isInUse)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,true);
    }
}

void GPE_Label_Text::set_name(std::string nameIn)
{
    if( FONT_LABEL!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL->get_metrics(nameIn.c_str(), &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt;
    }
    opName = nameIn;
}

//
//

GPE_Label_Error::GPE_Label_Error(std::string nameIn, std::string description)
{
    guiListTypeName = "labelerror";
    guiListTypeId = 7;
    opName = nameIn;
    descriptionText = descriptionText;
    if( FONT_LABEL!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL->get_metrics(nameIn.c_str(), &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt;
    }
    opName = nameIn;
    hasLineBreak = true;
}

GPE_Label_Error::~GPE_Label_Error()
{

}

std::string GPE_Label_Error::get_data()
{
    return guiListTypeName+":"+opName+"==|||=="+descriptionText;
}

std::string GPE_Label_Error::get_plain_string()
{
    return "\""+opName+"\"";
}

void GPE_Label_Error::load_data(std::string dataString)
{
    descriptionText = dataString;
}

void GPE_Label_Error::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    /*
    if( isHovered)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
    }
    if( isClicked )
    {
        wasClicked = true;
        if( (int)webUrl.size() > 3)
        {
            GPE_OpenURL(webUrl);
        }
    }
    */
    if( isInUse)
    {
        if( userInput->check_keyboard_down(kb_ctrl) && userInput->check_keyboard_released(kb_c) )
        {
            SDL_SetClipboardText(opName.c_str() );
        }
    }
}

void GPE_Label_Error::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && (int)opName.size() > 0 && viewedSpace!=NULL && cam!=NULL )
    {
        render_new_text(cRender,barBox.x-cam->x,barBox.y-cam->y,opName,GPE_MAIN_TEMPLATE->Input_Error_Font_Color,FONT_LABEL,FA_LEFT,FA_TOP);
    }
    if( isInUse)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_Highlight_Color,true);
    }
}

void GPE_Label_Error::set_name(std::string nameIn)
{
    if( FONT_LABEL!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL->get_metrics(nameIn.c_str(), &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt;
    }
    opName = nameIn;
}

//

GPE_Label_90Degree::GPE_Label_90Degree(std::string nameIn, std::string description)
{
    guiListTypeName = "labeltext";
    guiListTypeId = 7;
    opName = nameIn;
    descriptionText = descriptionText;
    if( FONT_LABEL!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL->get_metrics(nameIn.c_str(), &bWid, &bHgt);
        barBox.w = bHgt;
        barBox.h = bWid;
    }
    opName = nameIn;
    hasLineBreak = true;
}

GPE_Label_90Degree::~GPE_Label_90Degree()
{

}

std::string GPE_Label_90Degree::get_data()
{
    return guiListTypeName+":"+opName+"==|||=="+descriptionText;
}

std::string GPE_Label_90Degree::get_plain_string()
{
    return "\""+opName+"\"";
}

void GPE_Label_90Degree::load_data(std::string dataString)
{
    descriptionText = dataString;
}

void GPE_Label_90Degree::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    /*
    if( isHovered)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
    }
    if( isClicked )
    {
        wasClicked = true;
        if( (int)webUrl.size() > 3)
        {
            GPE_OpenURL(webUrl);
        }
    }
    */
    if( isInUse)
    {
        if( userInput->check_keyboard_down(kb_ctrl) && userInput->check_keyboard_released(kb_c) )
        {
            SDL_SetClipboardText(opName.c_str() );
        }
    }
}

void GPE_Label_90Degree::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && (int)opName.size() > 0 && viewedSpace!=NULL && cam!=NULL )
    {
        render_new_text_rotated(cRender,barBox.x-cam->x,barBox.y-cam->y+barBox.h,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_LABEL,90);
    }
    if( isInUse)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,true);
    }
}

void GPE_Label_90Degree::set_name(std::string nameIn)
{
    if( FONT_LABEL!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL->get_metrics(nameIn.c_str(), &bWid, &bHgt);
        barBox.w = bHgt;
        barBox.h = bWid;
    }
    opName = nameIn;
}

GPE_Label_Paragraph::GPE_Label_Paragraph(std::string nameIn, std::string paragraphIn, std::string descriptionIn)
{
    autoResizes= true;
    opName = nameIn;
    paragraphText = paragraphIn;
    descriptionText = descriptionIn;
    update_paragraph();
}

GPE_Label_Paragraph::~GPE_Label_Paragraph()
{

}

void GPE_Label_Paragraph::add_line(std::string newLine)
{
    paragraphLines.push_back(newLine);
}

void GPE_Label_Paragraph::clear_all_lines()
{
    paragraphLines.clear();
}

void GPE_Label_Paragraph::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam )
{

}

void GPE_Label_Paragraph::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && viewedSpace!=NULL && cam!=NULL )
    {
        for( int i =0; i < (int)paragraphLines.size(); i++)
        {
            render_new_text(cRender,barBox.x-cam->x,barBox.y-cam->y+(GENERAL_GPE_PADDING+defaultFontHeight)*i,paragraphLines[i],GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_PARAGRAGH,FA_LEFT,FA_TOP);
        }
    }
    if( isInUse)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,true);
    }
}

void GPE_Label_Paragraph::set_name(std::string nameIn)
{

}

void GPE_Label_Paragraph::set_width(int newWidth)
{
    if( barBox.w!=newWidth)
    {
        barBox.w = newWidth;
        update_paragraph();
    }
}

void GPE_Label_Paragraph::set_height( int newHeight)
{
    if( barBox.h!=newHeight)
    {
        barBox.h = newHeight;
        update_paragraph();
    }
}

void GPE_Label_Paragraph::set_max_width( int nMW)
{
    if( barBox.w!=nMW)
    {
        barBox.w = nMW;
        update_paragraph();
    }
}

void GPE_Label_Paragraph::set_max_height( int nMH)
{
    if( barBox.h!=nMH)
    {
        barBox.h = nMH;
        update_paragraph();
    }
}

void GPE_Label_Paragraph::update_paragraph()
{
    if( barBox.w > 0 )
    {
        clear_all_lines();
        if( (int)paragraphText.size() > 0)
        {
            int maxMessageWidth = 0;
            //int maxMessageHeight = 0;
            defaultFontWidth = 0;;
            defaultFontHeight = 0;
            int iSubMessage = 0;
            if( FONT_PARAGRAGH!=NULL)
            {
                FONT_PARAGRAGH->get_metrics("A",&defaultFontWidth, &defaultFontHeight);
                FONT_PARAGRAGH->clear_cache();
            }

            std::vector < std::string > messageSubTitles;

            if( defaultFontWidth > 0 && defaultFontHeight > 0)
            {
                maxMessageWidth = ( barBox.w -GENERAL_GPE_PADDING)/ defaultFontWidth;

                if( (int)paragraphText.size() > 0)
                {
                    wrap_string(paragraphText,messageSubTitles,maxMessageWidth,-1);
                }

                maxMessageWidth = 0;
                if( messageSubTitles.size() <= 0)
                {
                    add_line("");
                    barBox.h = 0;
                }
                else
                {
                    for( iSubMessage = 0; iSubMessage < (int)messageSubTitles.size(); iSubMessage++)
                    {
                        add_line( messageSubTitles.at(iSubMessage) );
                    }
                    barBox.h = ( (int)messageSubTitles.size() ) *(GENERAL_GPE_PADDING+defaultFontHeight);
                }
            }
        }
        else
        {
            add_line("");
        }
    }
}


GPE_Label_Title::GPE_Label_Title(std::string nameIn, std::string description)
{
    guiListTypeName = "labeltitle";
    opName = nameIn;
    descriptionText = descriptionText;
    if( FONT_LABEL_TITLE!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL_TITLE->get_metrics(nameIn.c_str(), &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt;
    }
    opName = nameIn;
    hasLineBreak = true;
}

GPE_Label_Title::~GPE_Label_Title()
{

}

std::string GPE_Label_Title::get_data()
{
    return guiListTypeName+":"+opName+"==|||=="+descriptionText;
}

std::string GPE_Label_Title::get_plain_string()
{
    return "\""+opName+"\"";
}

void GPE_Label_Title::load_data(std::string dataString)
{
    descriptionText = dataString;
}

void GPE_Label_Title::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isInUse)
    {
        if( userInput->check_keyboard_down(kb_ctrl) && userInput->check_keyboard_released(kb_c) )
        {
            SDL_SetClipboardText(opName.c_str() );
        }
    }
    /*
    if( isHovered)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
    }
    if( isClicked )
    {
        wasClicked = true;
        if( (int)webUrl.size() > 3)
        {
            GPE_OpenURL(webUrl);
        }
    }
    */
}

void GPE_Label_Title::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && (int)opName.size() > 0 && viewedSpace!=NULL && cam!=NULL )
    {
        render_new_text(cRender,barBox.x-cam->x,barBox.y+barBox.h/2-cam->y,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_LABEL_TITLE,FA_LEFT,FA_MIDDLE);
    }
    if( isInUse)
    {
        render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,true);
    }
}

void GPE_Label_Title::set_name(std::string nameIn)
{
    guiListTypeName = "labeltexturl";
    if( FONT_LABEL_TITLE!=NULL && nameIn!=opName)
    {
        int bWid = 0;
        int bHgt = 0;
        FONT_LABEL_TITLE->get_metrics(nameIn.c_str(), &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt;
    }
    opName = nameIn;
}

//

GPE_TextURL::GPE_TextURL(std::string nameIn, std::string description, std::string urlIn)
{
    webId = "";
    guiListTypeName = "texturl";
    opName = nameIn;
    descriptionText = description;
    wasClicked = false;
    webUrl = urlIn;
    if( DEFAULT_FONT!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        DEFAULT_FONT->get_metrics(nameIn, &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt;
    }
}

GPE_TextURL::~GPE_TextURL()
{

}

std::string GPE_TextURL::get_data()
{
    return guiListTypeName+":"+opName+"==|||=="+descriptionText+",,,"+webUrl+",,,";
}

std::string GPE_TextURL::get_plain_string()
{
    return "\""+webUrl+"\"";
}

void GPE_TextURL::load_data(std::string dataString)
{
    descriptionText = split_first_string(dataString,",,,");
    webUrl = split_first_string(dataString,",,,");
}

void GPE_TextURL::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam)
{
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isHovered)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_HAND);
    }
    if( isInUse &&( userInput->check_keyboard_down( kb_enter ) || userInput->check_keyboard_down( kb_space )  ) )
    {
        isClicked = true;
    }
    if( isClicked )
    {
        wasClicked = true;
        if( (int)webUrl.size() > 3)
        {
            GPE_OpenURL(webUrl);
        }
    }
}

void GPE_TextURL::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw)
{
    if( forceRedraw && (int)opName.size() > 0)
    {
        if( wasClicked)
        {
            render_new_text(cRender,barBox.x-cam->x,barBox.y-cam->y,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Visited_Color,DEFAULT_FONT,FA_LEFT,FA_TOP);
            render_horizontal_line_color(cRender,barBox.y+barBox.h-cam->y,barBox.x-cam->x,barBox.x+barBox.w-cam->x,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Visited_Color);
        }
        else
        {
            render_new_text(cRender,barBox.x-cam->x,barBox.y-cam->y,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,DEFAULT_FONT,FA_LEFT,FA_TOP);
            render_horizontal_line_color(cRender,barBox.y+barBox.h-cam->y,barBox.x-cam->x,barBox.x+barBox.w-cam->x,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color);
        }
        if( isInUse)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,true);
        }
    }
}

void GPE_TextURL::set_name(std::string nameIn)
{
    if( DEFAULT_FONT!=NULL)
    {
        int bWid = 0;
        int bHgt = 0;
        DEFAULT_FONT->get_metrics(nameIn, &bWid, &bHgt);
        barBox.w = bWid;
        barBox.h = bHgt;
    }
    opName = nameIn;
}

GPE_TextAreaInputBasic::GPE_TextAreaInputBasic(bool saveFirstEdit)
{
    redrawDelay = 0;
    redrawDelayMax = 2;
    parseForErrorsTimerGoal = 60;
    parseForErrorsTimerPos = 0;
    missingSymbolDetected = false;
    missingSymbolStartXPos = 0;
    missingSymbolStartYPos = 0;
    misingSymbolSuggestedEndYPos = 0;
    misingSymbolSuggestedEndXPos = 0;

    highlightXPos = 0;
    highlightYPos = 0;
    guiListTypeName = "textarea";
    highlightedTerm = NULL;
    suggestedTextMaxInViewCount = 7;
    iSuggestedStartPos = 0;
    iSuggestionPos = 0;
    maxSuggestedTextWidth = 0;
    codeBeingSuggested = false;
    lastDoubleClickAction = 0;
    undoableActionOccurred = false;
    currentPositionInHistory = 0;
    hasLineBreak = true;
    isReadOnly = false;
    isCodeEditor = true;
    isTextLog= false;
    codeEditorType = 0;
    showXScroll = false;
    showYScroll = false;
    useWordWrap = false;
    displayMode = 0;
    cursorXPos = 0;
    cursorYPos = 0;
    prevCursorXPos = cursorXPos;
    prevCursorYPos = cursorYPos;
    cursorTimer = 0;
    showCursor = false;
    inputFieldPos = 0;
    maxLength = 2048;
    maxLineCount = 32768;
    lineCountBoxWidth = 48;
    lineStartXPos = 0;
    charactersWithinView = 16;
    linesWithinView = 4;
    lineStartYPos = 0;
    textInputString = "";
    lineToEdit = "";

    tabDelay = 0;
    bscDelay = 0;
    delDelay = 0;
    enterDelay = 0;
    upDelay = 0;
    downDelay = 0;
    leftDelay = 0;
    rightDelay = 0;
    dKeyDelay = 0;
    textXScroll = new GPE_ScrollBar_XAxis();
    textYScroll = new GPE_ScrollBar_YAxis();
    TEXTBOX_FONT_SIZE_WIDTH = 10;
    TEXTBOX_FONT_SIZE_HEIGHT = 10;
    if( FONT_TEXTINPUT!=NULL)
    {
         FONT_TEXTINPUT->get_metrics("A",&TEXTBOX_FONT_SIZE_WIDTH,&TEXTBOX_FONT_SIZE_HEIGHT);
    }
    textSpaceRect.x = 0;
    textSpaceRect.y = 0;
    textSpaceRect.w = 32;
    textSpaceRect.h = 32;

    textEditorButtonBar = NULL;
    create_buttonbar();

    selectionCursorXPos = 0;
    selectionCursorYPos = 0;
    selectionEndCursorXPos = 0;
    selectionEndCursorYPos = 0;


    symbolCursorXPos = -1;
    symbolCursorYPos = -1;
    symbolEndCursorXPos = -1;
    symbolEndCursorYPos = -1;

    commentLineText = new GPE_SynthaxLine();
    datatypeLineText = new GPE_SynthaxLine();
    functionLineText = new GPE_SynthaxLine();
    variableLineText = new GPE_SynthaxLine();
    projectFunctionLineText = new GPE_SynthaxLine();
    projectKeywordLineText = new GPE_SynthaxLine();
    keywordLineText = new GPE_SynthaxLine();
    normalLineText = new GPE_SynthaxLine();
    numberLineText = new GPE_SynthaxLine();
    dQuoteLineText = new GPE_SynthaxLine();
    sQuoteLineText = new GPE_SynthaxLine();
    symbolLineText = new GPE_SynthaxLine();
    clear_all_lines();
    listOfStrings.push_back("");
    barBox.w = 640;
    barBox.h = 480;
    if( saveFirstEdit)
    {
        save_edit();
    }
}

GPE_TextAreaInputBasic::GPE_TextAreaInputBasic(int newX, int newY, int boxW, int boxH,std::string startName,std::string placeHolderText, bool saveFirstEdit)
{
    redrawDelay = 0;
    redrawDelayMax = 2;
    parseForErrorsTimerGoal = 60;
    parseForErrorsTimerPos = 0;
    missingSymbolDetected = false;
    missingSymbolStartXPos = 0;
    missingSymbolStartYPos = 0;
    misingSymbolSuggestedEndYPos = 0;
    misingSymbolSuggestedEndXPos = 0;
    highlightXPos = 0;
    highlightYPos = 0;
    guiListTypeName = "textarea";
    highlightedTerm = NULL;
    codeBeingSuggested = false;
    maxSuggestedTextWidth= 0;
    suggestedTextMaxInViewCount = 7;
    iSuggestedStartPos = 0;
    iSuggestionPos = 0;
    lastDoubleClickAction = 0;
    undoableActionOccurred = false;
    currentPositionInHistory = 0;
    hasLineBreak = true;
    isCodeEditor = true;
    isTextLog= false;
    codeEditorType = 0;
    isReadOnly = false;
    isEnabled = true;
    barBox.x = newX;
    barBox.y = newY;
    barBox.w = boxW;
    barBox.h = boxH;
    textSpaceRect.x = newX;
    textSpaceRect.y = newY;
    textSpaceRect.w = boxW;
    textSpaceRect.h = boxH;
    showXScroll = false;
    showYScroll = false;
    useWordWrap = false;
    displayMode = 0;
    cursorXPos = 0;
    cursorYPos = 0;
    prevCursorXPos = cursorXPos;
    prevCursorYPos = cursorYPos;
    cursorTimer = 0;
    showCursor = false;
    inputFieldPos = 0;
    maxLength = 2048;
    maxLineCount = 32768;
    lineCountBoxWidth = 48;
    lineStartXPos = 0;
    charactersWithinView = 16;
    linesWithinView = 4;
    lineStartYPos = 0;
    placeHolderString = placeHolderText;
    textInputString = "";
    lineToEdit = "";
    listOfStrings.push_back("");
    bscDelay = 0;
    delDelay = 0;
    enterDelay = 0;
    upDelay = 0;
    downDelay = 0;
    leftDelay = 0;
    rightDelay = 0;
    dKeyDelay = 0;
    tabDelay=0;

    textXScroll = new GPE_ScrollBar_XAxis();
    textYScroll = new GPE_ScrollBar_YAxis();
    TEXTBOX_FONT_SIZE_WIDTH = 12;
    TEXTBOX_FONT_SIZE_HEIGHT = 12;
    if( FONT_TEXTINPUT!=NULL)
    {
         FONT_TEXTINPUT->get_metrics("A",&TEXTBOX_FONT_SIZE_WIDTH,&TEXTBOX_FONT_SIZE_HEIGHT);
    }
    textEditorButtonBar = NULL;
    create_buttonbar();

    selectionCursorXPos = 0;
    selectionCursorYPos = 0;
    selectionEndCursorXPos = 0;
    selectionEndCursorYPos = 0;

    symbolCursorXPos = -1;
    symbolCursorYPos = -1;
    symbolEndCursorXPos = -1;
    symbolEndCursorYPos = -1;

    commentLineText = new GPE_SynthaxLine();
    normalLineText = new GPE_SynthaxLine();
    datatypeLineText = new GPE_SynthaxLine();
    functionLineText = new GPE_SynthaxLine();
    numberLineText = new GPE_SynthaxLine();
    projectFunctionLineText = new GPE_SynthaxLine();
    projectKeywordLineText = new GPE_SynthaxLine();
    keywordLineText = new GPE_SynthaxLine();
    dQuoteLineText = new GPE_SynthaxLine();
    sQuoteLineText = new GPE_SynthaxLine();
    symbolLineText = new GPE_SynthaxLine();
    if( saveFirstEdit)
    {
        save_edit();
    }
}

GPE_TextAreaInputBasic::~GPE_TextAreaInputBasic()
{
    if( textXScroll!=NULL)
    {
        delete textXScroll;
        textXScroll = NULL;
    }

    if( textYScroll!=NULL)
    {
        delete textYScroll;
        textYScroll= NULL;
    }
    if( textEditorButtonBar!=NULL)
    {
        delete textEditorButtonBar;
        textEditorButtonBar = NULL;
    }
    if( commentLineText!=NULL)
    {
        delete commentLineText;
        commentLineText = NULL;
    }
    if( datatypeLineText!=NULL)
    {
        delete datatypeLineText;
        datatypeLineText = NULL;
    }
    if( dQuoteLineText!=NULL)
    {
        delete dQuoteLineText;
        dQuoteLineText = NULL;
    }
    if( functionLineText!=NULL)
    {
        delete functionLineText;
        functionLineText = NULL;
    }
    if( keywordLineText!=NULL)
    {
        delete keywordLineText;
        keywordLineText = NULL;
    }
    if( normalLineText!=NULL)
    {
        delete normalLineText;
        normalLineText = NULL;
    }

    if( numberLineText!=NULL)
    {
        delete numberLineText;
        numberLineText = NULL;
    }

    if( sQuoteLineText!=NULL)
    {
        delete sQuoteLineText;
        sQuoteLineText = NULL;
    }

    if( symbolLineText!=NULL)
    {
        delete symbolLineText;
        symbolLineText = NULL;
    }

    if( projectFunctionLineText!=NULL)
    {
        delete projectFunctionLineText;
        projectFunctionLineText = NULL;
    }

    if( projectKeywordLineText!=NULL)
    {
        delete projectKeywordLineText;
        projectKeywordLineText = NULL;
    }
    if( variableLineText!=NULL)
    {
        delete variableLineText;
        variableLineText = NULL;
    }
    int iD = 0;
    GPE_TextAreaInputBasic * tempText = NULL;
    for( iD = (int)savedHistory.size()-1; iD >=0; iD--)
    {
        tempText = savedHistory.at(iD);
        if( tempText!=NULL)
        {
            delete tempText;
            tempText = NULL;
        }
    }

    GPE_TextAnchor * tempAnchor = NULL;
    for( iD = (int)anchorPositions.size()-1; iD >=0; iD--)
    {
        tempAnchor = anchorPositions.at(iD);
        if( tempAnchor!=NULL)
        {
            delete tempAnchor;
            tempAnchor = NULL;
        }
    }
    savedHistory.clear();
    listOfStrings.clear();
    if( textEditorButtonBar!=NULL)
    {
        delete textEditorButtonBar;
        textEditorButtonBar = NULL;
    }
}

void GPE_TextAreaInputBasic::activate_self()
{
    isEnabled = true;
    isInUse = true;
    isClicked = true;
    showCursor = true;
    cursorTimer = 0;
}

void GPE_TextAreaInputBasic::add_line( std::string newLine, bool scrollToBottom)
{
    listOfStrings.push_back( trim_right_inplace(newLine) );
    if( scrollToBottom)
    {
        scroll_to_pos( (int)listOfStrings.size()-1, 0 );
    }
}

void GPE_TextAreaInputBasic::adjust_fortabs()
{
    if( cursorXPos > 0 && MAIN_EDITOR_SETTINGS!=NULL && MAIN_EDITOR_SETTINGS->mouseAutoFindTabs!=NULL && MAIN_EDITOR_SETTINGS->mouseAutoFindTabs->is_clicked() )
    {
        if( (int)listOfStrings.size() > cursorYPos )
        {
            std::string currStrToCheck = listOfStrings[cursorYPos];
            int currLineSize = (int)currStrToCheck.size();
            if( currLineSize > cursorXPos )
            {
                if( (int)currStrToCheck[cursorXPos]==' ')
                {
                    int preSpacesCounted = 0;
                    int postSpacesCounted = 0;
                    int allSpacesCounted = 0;
                    int i = 0;

                    for( i = cursorXPos-1; i>= 0; i--)
                    {
                        if( currStrToCheck[i]==' ')
                        {
                            preSpacesCounted++;
                        }
                        else
                        {
                            break;
                        }
                    }

                    for( i = cursorXPos+1; i < currLineSize; i++)
                    {
                        if( currStrToCheck[i]==' ')
                        {
                            postSpacesCounted++;
                        }
                        else
                        {
                            break;
                        }
                    }

                    allSpacesCounted = preSpacesCounted+postSpacesCounted+1;
                    preSpacesCounted = preSpacesCounted%MAIN_EDITOR_SETTINGS->tabSpaceCount;
                    postSpacesCounted = postSpacesCounted%MAIN_EDITOR_SETTINGS->tabSpaceCount;
                    if( allSpacesCounted%MAIN_EDITOR_SETTINGS->tabSpaceCount==0)
                    {
                        if( preSpacesCounted >postSpacesCounted )
                        {
                            cursorXPos+=postSpacesCounted+1;
                        }
                        else
                        {
                            cursorXPos-=preSpacesCounted;
                        }
                        scroll_to_cursor();
                    }
                }
            }
            else
            {
                cursorXPos = (int)currStrToCheck.size();
            }
        }
    }
}

bool GPE_TextAreaInputBasic::can_redo()
{
    if( currentPositionInHistory >=0 && currentPositionInHistory <= (int)savedHistory.size()-1)
    {
        return true;
    }
    return false;
}

bool GPE_TextAreaInputBasic::can_undo()
{
    if( currentPositionInHistory > 0 && (int)savedHistory.size() > 0)
    {
        return true;
    }
    return false;
}

void GPE_TextAreaInputBasic::clear_line(int lineNumber)
{

}

void GPE_TextAreaInputBasic::clear_all_lines()
{
    listOfStrings.clear();
    cursorXPos = 0;
    cursorYPos = 0;
    selectionCursorXPos = 0;
    selectionCursorYPos = 0;
    selectionEndCursorXPos = 0;
    selectionEndCursorYPos = 0;
    lineStartYPos = 0;
    linesWithinView = 0;
}

void GPE_TextAreaInputBasic::clear_text_anchors()
{
    if( (int)anchorPositions.size() > 0)
    {
        GPE_TextAnchor * tAnchor = NULL;
        for( int i = (int)anchorPositions.size()-1; i >=0; i--)
        {
            tAnchor = anchorPositions[i];
            delete tAnchor;
            tAnchor = NULL;
        }
        anchorPositions.clear();
    }
}

void GPE_TextAreaInputBasic::create_buttonbar()
{
    if( textEditorButtonBar!=NULL)
    {
        delete textEditorButtonBar;
        textEditorButtonBar = NULL;
    }
    textEditorButtonBar = new GPE_ToolIconButtonBar(0, 0,24);
    textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/plane.png","Export Text",TEXTAREkb_aTONkb_OPTION_EXPORT,false );
    textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/file.png","Import Text",TEXTAREkb_aTONkb_OPTION_IMPORT,true );
    textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/eraser.png","Clear Text ",TEXTAREkb_aTONkb_OPTION_CLEAR );
    textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/backward.png","Undo Action",TEXTAREkb_aTONkb_OPTION_UNDO,false );
    textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/forward.png","Redo Action",TEXTAREkb_aTONkb_OPTION_REDO,true );

    textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/cut.png","Cut",TEXTAREkb_aTONkb_OPTION_CUT,false );
    textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/copy.png","Copy",TEXTAREkb_aTONkb_OPTION_COPY,true );
    textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/paste.png","Paste",TEXTAREkb_aTONkb_OPTION_PASTE,true );

    //textEditorButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/info.png","Text Info (Not Available Yet)",TEXTAREkb_aTONkb_OPTION_TEXTINFO,true );
    textEditorButtonBar->limit_width(true);
}

void GPE_TextAreaInputBasic::copy_selection()
{
    if( selectionCursorYPos >=0 && selectionCursorYPos < (int)listOfStrings.size() && selectionEndCursorYPos >=0 && selectionEndCursorYPos < (int)listOfStrings.size() )
    {
        int minHighlightXPos = 0, maxHighlightXPos = 0;
        std::string newClipBoardText = "";
        std::string strToCopy = "";
        if(selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos)
        {
            std::string tempStrToUse = "";
            int minHighlightYPos = std::min(selectionCursorYPos, selectionEndCursorYPos);
            int maxHighlightYPos = std::max(selectionCursorYPos, selectionEndCursorYPos);

            if( selectionCursorYPos > selectionEndCursorYPos)
            {
                minHighlightXPos = selectionEndCursorXPos;
                maxHighlightXPos = selectionCursorXPos;
            }
            else
            {
                maxHighlightXPos = selectionEndCursorXPos;
                minHighlightXPos = selectionCursorXPos;
            }
            if(minHighlightYPos!=maxHighlightYPos)
            {
                tempStrToUse = listOfStrings.at(minHighlightYPos);
                strToCopy = get_substring(tempStrToUse,minHighlightXPos,(int)std::string::npos);
                if( maxHighlightYPos-minHighlightYPos > 1)
                {
                    for( int i= minHighlightYPos+1; i <=maxHighlightYPos-1; i++ )
                    {
                        tempStrToUse = listOfStrings[i];
                        strToCopy += "\n"+tempStrToUse;
                    }
                }
                tempStrToUse = listOfStrings.at(maxHighlightYPos);
                strToCopy += "\n"+get_substring(tempStrToUse,0,maxHighlightXPos);
            }
            else
            {
                strToCopy = listOfStrings.at(selectionCursorYPos);
                minHighlightXPos = std::min(selectionCursorXPos, selectionEndCursorXPos);
                maxHighlightXPos = std::max(selectionCursorXPos, selectionEndCursorXPos);
                strToCopy = get_substring(strToCopy,minHighlightXPos,maxHighlightXPos-minHighlightXPos);
            }
            SDL_SetClipboardText(strToCopy.c_str() );
            //GPE_MAIN_GUI->update_temporary_message("Selection copied","","",0.25);
        }
    }
}

bool GPE_TextAreaInputBasic::compile_into_code(std::ofstream * fileTarget, int leftTabAmount, bool useNewLines, bool useLastNewLine )
{
    if( fileTarget!=NULL && leftTabAmount >=0)
    {
        if( fileTarget->is_open() )
        {
            std::string nestedTabsStr = generate_tabs( leftTabAmount  );
            if( !parse_code_javascript() )
            {
                return false;
            }
            int strSize = (int)listOfStrings.size();

            for( int i = 0; i < strSize-1; i++)
            {
                if( (int)listOfStrings[i].size() > 0 )
                {
                    if( useNewLines)
                    {
                        *fileTarget << nestedTabsStr+listOfStrings[i] << "\n";
                    }
                    else
                    {
                        *fileTarget <<nestedTabsStr+listOfStrings[i] << " ";
                    }
                }
            }
            if( (int)listOfStrings[strSize-1].size() > 0 )
            {
                if( useNewLines)
                {
                    if( useLastNewLine)
                    {
                        *fileTarget << nestedTabsStr+listOfStrings[strSize-1] << "\n";
                    }
                    else
                    {
                        *fileTarget << nestedTabsStr+listOfStrings[strSize-1];
                    }
                }
                else
                {
                    *fileTarget <<nestedTabsStr+listOfStrings[strSize-1] << " ";
                }
            }
            return true;
        }
    }
    return false;
}

int GPE_TextAreaInputBasic::compare_with(GPE_TextAreaInputBasic * other)
{
    if( other!=NULL)
    {
        if( (int)listOfStrings.size() == (int)other->listOfStrings.size()  && (int)listOfStrings.size() > 0 )
        {
            std::string myString = "";
            std::string otherString = "";
            for( int i = (int)listOfStrings.size()-1; i>=0; i--)
            {
                myString = listOfStrings[i];
                otherString = other->listOfStrings[i];
                if( (int)myString.size()==(int)otherString.size() )
                {
                    if( myString.compare(otherString)!=0 )
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return 1;
        }
        return 0;
    }
    return -1;
}

bool GPE_TextAreaInputBasic::copy_all()
{
    if( has_content() )
    {
        std::string superLongClipboardStr = "";
        for( int i = 0; i < (int)listOfStrings.size(); i++)
        {
            superLongClipboardStr+=listOfStrings[i]+"\n";
        }
        if( SDL_SetClipboardText( superLongClipboardStr.c_str() )!=0 )
        {
           return false;
        }
        return true;
    }
    return false;
}
void GPE_TextAreaInputBasic::copy_source(GPE_TextAreaInputBasic * other, bool overwriteSelf)
{
    if( other!=NULL)
    {
        if( overwriteSelf)
        {
            clear_all_lines();
        }
        cursorXPos = other->cursorXPos;
        cursorYPos = other->cursorYPos;
        lineStartXPos = other->lineStartXPos;
        lineStartYPos = other->lineStartYPos;
        selectionCursorXPos = other->selectionCursorXPos;
        selectionCursorYPos = other->selectionCursorYPos;
        selectionEndCursorXPos= other->selectionEndCursorXPos;
        selectionEndCursorYPos = other->selectionEndCursorYPos;

        for( int i = 0; i < (int)other->listOfStrings.size(); i++)
        {
            listOfStrings.push_back( other->listOfStrings[i] );
        }
    }
}

void GPE_TextAreaInputBasic::cut_selection()
{
    if( !isReadOnly)
    {
        copy_selection();
        delete_selection();
    }
}

void GPE_TextAreaInputBasic::delete_content()
{

}

void GPE_TextAreaInputBasic::delete_selection()
{
    if( !isReadOnly)
    {
        if( selectionCursorYPos >=0 && selectionCursorYPos < (int)listOfStrings.size() && selectionEndCursorYPos >=0 && selectionEndCursorYPos < (int)listOfStrings.size() )
        {
            if( selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos)
            {
                int minHighlightXPos = 0, maxHighlightXPos = 0;
                std::string newClipBoardText = "";
                std::string strToCopy = "";
                std::string tempStrToUse = "";
                if(selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos)
                {
                    int minHighlightYPos = std::min(selectionCursorYPos, selectionEndCursorYPos);
                    int maxHighlightYPos = std::max(selectionCursorYPos, selectionEndCursorYPos);

                    if( selectionCursorYPos > selectionEndCursorYPos)
                    {
                        minHighlightXPos = selectionEndCursorXPos;
                        maxHighlightXPos = selectionCursorXPos;
                    }
                    else
                    {
                        maxHighlightXPos = selectionEndCursorXPos;
                        minHighlightXPos = selectionCursorXPos;
                    }

                    if(minHighlightYPos!=maxHighlightYPos)
                    {
                        tempStrToUse = listOfStrings.at(minHighlightYPos);
                        if( minHighlightXPos >= 0)
                        {
                            strToCopy = get_substring(tempStrToUse,0,minHighlightXPos);
                        }
                        tempStrToUse = listOfStrings.at(maxHighlightYPos);
                        if( maxHighlightXPos <= (int)tempStrToUse.size() )
                        {
                            strToCopy += get_substring(tempStrToUse,maxHighlightXPos);
                        }
                        for( int i=maxHighlightYPos; i >= minHighlightYPos;i-- )
                        {
                            listOfStrings.erase(listOfStrings.begin()+i);
                        }
                        if( (int)strToCopy.size() > 0)
                        {
                            cursorXPos = selectionCursorXPos = selectionEndCursorXPos = minHighlightXPos;
                            cursorYPos = selectionCursorYPos = selectionEndCursorYPos = minHighlightYPos;
                            listOfStrings.insert(listOfStrings.begin()+minHighlightYPos,strToCopy);
                        }
                        else if( (int)listOfStrings.size() > minHighlightYPos)
                        {
                            listOfStrings.insert(listOfStrings.begin()+minHighlightYPos,"");
                            cursorXPos = selectionCursorXPos = selectionEndCursorXPos = 0;
                            cursorYPos = selectionCursorYPos = selectionEndCursorYPos = minHighlightYPos;
                        }
                        else
                        {
                            listOfStrings.push_back("");
                            cursorXPos = selectionCursorXPos = selectionEndCursorXPos = 0;
                            cursorYPos = selectionCursorYPos = selectionEndCursorYPos = (int)listOfStrings.size()-1;
                        }
                    }
                    else
                    {
                        minHighlightXPos = std::min(selectionCursorXPos, selectionEndCursorXPos);
                        maxHighlightXPos = std::max(selectionCursorXPos, selectionEndCursorXPos);
                        tempStrToUse = listOfStrings.at(selectionCursorYPos);
                        strToCopy = get_substring(tempStrToUse,0,minHighlightXPos);
                        strToCopy += get_substring(tempStrToUse,maxHighlightXPos);
                        listOfStrings.erase(listOfStrings.begin()+minHighlightYPos);
                        if( strToCopy.size() > 0)
                        {
                            listOfStrings.insert(listOfStrings.begin()+minHighlightYPos,strToCopy);
                            cursorXPos = selectionCursorXPos = selectionEndCursorXPos = minHighlightXPos;
                            cursorYPos = selectionCursorYPos = selectionEndCursorYPos = minHighlightYPos;
                        }
                        else if( (int)listOfStrings.size() > minHighlightYPos)
                        {
                            listOfStrings.insert(listOfStrings.begin()+minHighlightYPos,"");
                            tempStrToUse = listOfStrings.at(minHighlightYPos);
                            cursorXPos = selectionCursorXPos = selectionEndCursorXPos = 0;
                            cursorYPos = selectionCursorYPos = selectionEndCursorYPos = minHighlightYPos;
                        }
                        else
                        {
                            listOfStrings.push_back("");
                            cursorXPos = selectionCursorXPos = selectionEndCursorXPos = 0;
                            cursorYPos = selectionCursorYPos = selectionEndCursorYPos = (int)listOfStrings.size()-1;
                        }
                    }
                    save_edit();
                }
            }

            if( listOfStrings.size() <=0)
            {
                listOfStrings.push_back("");
                cursorXPos = selectionCursorXPos = selectionEndCursorXPos = 0;
                cursorYPos = selectionCursorYPos = selectionEndCursorYPos = 0;
                save_edit();
            }
            if( cursorXPos < 0)
            {
                cursorXPos = selectionCursorXPos = selectionEndCursorXPos = 0;
                cursorYPos = selectionCursorYPos = selectionEndCursorYPos = (int)listOfStrings.size()-1;
            }
            lineToEdit = listOfStrings[cursorYPos];

        }
        else
        {
            cursorXPos = selectionCursorXPos = selectionEndCursorXPos = 0;
            cursorYPos = selectionCursorYPos = selectionEndCursorYPos = 0;
            lineToEdit = listOfStrings[cursorYPos];
        }
    }
}

void GPE_TextAreaInputBasic::duplicate_text()
{
    if( !isReadOnly)
    {
        std::string prevClipboard = SDL_GetClipboardText();

        if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
        {
            //adds selection to below...
            if( selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos)
            {
                copy_selection();
                if( selectionCursorYPos > selectionEndCursorYPos)
                {
                    cursorXPos = selectionCursorXPos;
                    cursorYPos = selectionCursorYPos;
                }
                else
                {
                    if( selectionCursorXPos > selectionEndCursorXPos)
                    {
                        cursorXPos = selectionCursorXPos;
                        cursorYPos = selectionEndCursorYPos;
                    }
                    else
                    {
                        cursorXPos = selectionEndCursorXPos;
                        cursorYPos = selectionEndCursorYPos;
                    }
                }
                int prevCX = cursorXPos;
                int prevCY = cursorYPos;
                paste_clipboard();
                cursorXPos = prevCX;
                cursorYPos = prevCY;
                SDL_SetClipboardText(prevClipboard.c_str() );
            }
            else
            {
                std::string cLineToCopy = listOfStrings[cursorYPos];
                listOfStrings.insert(listOfStrings.begin()+cursorYPos+1,cLineToCopy);
                save_edit();
            }
        }
    }
}

void GPE_TextAreaInputBasic::export_text(std::string newFileName)
{
    if( !newFileName.empty() )
    {
        std::ofstream myfile (newFileName.c_str() );
        if (myfile.is_open())
        {
            int strSize = (int)listOfStrings.size();
            for( int i = 0; i < strSize; i++)
            {
                if( i !=strSize-1)
                {
                    myfile << listOfStrings[i] << "\n";
                }
                else
                {
                    myfile << listOfStrings[i];
                }
            }
            myfile.close();
        }
        else
        {
            display_user_alert("Unable to save text",newFileName);
        }
    }
}

void GPE_TextAreaInputBasic::export_text_anchors(std::string newFileName)
{
    if( !newFileName.empty() )
    {
        std::ofstream myfile (newFileName.c_str() );
        if (myfile.is_open())
        {
            int strSize = (int)anchorPositions.size();
            GPE_TextAnchor * tAnchor = NULL;
            for( int i = 0; i < strSize; i++)
            {
                tAnchor = anchorPositions[i];
                if( tAnchor!=NULL)
                {
                    myfile <<  tAnchor->lineNumber << "," << tAnchor->characterNumber;
                    if( i !=strSize-1)
                    {
                        myfile << "\n";
                    }
                }
            }
            myfile.close();
        }
        else
        {
            display_user_alert("Unable to save text anchors",newFileName);
        }
    }
}

int GPE_TextAreaInputBasic::find_all_strings(std::string strTarget,bool matchCase, bool addAnchor, std::string areaTitle)
{
    int stringsFoundInSearch = 0;
    if( strTarget.size() > 0)
    {
        //int tempXCursor = cursorXPos;
        //int tempYCursor = cursorYPos;
        int tempLineXStart = lineStartXPos;
        int tempLineYStart = lineStartYPos;
        GPE_TextAnchor * nTextAnchor = NULL;
        clear_text_anchors();
        cursorXPos = 0;
        cursorYPos = 0;
        clear_text_anchors();
        while( find_string(strTarget,true,matchCase,false) ==true)
        {
            //add to list
            stringsFoundInSearch++;
            if( addAnchor && GPE_Main_Logs!=NULL)
            {
                nTextAnchor = new GPE_TextAnchor(selectionCursorYPos,selectionCursorXPos,areaTitle,"",GPE_ANCHOR_REGULAR);
                GPE_Main_Logs->log_general_comment( "Adding anchor.." );
                GPE_Main_Logs->searchAnchors.push_back(nTextAnchor);
            }
            else
            {
                nTextAnchor = new GPE_TextAnchor(selectionCursorYPos,selectionCursorXPos,"Found ["+strTarget+"]","",GPE_ANCHOR_REGULAR);
                anchorPositions.push_back(nTextAnchor);
            }
            cursorXPos+=(int)strTarget.size();
        }
        selectionCursorXPos = selectionEndCursorXPos = 0;
        selectionCursorYPos = selectionEndCursorYPos = 0;
        scroll_to_pos(tempLineYStart,tempLineXStart);
    }
    return stringsFoundInSearch;
}


void GPE_TextAreaInputBasic::find_mouse_cursor(int *mXCursor, int *mYCursor, SDL_Rect *viewedSpace, SDL_Rect *cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( viewedSpace!=NULL && cam!=NULL && (int)listOfStrings.size() > 0)
    {
        if( point_within_rect(userInput->mouse_x,userInput->mouse_y,&textSpaceRect)  )
        {
            *mYCursor = (float)(userInput->mouse_y - viewedSpace->y-textEditorButtonBar->get_y2pos()+cam->y)/(float)GPE_AVERAGE_LINE_HEIGHT; //gets the barBox.y pos essentially
            *mYCursor+=lineStartYPos;
            if( *mYCursor < lineStartYPos)
            {
                *mYCursor = lineStartYPos;
            }
            if( *mYCursor >= (int)listOfStrings.size() )
            {
                *mYCursor = (int)listOfStrings.size() - 1;
            }

            if( *mYCursor < 0 )
            {
                *mYCursor = 0;
            }
            if( (int)listOfStrings.size()==0)
            {
                listOfStrings.push_back("");
            }
            if( GPE_MAIN_GUI->showTextEditorLineCount )
            {
                *mXCursor = (float)(userInput->mouse_x - barBox.x-viewedSpace->x-lineCountBoxWidth+cam->x)/TEXTBOX_FONT_SIZE_WIDTH+lineStartXPos;
            }
            else
            {
                *mXCursor = (float)(userInput->mouse_x - barBox.x-viewedSpace->x+cam->x)/TEXTBOX_FONT_SIZE_WIDTH+lineStartXPos;
            }
            std::string newString = listOfStrings.at(*mYCursor);
            int maxCursorSpace = (int)newString.size();
            if( *mXCursor > maxCursorSpace )
            {
                *mXCursor = maxCursorSpace;
            }
            if( *mXCursor < 0 )
            {
                *mXCursor = 0;
            }
        }
    }
}


bool GPE_TextAreaInputBasic::find_connected_symbols()
{
    symbolCursorXPos = -1;
    symbolCursorYPos = -1;
    symbolEndCursorXPos = -1;
    symbolEndCursorYPos = -1;
    if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
    {
        lineToEdit =listOfStrings[cursorYPos];
        int seekedCursorYPos = cursorYPos;
        if( (int)lineToEdit.size() > 0)
        {
            int fCursorXPos = cursorXPos;
            std::string beginSymbol;
            std::string endSymbol;
            std::string charStr = "";
            bool foundBookedSymbol = false;
            bool searchForEndSymbol = false;;

            int subStrSearchBeginPos = cursorXPos;
            int subStrSearchEndPos = cursorXPos;
            int foundOtherMatches = 0;
            int foundSeekedMatches = 0;
            if( cursorXPos >=0 && cursorXPos <(int)lineToEdit.size() )
            {
                fCursorXPos = cursorXPos;
                subStrSearchBeginPos = fCursorXPos;
                subStrSearchEndPos = fCursorXPos;
            }
            charStr = get_substring(lineToEdit,fCursorXPos,1);
            if( charStr =="(")
            {
                beginSymbol = "(";
                endSymbol = ")";
                symbolCursorXPos = fCursorXPos;
                symbolCursorYPos = cursorYPos;
                foundBookedSymbol = true;
                searchForEndSymbol = true;
            }
            else if( charStr =="{")
            {
                beginSymbol = "{";
                endSymbol = "}";
                symbolCursorXPos = fCursorXPos;
                symbolCursorYPos = cursorYPos;
                foundBookedSymbol = true;
                searchForEndSymbol = true;
             }
            else if( charStr =="[")
            {
                beginSymbol = "[";
                endSymbol = "]";
                symbolCursorXPos = fCursorXPos;
                symbolCursorYPos = cursorYPos;
                foundBookedSymbol = true;
                searchForEndSymbol = true;
            }
            else if( charStr ==")")
            {
                beginSymbol = "(";
                endSymbol = ")";
                symbolEndCursorXPos = fCursorXPos;
                symbolEndCursorYPos = cursorYPos;
                foundBookedSymbol = true;
            }
            else if( charStr =="}")
            {
                beginSymbol = "{";
                endSymbol = "}";
                symbolEndCursorXPos = fCursorXPos;
                symbolEndCursorYPos = cursorYPos;
                foundBookedSymbol = true;
            }
            else if( charStr =="]")
            {
                beginSymbol = "[";
                endSymbol = "]";
                symbolEndCursorXPos = fCursorXPos;
                symbolEndCursorYPos = cursorYPos;
                foundBookedSymbol = true;
            }

            if( foundBookedSymbol==false && fCursorXPos-1>=0 && fCursorXPos-1 < (int)lineToEdit.size() )
            {
                charStr = get_substring(lineToEdit,fCursorXPos-1,1);
                if( charStr =="(")
                {
                    beginSymbol = "(";
                    endSymbol = ")";
                    symbolCursorXPos = fCursorXPos-1;
                    symbolCursorYPos = cursorYPos;
                    foundBookedSymbol = true;
                    searchForEndSymbol = true;
                    fCursorXPos-=1;
                }
                else if( charStr =="{")
                {
                    beginSymbol = "{";
                    endSymbol = "}";
                    symbolCursorXPos = fCursorXPos-1;
                    symbolCursorYPos = cursorYPos;
                    foundBookedSymbol = true;
                    searchForEndSymbol = true;
                    fCursorXPos-=1;
                 }
                else if( charStr =="[")
                {
                    beginSymbol = "[";
                    endSymbol = "]";
                    symbolCursorXPos = fCursorXPos-1;
                    symbolCursorYPos = cursorYPos;
                    foundBookedSymbol = true;
                    searchForEndSymbol = true;
                    fCursorXPos-=1;
                }
                else if( charStr ==")")
                {
                    beginSymbol = "(";
                    endSymbol = ")";
                    symbolEndCursorXPos = fCursorXPos-1;
                    symbolEndCursorYPos = cursorYPos;
                    foundBookedSymbol = true;
                    fCursorXPos-=1;
                }
                else if( charStr =="}")
                {
                    beginSymbol = "{";
                    endSymbol = "}";
                    symbolEndCursorXPos = fCursorXPos-1;
                    symbolEndCursorYPos = cursorYPos;
                    foundBookedSymbol = true;
                    fCursorXPos-=1;
                }
                else if( charStr =="]")
                {
                    beginSymbol = "[";
                    endSymbol = "]";
                    symbolEndCursorXPos = fCursorXPos-1;
                    symbolEndCursorYPos = cursorYPos;
                    foundBookedSymbol = true;
                    fCursorXPos-=1;
                }
            }

            if( fCursorXPos >= (int)lineToEdit.size() )
            {
                fCursorXPos = (int)lineToEdit.size()-1;
            }

            if( foundBookedSymbol )
            {
                std::string searchedStr = listOfStrings[seekedCursorYPos];
                std::string tempStr;
                int prevFoundXPos = 0;
                if( searchForEndSymbol)
                {
                    foundOtherMatches = 0;
                    foundSeekedMatches = 0;
                    prevFoundXPos = symbolCursorXPos+1;
                    while( seekedCursorYPos < (int)listOfStrings.size() )
                    {
                        searchedStr = listOfStrings[seekedCursorYPos];

                        if( prevFoundXPos!=(int)std::string::npos)
                        {
                            subStrSearchBeginPos = searchedStr.find(beginSymbol,prevFoundXPos);
                            subStrSearchEndPos = searchedStr.find(endSymbol,prevFoundXPos);

                            if( subStrSearchBeginPos!=(int)std::string::npos && subStrSearchEndPos!=(int)std::string::npos)
                            {
                                if( subStrSearchBeginPos > subStrSearchEndPos)
                                {
                                    foundSeekedMatches++;
                                    prevFoundXPos = subStrSearchEndPos+1;
                                }
                                else
                                {
                                    foundOtherMatches++;
                                    prevFoundXPos = subStrSearchBeginPos+1;
                                }
                            }
                            else if(subStrSearchEndPos!=(int)std::string::npos)
                            {
                                foundSeekedMatches++;
                                prevFoundXPos = subStrSearchEndPos+1;
                            }
                            else if(subStrSearchBeginPos!=(int)std::string::npos)
                            {
                                foundOtherMatches++;
                                prevFoundXPos = subStrSearchBeginPos+1;
                            }
                            else
                            {
                                seekedCursorYPos++;
                                prevFoundXPos = subStrSearchBeginPos = 0;
                                subStrSearchEndPos = 0;
                            }

                            if( foundSeekedMatches > foundOtherMatches )
                            {
                                symbolEndCursorXPos = subStrSearchEndPos;
                                symbolEndCursorYPos = seekedCursorYPos;
                                return true;
                            }
                        }

                        if( subStrSearchBeginPos >=(int)searchedStr.size() )
                        {
                            subStrSearchBeginPos = (int)std::string::npos ;
                        }
                        if( subStrSearchEndPos >=(int)searchedStr.size() )
                        {
                            subStrSearchEndPos = (int)std::string::npos ;
                        }
                        if( subStrSearchBeginPos==(int)std::string::npos && subStrSearchEndPos==(int)std::string::npos)
                        {
                            seekedCursorYPos++;
                            prevFoundXPos = subStrSearchBeginPos = subStrSearchEndPos = 0;
                        }
                    }
                }
                else
                {
                    //reverse iterate
                    foundOtherMatches = 0;
                    foundSeekedMatches = 0;
                    subStrSearchBeginPos = prevFoundXPos;
                    subStrSearchEndPos = prevFoundXPos;
                    seekedCursorYPos = cursorYPos;

                    if( symbolEndCursorXPos > 0)
                    {
                        prevFoundXPos = symbolEndCursorXPos-1;
                    }
                    else if( seekedCursorYPos > 0 && seekedCursorYPos <(int)listOfStrings.size() )
                    {
                        seekedCursorYPos -=1;
                        searchedStr = listOfStrings[seekedCursorYPos];
                        prevFoundXPos = (int)searchedStr.size()-1;
                    }
                    else
                    {
                        return false;
                    }

                    int cSearchCursorXPos = 0;

                    while( seekedCursorYPos >= 0 )
                    {
                        searchedStr = listOfStrings[seekedCursorYPos];

                        for( cSearchCursorXPos = prevFoundXPos; cSearchCursorXPos>=0; cSearchCursorXPos--)
                        {
                            charStr = get_substring(searchedStr,cSearchCursorXPos,1);
                            if( charStr ==beginSymbol)
                            {
                                foundSeekedMatches++;
                            }
                            else if( charStr ==endSymbol)
                            {
                                foundOtherMatches++;
                            }
                            if( foundSeekedMatches > foundOtherMatches )
                            {
                                symbolCursorXPos = cSearchCursorXPos;
                                symbolCursorYPos = seekedCursorYPos;
                                return true;
                            }
                        }
                        seekedCursorYPos--;
                        if( seekedCursorYPos>=0 && seekedCursorYPos < (int)listOfStrings.size() )
                        {
                            searchedStr = listOfStrings[seekedCursorYPos];
                            prevFoundXPos = (int)searchedStr.size()-1;
                        }
                    }
                }
            }
        }
    }
    symbolCursorXPos = -1;
    symbolCursorYPos = -1;
    symbolEndCursorXPos = -1;
    symbolEndCursorYPos = -1;
    return false;
}

bool GPE_TextAreaInputBasic::find_string(std::string strTarget, bool searchDown, bool matchCase, bool startAtFront)
{
    if( (int)strTarget.size() > 0 && has_content() )
    {
        int searchCursorXPos = 0;
        int searchCursorYPos = 0;
        std::size_t foundSubXPos;
        int foundSubYPos = 0;
        std::string strToSearch = "";
        if( searchDown)
        {
            //search down
            if( startAtFront==false)
            {
                searchCursorXPos = cursorXPos;
                searchCursorYPos = cursorYPos;
            }
            if( searchCursorYPos <0 || searchCursorYPos >= (int)listOfStrings.size() )
            {
                searchCursorYPos = 0;
            }
            strToSearch = listOfStrings.at(searchCursorYPos);
            foundSubXPos= strToSearch.find(strTarget, searchCursorXPos);
            if( (int)foundSubXPos!=(int)std::string::npos)
            {
                foundSubYPos = searchCursorYPos;
                selectionCursorXPos = foundSubXPos;
                cursorXPos = selectionEndCursorXPos = foundSubXPos+(int)strTarget.size();
                cursorYPos = selectionCursorYPos = foundSubYPos;
                selectionEndCursorYPos = foundSubYPos;
                scroll_to_selection();
                return true;
            }
            else
            {
                for( int i = searchCursorYPos+1; i < (int)listOfStrings.size();i++)
                {
                    strToSearch = listOfStrings[i];
                    foundSubXPos= strToSearch.find(strTarget, 0);
                    if( (int)foundSubXPos!=(int)std::string::npos)
                    {
                        foundSubYPos = i;
                        selectionCursorXPos = foundSubXPos;
                        cursorXPos = selectionEndCursorXPos = foundSubXPos+(int)strTarget.size();
                        cursorYPos = selectionCursorYPos = foundSubYPos;
                        selectionEndCursorYPos = foundSubYPos;
                        scroll_to_selection();
                        return true;
                    }
                }
            }
        }
        else
        {
            //search up
            if( startAtFront==false)
            {
                searchCursorYPos = listOfStrings.size()-1;
                searchCursorXPos = (listOfStrings.at(searchCursorYPos).size() );
            }
            else
            {
                searchCursorXPos = cursorXPos;
                searchCursorYPos = cursorYPos;
            }
        }
    }
    return false;
}

void GPE_TextAreaInputBasic::find_documentation_description(int tCursorX, int tCursorY)
{
    documentationIsBeingShown = false;
    iSuggestedStartPos = 0;
    iSuggestionPos = 0;
    int  i = 0;

    if( tCursorY < 0)
    {
        tCursorY = cursorYPos;
    }

    if( tCursorX < 0)
    {
        tCursorX = cursorXPos;
    }

    if( tCursorY >=(int)listOfStrings.size() )
    {
        tCursorY = (int)listOfStrings.size() -1;
    }


    if( !codeBeingSuggested && tCursorY >=0 && tCursorY < (int)listOfStrings.size() && isCodeEditor)
    {
        maxSuggestedTextWidth = 0;
        std::string currentStringInView = "";
        tempCLineXStartPos = 0;
        tempCLineXEndPos = tCursorX;
        //int tempCLineYPos = tCursorY;
        std::string cLineToParse = listOfStrings.at(tCursorY);
        GPE_Compiler_Term * tempTerm = NULL;
        highlightXPos = tCursorX;
        highlightYPos = tCursorY;
        if( tCursorX >=0 && (int)tCursorX <=(int)cLineToParse.size() && (int)cLineToParse.size() > 0)
        {
            if( tCursorX==(int)cLineToParse.size() )
            {
                tempCLineXEndPos = tCursorX-1;
            }
            if( tempCLineXEndPos < 0)
            {
                tempCLineXEndPos = 0;
            }
            //goes back one if character isn't alpha numeric
            if( !char_is_alnum(cLineToParse[tempCLineXEndPos],false,true) )
            {
                if( (int)cLineToParse.size() > tempCLineXEndPos-1)
                {
                    if( char_is_alnum(cLineToParse[tempCLineXEndPos-1],false,true) )
                    {
                        tempCLineXEndPos--;
                    }
                }
            }
            //makes sure our subtext is alphanumeric without spaces
            if( char_is_alnum(cLineToParse[tempCLineXEndPos],false,true) )
            {
                int formerEndLinePos = tempCLineXEndPos;
                for( i = formerEndLinePos-1; i< (int)cLineToParse.size(); i++)
                {
                    if( char_is_alnum(cLineToParse[i],false,true) ==false )
                    {
                        tempCLineXEndPos = i-1;
                        break;
                    }
                    else
                    {
                        tempCLineXEndPos = i;
                    }
                }

                for( i = tempCLineXEndPos-1; i >=0; i--)
                {
                    if( char_is_alnum(cLineToParse[i],false,true) ==false )
                    {
                        tempCLineXStartPos = i+1;
                        break;
                    }
                    else
                    {
                        tempCLineXStartPos = i;
                    }
                }
                if( tempCLineXStartPos > lineStartXPos)
                {
                    highlightXPos = tempCLineXStartPos;
                }
                //makes sure the length is long enough to check for
                if(tempCLineXEndPos - tempCLineXStartPos >= 2)
                {
                    currentStringInView = get_substring(cLineToParse, tempCLineXStartPos, tempCLineXEndPos-tempCLineXStartPos+1);

                    //Avoids rechecking if term is already being highlighted
                    if( highlightedTerm!=NULL)
                    {
                        if( highlightedTerm->termString==currentStringInView)
                        {
                            documentationIsBeingShown = true;
                            return;
                        }
                        else
                        {
                            highlightedTerm = NULL;
                        }
                    }

                    //css suggestions
                    if( codeEditorType==1)
                    {

                    }
                    else if( codeEditorType==0)
                    {
                        if( CURRENT_PROJECT!=NULL)
                        {
                            for( i = CURRENT_PROJECT->projectFunctions.size()-1; i>=0; i--)
                            {
                                tempTerm = CURRENT_PROJECT->projectFunctions[i];
                                if( tempTerm!=NULL)
                                {
                                    if( tempTerm->termString==currentStringInView)
                                    {
                                        highlightedTerm = tempTerm;
                                        documentationIsBeingShown = true;
                                        return;
                                    }
                                }
                            }

                            for( i = CURRENT_PROJECT->projectKeywords.size()-1; i>=0; i--)
                            {
                                tempTerm = CURRENT_PROJECT->projectKeywords[i];
                                if( tempTerm!=NULL)
                                {
                                    if( tempTerm->termString==currentStringInView)
                                    {
                                        highlightedTerm = tempTerm;
                                        documentationIsBeingShown = true;
                                        return;
                                    }
                                }
                            }
                        }

                        tempTerm = GPE_MINI_COMPILER->find_matching_function( currentStringInView);
                        if( tempTerm!=NULL)
                        {
                            highlightedTerm = tempTerm;
                            documentationIsBeingShown = true;
                            return;
                        }

                        tempTerm = GPE_MINI_COMPILER->find_matching_variable( currentStringInView);
                        if( tempTerm!=NULL)
                        {
                            highlightedTerm = tempTerm;
                            documentationIsBeingShown = true;
                            return;
                        }
                    }
                }
                else
                {
                    highlightedTerm = NULL;
                }
            }
            else
            {
                highlightedTerm = NULL;
            }
        }
        else
        {
            highlightedTerm = NULL;
        }
    }
    else
    {
        highlightedTerm = NULL;
    }
}

void GPE_TextAreaInputBasic::find_suggested_text()
{
    codeBeingSuggested = false;
    maxSuggestedTextWidth = 0;
    iSuggestedStartPos = 0;
    iSuggestionPos = 0;
    suggestedCompilerTerms.clear();
    int  i = 0;
    if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
    {
        std::string currentStringInView = "";
        tempCLineXStartPos = 0;
        tempCLineXEndPos = cursorXPos;
        //int tempCLineYPos = cursorYPos;
        std::string cLineToParse = listOfStrings[cursorYPos];
        GPE_Compiler_Term * tempTerm = NULL;
        if( cursorXPos >=0 && (int)cursorXPos <=(int)cLineToParse.size() && (int)cLineToParse.size() > 0)
        {
            if( cursorXPos==(int)cLineToParse.size() )
            {
                tempCLineXEndPos = cursorXPos-1;
            }
            if( tempCLineXEndPos < 0)
            {
                tempCLineXEndPos = 0;
            }
            //goes back one if character isn't alpha numeric
            if( !char_is_alnum(cLineToParse[tempCLineXEndPos],false,true) )
            {
                if( (int)cLineToParse.size() > tempCLineXEndPos-1)
                {
                    if( char_is_alnum(cLineToParse[tempCLineXEndPos-1],false,true) )
                    {
                        tempCLineXEndPos--;
                    }
                }
            }
            //makes sure our subtext is alphanumeric without spaces
            if( char_is_alnum(cLineToParse[tempCLineXEndPos],false,true) )
            {
                for( i = tempCLineXEndPos-1; i >=0; i--)
                {
                    if( char_is_alnum(cLineToParse[i],false,true) ==false )
                    {
                        tempCLineXStartPos = i+1;
                        break;
                    }
                }

                //makes sure the length is long enough to check for
                if(tempCLineXEndPos - tempCLineXStartPos >= 2)
                {
                    currentStringInView = cLineToParse.substr( tempCLineXStartPos, tempCLineXEndPos-tempCLineXStartPos+1);
                    //css suggestions
                    if( codeEditorType==1)
                    {

                    }
                    else if( codeEditorType==0)
                    {
                        if( CURRENT_PROJECT!=NULL)
                        {
                            for( i = CURRENT_PROJECT->projectFunctions.size()-1; i>=0; i--)
                            {
                                tempTerm = CURRENT_PROJECT->projectFunctions[i];
                                if( tempTerm!=NULL)
                                {
                                    if( string_starts(tempTerm->termString,currentStringInView) )
                                    {
                                        suggestedCompilerTerms.push_back(tempTerm);
                                    }
                                }
                            }

                            for( i = CURRENT_PROJECT->projectKeywords.size()-1; i>=0; i--)
                            {
                                tempTerm = CURRENT_PROJECT->projectKeywords[i];
                                if( tempTerm!=NULL)
                                {
                                    if( string_starts(tempTerm->termString,currentStringInView) )
                                    {
                                        suggestedCompilerTerms.push_back(tempTerm);
                                    }
                                }
                            }
                        }

                        //Language suggestions
                        if( GPE_MINI_COMPILER!=NULL && GPE_MINI_COMPILER->defaultLanguage!=NULL)
                        {
                            for( i = GPE_MINI_COMPILER->defaultLanguage->languageConstants.size()-1; i>=0; i--)
                            {
                                tempTerm = GPE_MINI_COMPILER->defaultLanguage->languageConstants[i];
                                if( tempTerm!=NULL)
                                {
                                    if( string_starts(tempTerm->termString,currentStringInView) )
                                    {
                                        suggestedCompilerTerms.push_back(tempTerm);
                                    }
                                }
                            }

                            for( i = GPE_MINI_COMPILER->defaultLanguage->languageFunctions.size()-1; i>=0; i--)
                            {
                                tempTerm = GPE_MINI_COMPILER->defaultLanguage->languageFunctions[i];
                                if( tempTerm!=NULL)
                                {
                                    if( string_starts(tempTerm->termString,currentStringInView) )
                                    {
                                        suggestedCompilerTerms.push_back(tempTerm);
                                    }
                                }
                            }

                            for( i = GPE_MINI_COMPILER->defaultLanguage->languageKeywords.size()-1; i>=0; i--)
                            {
                                tempTerm = GPE_MINI_COMPILER->defaultLanguage->languageKeywords[i];
                                if( tempTerm!=NULL)
                                {
                                    if( string_starts(tempTerm->termString,currentStringInView) )
                                    {
                                        suggestedCompilerTerms.push_back(tempTerm);
                                    }
                                }
                            }

                            for( i = GPE_MINI_COMPILER->defaultLanguage->languageVariables.size()-1; i>=0; i--)
                            {
                                tempTerm = GPE_MINI_COMPILER->defaultLanguage->languageVariables[i];
                                if( tempTerm!=NULL)
                                {
                                    if( string_starts(tempTerm->termString,currentStringInView) )
                                    {
                                        suggestedCompilerTerms.push_back(tempTerm);
                                    }
                                }
                            }
                        }
                    }
                    int tTermWidth = 0;
                    maxSuggestedTextWidth = 0;
                    //soon add optional sorting [alphabetically] of these terms here....
                    for(  i = 0; i < (int)suggestedCompilerTerms.size(); i++)
                    {
                        tempTerm = suggestedCompilerTerms[i];
                        if( tempTerm!=NULL)
                        {
                            if( tempTerm->termType==CTERM_FUNCTION)
                            {
                                tTermWidth = (int)tempTerm->termString.size()+(int)tempTerm->get_parameters().size()+(int)tempTerm->termFunctionReturnType.size()+3; // functionName(parameters)
                            }
                            else
                            {
                                tTermWidth = (int)tempTerm ->termString.size();
                            }
                            //User Global
                            if( (int)tempTerm->termScope.size() > 0 && tempTerm->termScope!="User Global" )
                            {
                                tTermWidth+=tempTerm->termScope.size()+1;
                            }

                            if( tTermWidth > maxSuggestedTextWidth)
                            {
                                maxSuggestedTextWidth = tTermWidth;
                            }
                        }
                    }
                    TEXTBOX_FONT_SIZE_WIDTH = 12;
                    TEXTBOX_FONT_SIZE_HEIGHT = 12;

                    if( FONT_TEXTINPUT!=NULL)
                    {
                         FONT_TEXTINPUT->get_metrics("A",&TEXTBOX_FONT_SIZE_WIDTH,&TEXTBOX_FONT_SIZE_HEIGHT);
                    }
                    maxSuggestedTextWidth=64+maxSuggestedTextWidth*TEXTBOX_FONT_SIZE_WIDTH;
                }
            }
        }
    }
    if( (int)suggestedCompilerTerms.size() > 0)
    {
        codeBeingSuggested = true;
    }
}

int GPE_TextAreaInputBasic::get_xcursor()
{
    return cursorXPos;
}

int GPE_TextAreaInputBasic::get_ycursor()
{
    return cursorYPos;
}

int GPE_TextAreaInputBasic::get_renderbox_height()
{
    int returnVal = barBox.h-textEditorButtonBar->get_height();
    /*switch(GPE_MAIN_GUI->textSearchMode)
    {
        case 1:
        case 2:
            returnVal = barBox.h-textEditorButtonBar->get_height()-48;
        break;
        case 3:
            returnVal = barBox.h-textEditorButtonBar->get_height()-80;
        break;
        default:
           returnVal = barBox.h-textEditorButtonBar->get_height();
        break;
    }*/
    if( showXScroll)
    {
        returnVal-=16;
    }
    return returnVal;
}

std::string GPE_TextAreaInputBasic::get_string()
{
    std::string returnString = "";
    for(int i=0; i < (int)listOfStrings.size(); i+=1)
    {
        returnString+=listOfStrings[i]+"\n";
    }
    return returnString;
}

std::string GPE_TextAreaInputBasic::get_string_spaces()
{
    std::string returnString = "";
    int listSize = (int)listOfStrings.size();
    for(int i=0; i < listSize; i+=1)
    {
        if( i ==listSize-1)
        {
            returnString+=listOfStrings[i]+" ";
        }
        else
        {
            returnString+=listOfStrings[i];
        }
    }
    return returnString;
}

int GPE_TextAreaInputBasic::get_line_count()
{
    return (int)listOfStrings.size();
}

std::string GPE_TextAreaInputBasic::get_line_string(int lineNumberIn)
{
    if( lineNumberIn >=0 && lineNumberIn < (int)listOfStrings.size() )
    {
        return listOfStrings.at(lineNumberIn);
    }
    return "";
}

std::string GPE_TextAreaInputBasic::get_short_hightlighted()
{
    if( selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos )
    {
        int yLineToCopy = std::min( selectionCursorYPos, selectionEndCursorYPos);
        if( (int)listOfStrings.size() > yLineToCopy)
        {
            int tempYlineLength = (int)listOfStrings[yLineToCopy].size();
            int minXPosToCopy = 0, maxXPosToCopy = 0;
            if(selectionCursorYPos==selectionEndCursorYPos)
            {
                minXPosToCopy = std::min( selectionCursorXPos, selectionEndCursorXPos);
                maxXPosToCopy = std::max( selectionCursorXPos, selectionEndCursorXPos);
            }
            else
            {
                if( selectionCursorYPos > selectionEndCursorYPos)
                {
                    minXPosToCopy = selectionEndCursorXPos;
                }
                else
                {
                    minXPosToCopy = selectionCursorXPos;
                }
                maxXPosToCopy = tempYlineLength;
            }
            if( tempYlineLength > minXPosToCopy && tempYlineLength >= maxXPosToCopy )
            {
                return listOfStrings[yLineToCopy].substr(minXPosToCopy,maxXPosToCopy-minXPosToCopy);
            }
        }
    }
    return "";
}

std::vector <std::string> GPE_TextAreaInputBasic::get_all_strings()
{
    return listOfStrings;
}

int GPE_TextAreaInputBasic::get_most_anchors_characters()
{
    int maxCharsUsed = 0;
    GPE_TextAnchor * tAnchor;
    for( int i = 0; i < (int)anchorPositions.size();i++)
    {
        tAnchor = anchorPositions[i];
        if( tAnchor!=NULL)
        {
            if( (int)tAnchor->lineMessage.size() > maxCharsUsed )
            {
                maxCharsUsed = (int)tAnchor->lineMessage.size();
            }
        }
    }
    return maxCharsUsed;
}

int GPE_TextAreaInputBasic::get_most_characters_used()
{
    int maxCharsUsed = 0;
    for( int i = 0; i < (int)listOfStrings.size();i++)
    {
        if( (int)listOfStrings[i].size() > maxCharsUsed)
        {
            maxCharsUsed = (int)listOfStrings[i].size();
        }
    }
    return maxCharsUsed;
}

void GPE_TextAreaInputBasic::handle_scrolling()
{

}

bool GPE_TextAreaInputBasic::has_content()
{
    if((int)listOfStrings.size() > 1)
    {
        return true;
    }
    else if((int)listOfStrings.size()==1 )
    {
        std::string firstLine = listOfStrings[0];
        if( (int)firstLine.size() > 0)
        {
            return true;
        }
    }
    return false;
}

bool GPE_TextAreaInputBasic::has_selection()
{
    if( selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos )
    {
        return true;
    }
    return false;
}

bool GPE_TextAreaInputBasic::import_text(std::string newFileName)
{
    if( !newFileName.empty() )
    {
        std::ifstream newTxtFile( newFileName.c_str() );
        //If the level file could be loaded
        if( !newTxtFile.fail() )
        {
            //makes sure the file is open
            if (newTxtFile.is_open())
            {
                std::string currLine = "";
                clear_all_lines();
                while ( newTxtFile.good() )
                {
                    getline (newTxtFile,currLine); //gets the next line of the file
                    currLine = trim_right_inplace(currLine);
                    currLine = string_replace_all(currLine,"\t","   ");
                    if(!currLine.empty() )
                    {
                        listOfStrings.push_back(currLine);
                    }
                    else
                    {
                        listOfStrings.push_back("");
                    }
                }
                newTxtFile.close();
                save_edit();
                return true;
            }
        }
    }
    return false;
}

void GPE_TextAreaInputBasic::init_save_history()
{
    GPE_TextAreaInputBasic * tempText;
    for( int iD = (int)savedHistory.size()-1; iD >=0; iD--)
    {
        tempText = savedHistory.at(iD);
        if( tempText!=NULL)
        {
            delete tempText;
            tempText = NULL;
        }
    }
    savedHistory.clear();
    currentPositionInHistory = 0;
    save_edit();
}

bool GPE_TextAreaInputBasic::is_read_only()
{
    return isReadOnly;
}

void GPE_TextAreaInputBasic::log_editable_action()
{
    if( undoableActionOccurred==false)
    {
        time(&lastUndoableActionTime);
        undoableActionOccurred = true;
    }
}

void GPE_TextAreaInputBasic::move_down(int yToMove )
{
    if( yToMove > 0)
    {
        lineStartYPos+=yToMove;
        if( lineStartYPos > (int)listOfStrings.size()-linesWithinView )
        {
            lineStartYPos = (int)listOfStrings.size()-linesWithinView;
        }
        find_documentation_description();
    }
}

void GPE_TextAreaInputBasic::move_up(int yToMove )
{
    if( yToMove > 0)
    {
        lineStartYPos-=yToMove;
        if( lineStartYPos < 0)
        {
            lineStartYPos = 0;
        }
        find_documentation_description();
    }
}

void GPE_TextAreaInputBasic::move_right(int xToMove )
{
    if( xToMove > 0)
    {
        lineStartXPos+=xToMove;
        if( lineStartXPos >= get_most_characters_used()-charactersWithinView )
        {
            lineStartXPos = get_most_characters_used()-charactersWithinView;
        }
        find_documentation_description();
    }
}

void GPE_TextAreaInputBasic::move_left(int xToMove )
{
    if( xToMove > 0)
    {
        lineStartXPos-=xToMove;
        if( lineStartXPos < 0 )
        {
            lineStartXPos = 0;
        }
        find_documentation_description();
    }
}

void GPE_TextAreaInputBasic::paste_clipboard()
{
    if(!isReadOnly)
    {
        std::string clipboardStr = SDL_GetClipboardText();
        if( clipboardStr.size() > 0)
        {
            clipboardStr = string_replace_all(clipboardStr,"\r\n","\n");
            clipboardStr = string_replace_all(clipboardStr,"\r","\n");
            clipboardStr = string_replace_all(clipboardStr,"\t","    ");
            if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
            {
                lineToEdit = listOfStrings[cursorYPos];
                if( cursorXPos >(int)lineToEdit.size() )
                {
                    cursorXPos = (int)lineToEdit.size() - 1;
                }
                if( cursorXPos < 0)
                {
                    cursorXPos = 0;
                }
                int newLinePos=clipboardStr.find_first_of("\n");
                if(newLinePos!=(int)std::string::npos)
                {
                    std::string cbNLString = split_first_string(clipboardStr,'\n');
                    if( (int)lineToEdit.size() >= cursorXPos)
                    {
                        textInputString = get_substring(lineToEdit,0,cursorXPos);
                    }
                    else
                    {
                        textInputString= "";
                    }
                    textInputString+=cbNLString;
                    std::string remainerOfStr="";
                    if( (int)lineToEdit.size() > cursorXPos )
                    {
                        remainerOfStr = get_substring(lineToEdit,cursorXPos);
                    }
                    listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                    listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                    cursorYPos+=1;
                    newLinePos=clipboardStr.find_first_of('\n');
                    while (newLinePos!=(int)std::string::npos)
                    {
                        cbNLString = split_first_string(clipboardStr,'\n');
                        listOfStrings.insert(listOfStrings.begin()+cursorYPos,cbNLString);
                        newLinePos=clipboardStr.find_first_of("\n");
                        cursorYPos+=1;
                    }
                    textInputString = clipboardStr;
                    textInputString+=remainerOfStr;
                    listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                    cursorXPos=(int)clipboardStr.size();
                }
                else
                {
                    if( (int)lineToEdit.size() >= cursorXPos)
                    {
                        textInputString = get_substring(lineToEdit,0,cursorXPos);
                    }
                    else
                    {
                        textInputString = "";
                    }
                    textInputString+=clipboardStr;
                    if( (int)lineToEdit.size() >= cursorXPos)
                    {
                        textInputString+=get_substring(lineToEdit,cursorXPos);
                    }
                    cursorXPos+=(int)clipboardStr.size();
                    listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                    listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                }
                save_edit();
            }
        }
    }
}

bool GPE_TextAreaInputBasic::parse_code_javascript()
{
    //resets symbol information
    missingSymbolDetected = false;


    if( has_content() )
    {
        foundSynthaxErrors.clear();
        missingSymbolStartXPos = 0;
        missingSymbolStartYPos = 0;
        misingSymbolSuggestedEndYPos = 0;
        misingSymbolSuggestedEndXPos = 0;

        int i = 0;
        std::string currStringToRender = "";
        std::string currentLineInView = "";

        int tempSynStringSize = 0;
        int currPosToParse = 0, lineEnd = 0;
        bool isInBlockCommentMode = false;
        bool isInDoubleQuoteMode = false;
        bool isInSingleQuoteMode = false;
        int maxLine = (int)listOfStrings.size();
        int endBlockCommentPos = 0;
        int endDQuoteCommentPos = 0;
        int endSQuoteCommentPos = 0;
        bool commentFoundInSymbols = false;
        int openBracesCount = 0;
        int openBracketsCount = 0;
        int openParenthesisCount = 0;
        for( i=0; i < maxLine; i++)
        {
            currStringToRender = listOfStrings[i];
            currPosToParse = 0;
            openParenthesisCount = 0;
            lineEnd = (int)currStringToRender.size();

            endBlockCommentPos=(int)std::string::npos;
            endDQuoteCommentPos=(int)std::string::npos;
            endSQuoteCommentPos=(int)std::string::npos;
            while (currPosToParse < lineEnd)
            {
                if( isInBlockCommentMode)
                {
                    endBlockCommentPos = currStringToRender.find("*/");
                    if( endBlockCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endBlockCommentPos+2;
                        isInBlockCommentMode = false;
                    }
                }
                else if( isInDoubleQuoteMode)
                {
                    endDQuoteCommentPos = currStringToRender.find('"',currPosToParse);
                    if( endDQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endDQuoteCommentPos+1;
                        isInDoubleQuoteMode = false;
                    }
                }
                else if( isInSingleQuoteMode)
                {
                    endSQuoteCommentPos = currStringToRender.find("'",currPosToParse);
                    if( endSQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endSQuoteCommentPos+1;
                        isInSingleQuoteMode = false;
                    }
                }
                else
                {
                    while (currPosToParse < lineEnd && currStringToRender[currPosToParse]==' ')
                    {
                        currPosToParse++;
                    }
                    if (currPosToParse < lineEnd)
                    {
                        if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currPosToParse + 1 < lineEnd && currStringToRender[currPosToParse + 1] == '/' )
                        {
                            currPosToParse = lineEnd;
                        }
                        else if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currStringToRender[currPosToParse + 1] == '*' )
                        {
                            isInBlockCommentMode = true;
                            currPosToParse+=2;
                        }
                        else if(currStringToRender[currPosToParse] == '"')
                        {
                            isInDoubleQuoteMode = true;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '\'')
                        {
                            isInSingleQuoteMode = true;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '(')
                        {
                            openParenthesisCount++;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '[')
                        {
                            openBracesCount++;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '{')
                        {
                            openBracketsCount++;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == ')')
                        {
                            if( isInDoubleQuoteMode==false && isInSingleQuoteMode==false && isInBlockCommentMode==false)
                            {
                                if( openParenthesisCount > 0)
                                {
                                    openParenthesisCount--;
                                }
                                else
                                {
                                    missingSymbolDetected= true;
                                    foundSynthaxErrors.push_back( "Invalid ')' found on line "+int_to_string(i+1)+ " @ "+int_to_string(currPosToParse)+" ParentCount ["+int_to_string(openParenthesisCount)+"].");
                                }
                            }
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == ']')
                        {
                            if( openBracesCount > 0)
                            {
                                openBracesCount--;
                            }
                            else
                            {
                                missingSymbolDetected= true;
                                foundSynthaxErrors.push_back("Invalid ']' found on line "+int_to_string(i+1)+" @ "+int_to_string(currPosToParse)+" BracesCount ["+int_to_string(openBracesCount)+"].");
                            }
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '}')
                        {
                            if( openBracketsCount > 0)
                            {
                                openBracketsCount--;
                            }
                            else
                            {
                                missingSymbolDetected= true;
                                foundSynthaxErrors.push_back("Invalid '}' found on line "+int_to_string(i+1)+" @ "+int_to_string(currPosToParse)+" BracketsCount ["+int_to_string(openBracketsCount)+"].");
                            }
                            currPosToParse++;
                        }
                        else if (isdigit(currStringToRender[currPosToParse]) )
                        {
                            currPosToParse++;
                            while( (currPosToParse < lineEnd && isdigit( currStringToRender[currPosToParse] )  ) || currStringToRender[currPosToParse] ==' ')
                            {
                                currPosToParse++;
                            }
                        }
                        /*
                        else if ( GPE_MINI_COMPILER->charIsSymbol(currStringToRender[currPosToParse]) )
                        {
                            commentFoundInSymbols = false;
                            while( ( commentFoundInSymbols==false && currPosToParse < lineEnd && GPE_MINI_COMPILER->charIsSymbol(currStringToRender[currPosToParse] ) )|| currStringToRender[currPosToParse] ==' ')
                            {
                                if( lineEnd > currPosToParse+1)
                                {
                                    if( currStringToRender[currPosToParse] == '/' && (currStringToRender[currPosToParse + 1] == '/' || currStringToRender[currPosToParse + 1] == '*' ) )
                                    {
                                        commentFoundInSymbols = true;
                                    }
                                    else if (currStringToRender[currPosToParse] == '*' && currStringToRender[currPosToParse + 1] == '/' )
                                    {
                                        commentFoundInSymbols = true;
                                    }
                                    else
                                    {
                                        currPosToParse++;
                                    }
                                }
                                else
                                {
                                    currPosToParse++;
                                }
                            }
                            currPosToParse++;
                        }
                        */
                        else if (char_is_alpha(currStringToRender[currPosToParse],true,true) )
                        {
                            //color = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;
                            currPosToParse++;
                            while (currPosToParse < lineEnd && char_is_alnum(currStringToRender[currPosToParse],true,true) )
                            {
                                currPosToParse++;
                            }
                        }
                        else
                        {
                            //color = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;
                            //anything else is just regular text as well...
                            currPosToParse++;
                        }
                    }
                }
            }
        }

        if( isInBlockCommentMode)
        {
            missingSymbolDetected = true;
            foundSynthaxErrors.push_back( "Missing Symbol: [*/] - End Block Comment" );
        }
        else if( isInDoubleQuoteMode)
        {
            missingSymbolDetected = true;
            foundSynthaxErrors.push_back("\"/ - End Quote" );
        }
        else if( isInSingleQuoteMode)
        {
            missingSymbolDetected = true;
            foundSynthaxErrors.push_back( "' - End Single Quote" );
        }
    }
    return !missingSymbolDetected;
}

void GPE_TextAreaInputBasic::process_self(SDL_Rect * viewedSpace, SDL_Rect * cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    hasScrollControl = false;
    prevCursorXPos = cursorXPos;
    prevCursorYPos = cursorYPos;
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( clickedOutside)
    {
        hasArrowkeyControl = false;
        hasScrollControl = false;
    }
    else if( isClicked)
    {
        hasArrowkeyControl = true;
        hasScrollControl = true;
    }
    if( (int)listOfStrings.size()==0)
    {
        listOfStrings.push_back("");
        reset_self();
    }

    bool pasteCommandGiven = false;
    bool mouseHoveringInTextArea = false;
    if( textEditorButtonBar!=NULL )
    {
        if( !isReadOnly )
        {
            textEditorButtonBar->set_coords(barBox.x,barBox.y);
            //sets the buttonbar to the width of the text editor( minus width of yScroll width[16 ).
            textEditorButtonBar->set_width(barBox.w);
            textEditorButtonBar->set_height(32);
            textEditorButtonBar->process_self(viewedSpace,cam);

            if( textEditorButtonBar->selectedOption>= 0 && textEditorButtonBar->selectedOption < TEXTAREkb_aTONkb_OPTION_MAX_OPTIONS)
            {
                if( textEditorButtonBar->selectedOption==TEXTAREkb_aTONkb_OPTION_IMPORT)
                {
                    std::string importTextFileName = GPE_GetOpenFileName("Import Text","",GPE_MAIN_GUI->fileOpenTextFileDir);
                    if( (int)importTextFileName.size() > 0)
                    {
                        //if( display_get_prompt("Warning!","Clearing this text area is irreversible. Are you sure you want to continue this operation?")==DISPLAY_QUERY_YES )
                        {
                            import_text( importTextFileName);
                        }
                    }
                }
                else if(textEditorButtonBar->selectedOption ==TEXTAREkb_aTONkb_OPTION_REDO)
                {
                    if( can_redo() )
                    {
                        redo_edit();
                    }
                }
                else if(textEditorButtonBar->selectedOption ==TEXTAREkb_aTONkb_OPTION_UNDO)
                {
                    if( can_undo() )
                    {
                        undo_edit();
                    }
                }
                else if( textEditorButtonBar->selectedOption==TEXTAREkb_aTONkb_OPTION_EXPORT)
                {
                    std::string exportTextFileName = GPE_GetSaveFileName("Export Text","",GPE_MAIN_GUI->fileOpenFunctionDir);
                    if( file_exists(exportTextFileName) )
                    {
                        if( display_get_prompt("Warning!","File Exists already, do you wish to overwrite it?)")==DISPLAY_QUERY_YES )
                        {
                            export_text( exportTextFileName);
                        }
                    }
                    else
                    {
                        export_text( exportTextFileName);
                    }
                }
                else if( textEditorButtonBar->selectedOption==TEXTAREkb_aTONkb_OPTION_CLEAR)
                {
                    if( display_get_prompt("Warning!","Are you sure you want to continue this operation?")==DISPLAY_QUERY_YES )
                    {
                        clear_all_lines();
                        listOfStrings.push_back("");
                        save_edit();
                    }
                }
                else if( textEditorButtonBar->selectedOption==TEXTAREkb_aTONkb_OPTION_COPY)
                {
                    copy_selection();
                }
                else if( textEditorButtonBar->selectedOption==TEXTAREkb_aTONkb_OPTION_CUT)
                {
                    cut_selection();
                }
                else if( textEditorButtonBar->selectedOption==TEXTAREkb_aTONkb_OPTION_PASTE)
                {
                    pasteCommandGiven = true;
                }
            }
        }

        if( !textEditorButtonBar->is_clicked() && (int)listOfStrings.size() >0 )
        {
            textInputString = "";
            showXScroll = false;
            showYScroll = false;
            cursorTimer+=1;

            if( cursorTimer > 15*FPS_RATIO )
            {
                showCursor = true;
            }
            if( cursorTimer > 30*FPS_RATIO )
            {
                showCursor = false;
                cursorTimer = 0;
            }
            if( isClicked)
            {
                isInUse = true;
                //inputFieldPos = 0;
                userInput->inkeys = "";
            }
            if( clickedOutside )
            {
                isInUse = false;
            }
            if( GPE_MAIN_GUI->showTextEditorLineCount && isReadOnly==false )
            {
                lineCountBoxWidth = GPE_MAIN_GUI->defaultLineCountWidth;
            }
            else
            {
                lineCountBoxWidth = 0;
            }
            if( textEditorButtonBar!=NULL)
            {
                textEditorButtonBar->set_coords(barBox.x,barBox.y);
                //sets the buttonbar to the width of the text editor( minus width of yScroll width[16 ).
                textEditorButtonBar->set_width(barBox.w);
                if( !isReadOnly)
                {
                    textEditorButtonBar->set_height(32);
                    textEditorButtonBar->enable_self();
                }
                else
                {
                    textEditorButtonBar->set_height(0);
                    textEditorButtonBar->disable_self();
                }

                renderBox.x = barBox.x+lineCountBoxWidth;
                renderBox.y = textEditorButtonBar->get_y2pos();
            }

            renderBox.w = barBox.w-lineCountBoxWidth;
            renderBox.h = get_renderbox_height();


            charactersWithinView = (renderBox.w/TEXTBOX_FONT_SIZE_WIDTH)-2;
            linesWithinView =( renderBox.h/GPE_AVERAGE_LINE_HEIGHT);


            if( linesWithinView < (int)listOfStrings.size() )
            {
                showYScroll = true;
            }
            if( textXScroll!=NULL)
            {
                if( charactersWithinView < get_most_characters_used() )
                {
                    showXScroll = true;
                    if( linesWithinView>1)
                    {
                        linesWithinView-=1;
                    }
                    //int prevYPos = lineStartYPos;
                    textXScroll->barBox.x = renderBox.x;
                    textXScroll->barBox.y = renderBox.y+renderBox.h-16;
                    textXScroll->barBox.w = barBox.w-lineCountBoxWidth;
                    textXScroll->barBox.h = 16;
                    textXScroll->fullRect.x = 0;
                    textXScroll->fullRect.y = 0;
                    textXScroll->fullRect.w = get_most_characters_used();
                    textXScroll->fullRect.h = renderBox.h;
                    if(showYScroll)
                    {
                        textXScroll->barBox.w-=textYScroll->barBox.w;
                        charactersWithinView-=1;
                    }

                    textXScroll->contextRect.x = lineStartXPos;
                    textXScroll->contextRect.y = 0;
                    textXScroll->contextRect.w = charactersWithinView;
                    textXScroll->contextRect.h = renderBox.h;

                    textXScroll->process_self(viewedSpace,cam,true );
                    if( textXScroll->has_moved() || textXScroll->is_scrolling() )
                    {
                        lineStartXPos = get_most_characters_used() * ( (float)textXScroll->scrollXPos/(float)textXScroll->barBox.w );
                    }
                }
                else
                {
                    lineStartXPos = 0;
                    textXScroll->reset_scroller();
                }
            }
            if( textYScroll!=NULL)
            {
                if( showYScroll )
                {
                    //int prevYPos = lineStartYPos;
                    textYScroll->barBox.x = barBox.x+barBox.w-16;
                    textYScroll->barBox.y = textEditorButtonBar->get_y2pos();
                    textYScroll->barBox.w = 16;
                    textYScroll->barBox.h = barBox.h-textEditorButtonBar->get_height();

                    textYScroll->fullRect.x = 0;
                    textYScroll->fullRect.y = 0;
                    textYScroll->fullRect.w = renderBox.w;
                    textYScroll->fullRect.h = (int)listOfStrings.size();
                    textYScroll->contextRect.x = 0;
                    textYScroll->contextRect.y = lineStartYPos;
                    textYScroll->contextRect.w = renderBox.w;
                    textYScroll->contextRect.h = linesWithinView;
                    if(showXScroll)
                    {
                        textYScroll->barBox.h-=textXScroll->barBox.h;
                        //textYScroll->contextRect.h-=1;
                    }
                    textYScroll->process_self(viewedSpace,cam,true );
                    if( textYScroll->has_moved() )
                    {
                        lineStartYPos =  round ( textYScroll->contextRect.y );
                    //    lineStartYPos =  ceil( ( (float)listOfStrings.size() ) * ( (float)textYScroll->scrollYPos/(float)textYScroll->barBox.h ) );
                    }

                    //updates the buttonbar to appear less awkward
                    textEditorButtonBar->set_width(barBox.w);
                }
                else
                {
                    lineStartYPos = 0;
                    textYScroll->reset_scroller();
                }
            }
            if( lineStartXPos < 0)
            {
                lineStartXPos = 0;
            }
            if( lineStartYPos < 0)
            {
                lineStartYPos = 0;
            }
            //just changes the cursor around if it is in the specific text area
            textSpaceRect.x = renderBox.x+1;
            textSpaceRect.y = renderBox.y+1;
            textSpaceRect.w = renderBox.w;
            textSpaceRect.h = renderBox.h;

            if( GPE_MAIN_GUI->showTextEditorLineCount)
            {
                if(showYScroll)
                {
                    if(showXScroll)
                    {
                        textSpaceRect.x = renderBox.x;
                        textSpaceRect.y = renderBox.y;
                        textSpaceRect.w = barBox.w-lineCountBoxWidth-16;
                        textSpaceRect.h = renderBox.h-16;
                    }
                    else
                    {
                        textSpaceRect.x = renderBox.x;
                        textSpaceRect.y = renderBox.y;
                        textSpaceRect.w = barBox.w-lineCountBoxWidth-16;
                        textSpaceRect.h = renderBox.h;
                    }
                }
                else if(showXScroll)
                {
                    textSpaceRect.x = renderBox.x;
                    textSpaceRect.y = renderBox.y;
                    textSpaceRect.w = barBox.w-lineCountBoxWidth;
                    textSpaceRect.h = renderBox.h-16;
                }
                else
                {
                    textSpaceRect.x = renderBox.x;
                    textSpaceRect.y = renderBox.y;
                    textSpaceRect.w = barBox.w-lineCountBoxWidth;
                    textSpaceRect.h = renderBox.h;
                }
            }
            else if(showYScroll)
            {
                if( showXScroll)
                {
                    textSpaceRect.x = renderBox.x;
                    textSpaceRect.y = renderBox.y;
                    textSpaceRect.w = renderBox.w-16;
                    textSpaceRect.h = renderBox.h-16;
                }
                else
                {
                    textSpaceRect.x = renderBox.x;
                    textSpaceRect.y = renderBox.y;
                    textSpaceRect.w = renderBox.w-16;
                    textSpaceRect.h = renderBox.h;
                }
            }
            else if ( showXScroll)
            {
                textSpaceRect.x = renderBox.x;
                textSpaceRect.y = renderBox.y;
                textSpaceRect.w = renderBox.w;
                textSpaceRect.h = renderBox.h-16;
            }

            textSpaceRect.x = renderBox.x+viewedSpace->x-cam->x;
            textSpaceRect.y = renderBox.y+viewedSpace->y-cam->y;

            if( isHovered && (showXScroll || showYScroll ) )
            {
                hasScrollControl = true;
            }
            if( isInUse && isEnabled && cam!=NULL && textEditorButtonBar!=NULL)
            {
                if( point_within_rect(userInput->mouse_x,userInput->mouse_y,&textSpaceRect)  )
                {
                    mouseHoveringInTextArea = true;
                    GPE_change_cursor(SDL_SYSTEM_CURSOR_IBEAM);
                }
                if( mouseHoveringInTextArea && textXScroll->is_scrolling()==false && textYScroll->is_scrolling()==false )
                {
                    if( userInput->check_mouse_down(0) )
                    {
                        update_cursor_to_mouse(viewedSpace, cam);
                        if( lineStartXPos < 0)
                        {
                            lineStartXPos = 0;
                        }
                        if( lineStartYPos < 0)
                        {
                            lineStartYPos = 0;
                        }
                    }
                    //Handles the Mouse movements & buttons
                    if( userInput->check_mouse_doubleclicked(0) && RESOURCE_TO_DRAG==NULL )
                    {
                        update_cursor_to_mouse(viewedSpace, cam);
                        if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                        {
                            lineToEdit = listOfStrings[cursorYPos];

                            selectionCursorXPos = selectionEndCursorXPos = cursorXPos;
                            selectionCursorYPos = selectionEndCursorYPos = cursorYPos;
                            if( (int)lineToEdit.size() == 0 )
                            {
                                if( cursorYPos+1 < (int)listOfStrings.size() )
                                {
                                    cursorXPos = 0;
                                    cursorYPos++;
                                    selectionEndCursorYPos = cursorYPos;
                                    selectionCursorXPos = 0;
                                    selectionEndCursorXPos = 0;
                                }
                            }
                            else
                            {
                                int iPrev = cursorXPos;
                                int jNext = cursorXPos;
                                if( lastDoubleClickAction ==0)
                                {
                                    if( cursorXPos>=0 &&  cursorXPos <= (int)lineToEdit.size() )
                                    {
                                        if( lineToEdit[cursorXPos]==' ')
                                        {
                                            for(iPrev = cursorXPos-1; iPrev >=0; iPrev-- )
                                            {
                                                if( lineToEdit[iPrev]==' ')
                                                {
                                                    selectionCursorXPos--;
                                                }
                                                else
                                                {
                                                    break;
                                                }
                                            }
                                            for(jNext = cursorXPos; jNext < (int)lineToEdit.size(); jNext++ )
                                            {
                                                if( lineToEdit[jNext]==' ')
                                                {
                                                    selectionEndCursorXPos++;
                                                }
                                                else
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else if( char_is_alnum( lineToEdit[cursorXPos],false,true) )
                                        {
                                            for(iPrev = cursorXPos-1; iPrev >=0; iPrev-- )
                                            {
                                                if( char_is_alnum( lineToEdit[iPrev],false,true) )
                                                {
                                                    selectionCursorXPos--;
                                                }
                                                else
                                                {
                                                    break;
                                                }
                                            }

                                            for(jNext = cursorXPos; jNext < (int)lineToEdit.size(); jNext++ )
                                            {
                                                if( char_is_alnum( lineToEdit[jNext],false,true) )
                                                {
                                                    selectionEndCursorXPos++;
                                                }
                                                else
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            //for symbols
                                            for(iPrev = cursorXPos-1; iPrev >=0; iPrev-- )
                                            {
                                                if( char_is_alnum( lineToEdit[iPrev],true,true)==false)
                                                {
                                                    selectionCursorXPos--;
                                                }
                                                else
                                                {
                                                    break;
                                                }
                                            }
                                            for(jNext = cursorXPos; jNext < (int)lineToEdit.size(); jNext++ )
                                            {
                                                if( char_is_alnum( lineToEdit[jNext],true,true)==false)
                                                {
                                                    selectionEndCursorXPos++;
                                                }
                                                else
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    lastDoubleClickAction = 1;
                                }
                                else if( (int)lineToEdit.size() > 0 )
                                {
                                    selectionCursorXPos = 0;
                                    selectionEndCursorXPos = (int)lineToEdit.size();
                                    cursorXPos = 0;
                                    lastDoubleClickAction = 0;
                                }
                                else if( cursorYPos+1 < (int)listOfStrings.size() )
                                {
                                    cursorXPos = 0;
                                    cursorYPos++;
                                    selectionEndCursorYPos = cursorYPos;
                                    selectionCursorXPos = 0;
                                    selectionEndCursorXPos = 0;
                                }
                                userInput->reset_all_input();
                                codeBeingSuggested = false;
                                find_documentation_description();
                            }
                        }
                    }
                    else if( userInput->check_mouse_pressed(0) )
                    {
                        //if( lastDoubleClickAction==0)
                        {
                            update_cursor_to_mouse(viewedSpace, cam);
                            if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                            {
                                selectionCursorXPos = selectionEndCursorXPos = cursorXPos;
                                selectionCursorYPos = selectionEndCursorYPos = cursorYPos;
                            }
                        }
                        codeBeingSuggested = false;
                        find_documentation_description();
                    }
                    else if( userInput->check_mouse_down(0) )
                    {
                        //if( lastDoubleClickAction==0)
                        {
                            update_cursor_to_mouse(viewedSpace, cam);
                            if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                            {
                                selectionEndCursorXPos = cursorXPos;
                                selectionEndCursorYPos = cursorYPos;
                            }
                        }
                        codeBeingSuggested = false;
                        find_documentation_description();
                    }
                    else if( userInput->check_mouse_down(1) )
                    {
                        GPE_open_context_menu();
                        MAIN_CONTEXT_MENU->set_width(128);

                        MAIN_CONTEXT_MENU->add_menu_option("Undo",0,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/backward.png"),-1,NULL,true,!isReadOnly && can_undo());
                        MAIN_CONTEXT_MENU->add_menu_option("Redo",1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/forward.png"),-1,NULL,true,!isReadOnly && can_redo() );
                        MAIN_CONTEXT_MENU->add_menu_option("Cut",2,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/cut.png"),-1,NULL,false,!isReadOnly);
                        MAIN_CONTEXT_MENU->add_menu_option("Copy",3,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/copy.png"),-1,NULL,false,true);
                        MAIN_CONTEXT_MENU->add_menu_option("Paste",4,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/paste.png"),-1,NULL,false,!isReadOnly);
                        MAIN_CONTEXT_MENU->add_menu_option("Delete",5,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/remove.png"),-1,NULL,true,!isReadOnly);
                        MAIN_CONTEXT_MENU->add_menu_option("Select All",6,rsm->texture_add(APP_DIRECTORY_NAME+"resources/buttons/sticky-note.png"),-1,NULL,true,true);
                        int menuSelection = get_popupmenu_result();

                        if( menuSelection==0)
                        {
                            if( can_undo() && !isReadOnly )
                            {
                                undo_edit();
                            }
                        }
                        else if( menuSelection==1 && !isReadOnly )
                        {
                            if( can_redo() )
                            {
                                redo_edit();
                            }
                        }
                        if( menuSelection==6)
                        {
                            select_all();
                        }
                        else
                        {
                            switch(menuSelection)
                            {
                                case 2:
                                    cut_selection();
                                break;
                                case 3:
                                    copy_selection();
                                break;
                                case 4:
                                    pasteCommandGiven = true;
                                break;
                                case 5:
                                    delete_selection();
                                break;
                                default:
                                break;
                            }
                            reset_selection();
                        }
                        lastDoubleClickAction = 0;
                        highlightedTerm = NULL;
                    }
                    else if( userInput->mouseMovementInputReceivedInFrame && RESOURCE_TO_DRAG==NULL )
                    {
                        //Highlights documenation under mouse if found.
                        int tMouseX = 0, tMouseY = 0;
                        find_mouse_cursor(&tMouseX,&tMouseY, viewedSpace, cam);
                        if( tMouseX!=highlightXPos || tMouseY!=highlightYPos)
                        {
                            find_documentation_description(tMouseX,tMouseY);
                        }
                    }
                    else if( RESOURCE_TO_DRAG!=NULL && !isReadOnly )
                    {
                        if( userInput->check_mouse_released(0) )
                        {
                            if( point_within_rect(userInput->mouse_x,userInput->mouse_y,&textSpaceRect)  )
                            {
                                mouseHoveringInTextArea = true;
                                GPE_change_cursor(SDL_SYSTEM_CURSOR_IBEAM);

                                update_cursor_to_mouse(viewedSpace, cam);
                                if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                                {
                                    if( cursorXPos >=0 && cursorXPos <= (int)listOfStrings[cursorYPos].size() )
                                    {

                                        listOfStrings[cursorYPos] = get_substring(listOfStrings[cursorYPos],0,cursorXPos)+RESOURCE_TO_DRAG->get_name()+get_substring(listOfStrings[cursorYPos],cursorXPos);
                                        RESOURCE_TO_DRAG = NULL;
                                    }
                                }
                            }
                            else
                            {
                                record_error("Unable to drag resource into textArea...");
                            }
                        }
                    }
                }
                else if( userInput->check_mouse_down(0) && textXScroll->is_scrolling()==false && textYScroll->is_scrolling()==false )
                {
                    //if( lastDoubleClickAction==0)
                    if( userInput->mouse_x < textSpaceRect.x )
                    {
                        if( cursorXPos > 0)
                        {
                            cursorXPos-=1;
                        }
                        move_left(1);
                    }
                    else if( userInput->mouse_x > textSpaceRect.x+textSpaceRect.w )
                    {
                        lineToEdit = listOfStrings[cursorYPos];
                        if( cursorXPos > (int)lineToEdit.size()-1 )
                        {
                            cursorXPos+=1;
                        }
                        move_right(1);
                    }

                    if( userInput->mouse_y > textSpaceRect.y && userInput->mouse_y < textSpaceRect.y+4 )
                    {
                        if( cursorYPos > 0)
                        {
                            cursorYPos-=1;
                        }
                        move_up(1);
                    }
                    else if( userInput->mouse_y > textSpaceRect.y+textSpaceRect.h-4 )
                    {
                        if( cursorYPos < (int)listOfStrings.size()-1 )
                        {
                            cursorYPos+=1;
                        }
                        move_down(1);
                    }

                    update_cursor_to_mouse(viewedSpace, cam);
                    if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                    {
                        selectionEndCursorXPos = cursorXPos;
                        selectionEndCursorYPos = cursorYPos;
                    }
                    showCursor = false;
                    cursorTimer = 30;
                    codeBeingSuggested = false;
                    find_documentation_description();
                }
            }

            //special control action happening
            if(  GPE_MAIN_GUI->using_search()==false && isInUse && isEnabled && hasArrowkeyControl )
            {
                //used to delay events from happening superfast
                if( userInput->down[kb_backspace] && !userInput->pressed[kb_backspace] )
                {
                    bscDelay +=1;
                }
                else
                {
                    bscDelay = 0;
                }
                if( userInput->down[kb_delete] && !userInput->pressed[kb_delete] )
                {
                    delDelay += 0.5;
                }
                else
                {
                    delDelay = 0;
                }
                if( userInput->down[kb_tab]  && !userInput->pressed[kb_tab])
                {
                    tabDelay += 0.5;
                }
                if(userInput->down[kb_enter] && !userInput->pressed[kb_enter])
                {
                    enterDelay+=0.5;
                }
                else
                {
                    enterDelay = 0;
                }
                if( userInput->down[kb_left] && !userInput->pressed[kb_left] && !userInput->released[kb_left] )
                {
                    leftDelay+=1;
                }
                else
                {
                    leftDelay = 0;
                }

                if( userInput->down[kb_right] && !userInput->pressed[kb_right] && !userInput->released[kb_right] )
                {
                    rightDelay+=1;
                }
                else
                {
                    rightDelay = 0;
                }

                if(userInput->down[kb_up] && !userInput->pressed[kb_up] && !userInput->released[kb_up] )
                {
                    upDelay+=1;
                }
                else
                {
                    upDelay = 0;
                }
                if(userInput->down[kb_down] && !userInput->pressed[kb_down] && !userInput->released[kb_down])
                {
                    downDelay+=0.5;
                }
                else
                {
                    downDelay = 0;
                }

                if(userInput->down[kb_d] && !userInput->pressed[kb_d] && !userInput->released[kb_d])
                {
                    dKeyDelay+=0.5;
                }
                else
                {
                    dKeyDelay = 0;
                }

                if( userInput->down[kb_ctrl]  )
                {
                    highlightedTerm = NULL;
                    if( userInput->released[kb_a])
                    {
                       select_all();
                    }
                    else if( userInput->released[kb_c])
                    {
                         copy_selection();
                    }
                    else if( userInput->released[kb_f] ||  userInput->released[kb_h] )
                    {
                         GPE_MAIN_GUI->findTextStringBox->set_string( get_short_hightlighted() );
                    }
                    else if( dKeyDelay > (GPE_MAIN_GUI->textAreaDelayTime+1)*FPS_RATIO  || ( !userInput->pressed[kb_d] && userInput->released[kb_d] ) )
                    {
                        if( !isReadOnly )
                        {
                            duplicate_text();
                            dKeyDelay = 0;
                        }
                    }
                    else if( userInput->released[kb_v] && !isReadOnly)
                    {
                        pasteCommandGiven = true;
                    }
                    else if( userInput->released[kb_x] && !isReadOnly)
                    {
                         cut_selection();
                         scroll_to_cursor();
                    }
                    else if( userInput->released[kb_y] && !isReadOnly)
                    {
                        if( can_redo() )
                        {
                            redo_edit();
                            userInput->reset_all_input();
                            process_self( viewedSpace,cam );
                        }
                    }
                    else if( userInput->released[kb_z] && !isReadOnly)
                    {
                        if( can_undo() )
                        {
                            undo_edit();
                            userInput->reset_all_input();
                            process_self( viewedSpace,cam );
                        }
                    }
                    else if( upDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*FPS_RATIO  || ( !userInput->pressed[kb_up] && userInput->released[kb_up] ) )
                    {
                        lineStartYPos--;
                        upDelay = 0;
                        showCursor = true;
                        cursorTimer = 0;
                    }
                    else if( downDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*FPS_RATIO  || ( !userInput->pressed[kb_down] && userInput->released[kb_down] ) )
                    {
                        lineStartYPos++;
                        downDelay = 0;
                        showCursor = true;
                        cursorTimer = 0;
                    }
                    else if( leftDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*FPS_RATIO  || ( !userInput->pressed[kb_left] && userInput->released[kb_left] ) )
                    {
                        if( userInput->shiftKeyIsPressed)
                        {
                            if( selectionCursorXPos==selectionEndCursorXPos && selectionCursorYPos==selectionEndCursorYPos )
                            {
                                selectionCursorXPos = cursorXPos;
                                selectionCursorYPos = cursorYPos;
                            }
                        }
                        if( cursorXPos <=0)
                        {
                            if( cursorYPos > 0)
                            {
                                cursorYPos--;
                                cursorXPos = (int)listOfStrings[cursorYPos].size()-1;
                                if( cursorXPos < 0)
                                {
                                    cursorXPos = 0;
                                }
                            }
                        }
                        else if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                        {
                            std::string currentLineToScroll = listOfStrings[cursorYPos];
                            if( cursorXPos >=(int)currentLineToScroll.size() )
                            {
                                cursorXPos = (int)currentLineToScroll.size()-1;
                            }
                            if( cursorXPos < 0)
                            {
                                if( cursorYPos >0 && cursorYPos < (int)listOfStrings.size() )
                                {
                                    cursorYPos--;
                                    cursorXPos = listOfStrings[cursorYPos].size()-1;
                                }
                            }
                            else if( cursorXPos < (int)currentLineToScroll.size() )
                            {
                                int iNCursorX = cursorXPos-1;
                                for( iNCursorX = cursorXPos-1; iNCursorX >=0; iNCursorX--)
                                {
                                    if( char_is_alnum(currentLineToScroll[iNCursorX],false,true)==false )
                                    {
                                        break;
                                    }
                                }
                                if( iNCursorX< 0)
                                {
                                    iNCursorX = 0;
                                }
                                cursorXPos = iNCursorX;
                            }
                            else
                            {
                                cursorXPos = 0;
                            }
                        }
                        scroll_to_cursor();
                        showCursor = true;
                        cursorTimer = 0;
                        if( userInput->shiftKeyIsPressed)
                        {
                            selectionEndCursorXPos = cursorXPos;
                            selectionEndCursorYPos = cursorYPos;
                        }
                        leftDelay = 0;
                    }
                    else if( rightDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*FPS_RATIO  || ( !userInput->pressed[kb_right] && userInput->released[kb_right] ) )
                    {
                        if( userInput->shiftKeyIsPressed)
                        {
                            if( selectionCursorXPos==selectionEndCursorXPos && selectionCursorYPos==selectionEndCursorYPos )
                            {
                                selectionCursorXPos = cursorXPos;
                                selectionCursorYPos = cursorYPos;
                            }
                        }
                        if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                        {
                            std::string currentLineToScroll = listOfStrings[cursorYPos];
                            if( cursorXPos >=(int)currentLineToScroll.size() )
                            {
                                if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size()-1 )
                                {
                                    cursorYPos++;
                                    cursorXPos = 0;
                                }
                            }
                            else if( cursorXPos >= 0 && cursorXPos < (int)currentLineToScroll.size() )
                            {
                                int iNCursorX = cursorXPos+1;
                                for( iNCursorX = cursorXPos+1; iNCursorX <(int)currentLineToScroll.size(); iNCursorX++)
                                {
                                    if( char_is_alnum(currentLineToScroll[iNCursorX],false,true)==false )
                                    {
                                        break;
                                    }
                                }
                                if( iNCursorX >=(int)currentLineToScroll.size() )
                                {
                                    iNCursorX >(int)currentLineToScroll.size()-1;
                                }
                                if( iNCursorX < 0)
                                {
                                    iNCursorX = 0;
                                }
                                cursorXPos = iNCursorX;
                            }
                        }
                        scroll_to_cursor();
                        showCursor = true;
                        cursorTimer = 0;
                        if( userInput->shiftKeyIsPressed)
                        {
                            selectionEndCursorXPos = cursorXPos;
                            selectionEndCursorYPos = cursorYPos;
                        }
                        rightDelay = 0;
                    }
                    codeBeingSuggested = false;
                }
                else
                {
                    dKeyDelay = 0;
                    if( userInput->mouseScrollingUp > 0)
                    {
                        //move_up( linesWithinView/4);
                        highlightedTerm = NULL;
                    }
                    else if( mouseHoveringInTextArea && userInput->mouseScrollingDown > 0)
                    {
                        //move_down( linesWithinView/4);
                        highlightedTerm = NULL;
                    }
                    else if(  (enterDelay > (GPE_MAIN_GUI->textAreaDelayTime+1)*1.3*FPS_RATIO || ( !userInput->pressed[kb_enter] && userInput->released[kb_enter] )  )  && !isReadOnly )
                    {
                        if( codeBeingSuggested )
                        {
                            if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                            {
                                std::string prevStr = listOfStrings[cursorYPos];
                                if( iSuggestionPos >= 0 && iSuggestionPos < (int)suggestedCompilerTerms.size() )
                                {
                                    GPE_Compiler_Term * tempTerm = suggestedCompilerTerms.at(iSuggestionPos);
                                    if( tempTerm!=NULL)
                                    {
                                        if( tempTerm->termType==CTERM_FUNCTION)
                                        {
                                            prevStr = prevStr.substr(0,tempCLineXStartPos)+tempTerm->termString+"()"+prevStr.substr(tempCLineXEndPos+1);
                                            cursorXPos = tempCLineXStartPos + (int)tempTerm->termString.size()+1;
                                        }
                                        else
                                        {
                                            prevStr = prevStr.substr(0,tempCLineXStartPos)+tempTerm->termString+prevStr.substr(tempCLineXEndPos+1);
                                            cursorXPos = tempCLineXStartPos + (int)tempTerm->termString.size();
                                        }
                                        listOfStrings[cursorYPos] = prevStr;
                                    }
                                }
                            }
                            codeBeingSuggested = false;
                            suggestedCompilerTerms.clear();
                            enterDelay = 0;
                            userInput->reset_all_input();
                        }
                        else
                        {
                            log_editable_action();
                            delete_selection();
                            lineToEdit = listOfStrings[cursorYPos];
                            //go to next line
                            std::string nextString = "";
                            if( (int)lineToEdit.size()> 0)
                            {
                                nextString = get_substring(lineToEdit,cursorXPos);
                                lineToEdit = get_substring(lineToEdit,0, cursorXPos);
                            }
                            else
                            {
                                lineToEdit = "";
                                nextString = "";
                            }
                            cursorXPos = 0;
                            if( (int)listOfStrings.size()>0 )
                            {
                                listOfStrings.erase(listOfStrings.begin()+cursorYPos );
                                listOfStrings.insert(listOfStrings.begin()+cursorYPos,lineToEdit);
                                int numbOfSpaces =  get_leading_space_count(lineToEdit);
                                cursorXPos = 0;
                                if( numbOfSpaces > 0)
                                {
                                    for(int i= 0; i < numbOfSpaces; i++)
                                    {
                                        nextString=" "+nextString;
                                    }
                                    cursorXPos = numbOfSpaces;
                                }
                                if( (int)lineToEdit.size()>0)
                                {
                                    std::string lastChar = get_substring(lineToEdit, (int)lineToEdit.size()-1 );
                                    if( lastChar.compare("{" )==0)
                                    {
                                        nextString=generate_tabs(1)+nextString;
                                        cursorXPos+=get_tab_space_count();
                                    }
                                }
                                listOfStrings.insert(listOfStrings.begin()+cursorYPos+1,nextString);
                                userInput->reset_all_input();
                            }
                            else
                            {
                                listOfStrings.push_back(lineToEdit);
                                listOfStrings.push_back(nextString);
                            }
                            if( cursorXPos < 0)
                            {
                                cursorXPos = 0;
                            }
                            cursorYPos+=1;
                            move_down();
                            showCursor = true;
                            cursorTimer = 0;
                            scroll_to_cursor();
                            codeBeingSuggested = false;
                            enterDelay = 0;
                        }
                        highlightedTerm = NULL;
                        enterDelay = 0;
                    }
                    else if( leftDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*1.3*FPS_RATIO  || ( !userInput->released[kb_left] && userInput->pressed[kb_left] ) )
                    {
                        if( userInput->shiftKeyIsPressed )
                        {
                            if( selectionCursorXPos==selectionEndCursorXPos && selectionCursorYPos==selectionEndCursorYPos )
                            {
                                selectionCursorXPos = cursorXPos;
                                selectionCursorYPos = cursorYPos;
                            }
                        }
                        else
                        {
                            reset_selection(-1);
                        }
                        if( cursorXPos > 0)
                        {
                            int tabCharCount = get_tab_space_count();
                            if( (int)lineToEdit.size() >= cursorXPos-tabCharCount )
							{
							    bool hasLeadingTabs = true;
							    for( int iCharPos = std::min( cursorXPos-1, (int)lineToEdit.size()-1 ); iCharPos >=0 && iCharPos >=cursorXPos-tabCharCount; iCharPos-- )
                                {
                                    if( lineToEdit[iCharPos]!=' ')
                                    {
                                        hasLeadingTabs = false;
                                    }
                                }
                                if( hasLeadingTabs)
                                {
                                    cursorXPos-=tabCharCount;
                                }
                                else
                                {
                                    cursorXPos-=1;
                                }
                            }
                            else
                            {
                                cursorXPos-=1;
                            }
                            //adjust_fortabs();
                        }
                        else if( cursorYPos > 0 )
                        {
                            cursorYPos-=1;
                            move_up();
                            std::string prevString = listOfStrings[cursorYPos];
                            cursorXPos = prevString.size();
                            if( cursorXPos < 0)
                            {
                                cursorXPos = 0;
                            }
                            adjust_fortabs();
                        }
                        if( userInput->shiftKeyIsPressed)
                        {
                            selectionEndCursorXPos = cursorXPos;
                            selectionEndCursorYPos = cursorYPos;
                        }
                        leftDelay = 0;
                        scroll_to_cursor();
                        codeBeingSuggested = false;
                        find_documentation_description();
                    }
                    else if( rightDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*1.3*FPS_RATIO  || ( !userInput->released[kb_right] && userInput->pressed[kb_right] ))
                    {
                        lineToEdit = listOfStrings[cursorYPos];
                        if( userInput->shiftKeyIsPressed)
                        {
                            if( selectionCursorXPos==selectionEndCursorXPos && selectionCursorYPos==selectionEndCursorYPos )
                            {
                                selectionCursorXPos = cursorXPos;
                                selectionCursorYPos = cursorYPos;
                            }
                        }
                        else
                        {
                            reset_selection(1);
                        }
                        //special shift action
                        cursorXPos+=1;
                        if( cursorXPos > (int)lineToEdit.size() )
                        {
                            //go to next line if available
                            if(cursorYPos < (int) listOfStrings.size()-1 )
                            {
                                cursorXPos = 0;
                                cursorYPos+=1;
                                move_down();
                            }
                            else
                            {
                                cursorXPos = (int)lineToEdit.size();
                            }
                        }
                        else
                        {
                            //adjust_fortabs();
                        }
                        if( userInput->shiftKeyIsPressed)
                        {
                            selectionEndCursorXPos = cursorXPos;
                            selectionEndCursorYPos = cursorYPos;
                        }
                        rightDelay = 0;
                        showCursor = true;
                        cursorTimer = 0;
                        scroll_to_cursor();
                        codeBeingSuggested = false;
                        find_documentation_description();
                    }
                    else if( upDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*2*FPS_RATIO  || ( !userInput->released[kb_up] && userInput->pressed[kb_up] ) )
                    {
                        highlightedTerm = NULL;
                        if( codeBeingSuggested )
                        {
                            if( iSuggestionPos > 0)
                            {
                                iSuggestionPos--;
                                if( iSuggestionPos < iSuggestedStartPos)
                                {
                                    iSuggestedStartPos = iSuggestionPos;
                                }
                            }
                            upDelay = -1;
                        }
                        else
                        {
                            if( userInput->shiftKeyIsPressed)
                            {
                                if( selectionCursorXPos==selectionEndCursorXPos && selectionCursorYPos==selectionEndCursorYPos )
                                {
                                    selectionCursorXPos = cursorXPos;
                                    selectionCursorYPos = cursorYPos;
                                }
                            }
                            else
                            {
                                reset_selection(-1);
                            }
                            //special shift action
                            if( cursorYPos>0)
                            {
                                cursorYPos-=1;
                                if( lineStartYPos==cursorYPos+1)
                                {
                                    move_up();
                                }
                                else if( cursorYPos < lineStartYPos || cursorYPos > lineStartYPos+linesWithinView)
                                {
                                    lineStartYPos = cursorYPos;
                                }
                                std::string prevLine = listOfStrings[cursorYPos];
                                if( cursorXPos >= (int)prevLine.size() )
                                {
                                    cursorXPos = (int)prevLine.size()-1;
                                    if( cursorXPos<0)
                                    {
                                        cursorXPos = 0;
                                    }
                                }
                            }
                            if( userInput->shiftKeyIsPressed)
                            {
                                selectionEndCursorXPos = cursorXPos;
                                selectionEndCursorYPos = cursorYPos;
                            }
                            upDelay = 0;
                            showCursor = true;
                            cursorTimer = 0;
                            adjust_fortabs();
                            scroll_to_cursor();
                            find_documentation_description();
                        }
                    }
                    else if( downDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*2*FPS_RATIO  || ( !userInput->released[kb_down] && userInput->pressed[kb_down] ) )
                    {
                        highlightedTerm = NULL;
                        if( codeBeingSuggested )
                        {
                            if( iSuggestionPos < (int)suggestedCompilerTerms.size()-1 )
                            {
                                iSuggestionPos++;
                                if( iSuggestionPos >= iSuggestedStartPos+suggestedTextMaxInViewCount)
                                {
                                    iSuggestedStartPos = iSuggestionPos;
                                    if( iSuggestedStartPos+suggestedTextMaxInViewCount >=(int)suggestedCompilerTerms.size() )
                                    {
                                        iSuggestedStartPos = (int)suggestedCompilerTerms.size() -  suggestedTextMaxInViewCount;
                                    }
                                    if( iSuggestedStartPos < 0)
                                    {
                                        iSuggestedStartPos = 0;
                                    }
                                }
                            }
                            downDelay = -1;
                        }
                        else
                        {
                            if( userInput->shiftKeyIsPressed)
                            {
                                if( selectionCursorXPos==selectionEndCursorXPos && selectionCursorYPos==selectionEndCursorYPos )
                                {
                                    selectionCursorXPos = cursorXPos;
                                    selectionCursorYPos = cursorYPos;
                                }
                            }
                            else
                            {
                                reset_selection(1);
                            }
                            //special shift action
                            if( cursorYPos < (int)listOfStrings.size()-1 )
                            {
                                cursorYPos+=1;
                                if( lineStartYPos>=cursorYPos+linesWithinView-1)
                                {
                                    move_down();
                                }
                                else if( cursorYPos < lineStartYPos || cursorYPos > lineStartYPos+linesWithinView)
                                {
                                    lineStartYPos = cursorYPos;
                                }
                                std::string nextLine = listOfStrings[cursorYPos];
                                if( cursorXPos >= (int)nextLine.size() )
                                    {
                                        cursorXPos = (int)nextLine.size()-1;
                                        if( cursorXPos<0)
                                        {
                                            cursorXPos = 0;
                                        }
                                    }
                                }
                                if( userInput->shiftKeyIsPressed)
                                {
                                    selectionEndCursorXPos = cursorXPos;
                                    selectionEndCursorYPos = cursorYPos;
                                }
                                downDelay = 0;
                                showCursor = true;
                                cursorTimer = 0;
                                adjust_fortabs();
                                scroll_to_cursor();
                                find_documentation_description();
                            }
                    }
                    else if( bscDelay > (GPE_MAIN_GUI->textAreaDelayTime+1)*2*FPS_RATIO || ( userInput->pressed[kb_backspace] && !userInput->released[kb_backspace] ) )
                    {
                        bscDelay = 0;
                        if( !isReadOnly)
                        {
                            bscDelay = 0;
                            if( selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos)
                            {
                                delete_selection();
                            }
                            else if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                            {
                                lineToEdit = listOfStrings[cursorYPos];
                                int prevSize = (int)lineToEdit.size();
                                if( prevSize>0)
                                {
                                    if( cursorXPos > prevSize )
                                    {
                                        cursorXPos = prevSize;
                                    }
                                }
                                else
                                {
                                    cursorXPos = 0;
                                }
                                if( cursorXPos>0 && cursorXPos <= (int)lineToEdit.size() )
                                {
                                    textInputString = get_substring(lineToEdit,0,cursorXPos);
                                    std::string rightSide = get_substring(lineToEdit,cursorXPos);
                                    if( cursorXPos >= (int)lineToEdit.size() )
                                    {
                                        textInputString = get_substring(lineToEdit,0);
                                        rightSide = "";
                                    }
                                    int trailingSpaces = get_trailing_space_count(textInputString);
                                    int tabsToCheckCount = get_tab_space_count();
                                    if( trailingSpaces >= tabsToCheckCount )
                                    {
                                        cursorXPos -= tabsToCheckCount;
                                        textInputString = get_substring(textInputString,0,cursorXPos);
                                    }
                                    else
                                    {
                                        cursorXPos -=1;
                                        textInputString = get_substring(textInputString,0,cursorXPos);
                                    }

                                    textInputString+=rightSide;
                                    listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                                    if( cursorYPos>=0)
                                    {
                                        listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                                    }
                                    else
                                    {
                                        listOfStrings.push_back(textInputString);
                                    }
                                    log_editable_action();
                                }
                                else if( cursorYPos>=1)
                                {
                                    log_editable_action();
                                    textInputString = lineToEdit;
                                    std::string prevString = listOfStrings.at(cursorYPos-1);
                                    cursorXPos = prevString.size();
                                    listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                                    cursorYPos -=1;
                                    if( cursorYPos < lineStartYPos && cursorYPos>=0)
                                    {
                                        lineStartYPos-=1;
                                    }
                                    textInputString = listOfStrings[cursorYPos]+lineToEdit;
                                    listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                                    listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                                    log_editable_action();
                                }
                            }
                            bscDelay = 0;
                            showCursor = true;
                            cursorTimer = 0;
                            scroll_to_cursor();
                        }
                        codeBeingSuggested = false;
                        highlightedTerm = NULL;

                    }
                    else if( delDelay >= (GPE_MAIN_GUI->textAreaDelayTime+1)*2*FPS_RATIO  || ( userInput->pressed[kb_delete] && !userInput->released[kb_delete] ) )
                    {
                        delDelay = 0;
                        if(!isReadOnly)
                        {
                            log_editable_action();
                            if( selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos)
                            {
                                delete_selection();
                            }
                            else if( cursorYPos >=0 && cursorYPos < (int)listOfStrings.size() )
                            {
                                lineToEdit = listOfStrings[cursorYPos];
                                int prevSize = (int)lineToEdit.size();
                                if( prevSize>0)
                                {
                                    if( cursorXPos > prevSize )
                                    {
                                        cursorXPos = prevSize;
                                    }
                                }
                                else
                                {
                                    cursorXPos = 0;
                                }
                                if( cursorXPos>=0 && cursorXPos < (int)lineToEdit.size() )
                                {
                                    textInputString = get_substring(lineToEdit,0,cursorXPos);
                                    std::string rightSide = get_substring(lineToEdit,cursorXPos+1);
                                    if( cursorXPos >= (int)lineToEdit.size() )
                                    {
                                        textInputString = get_substring(lineToEdit,0);
                                        rightSide = "";
                                    }

                                    textInputString+=rightSide;
                                    listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                                    if( cursorYPos>=0)
                                    {
                                        listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                                    }
                                    else
                                    {
                                        listOfStrings.push_back(textInputString);
                                    }
                                    log_editable_action();
                                }
                                else if( cursorYPos>=0 && cursorXPos>=(int)lineToEdit.size() && cursorYPos < (int)listOfStrings.size()-1 )
                                {
                                    log_editable_action();
                                    textInputString = lineToEdit;
                                    std::string prevString = listOfStrings.at(cursorYPos+1);
                                    cursorXPos = lineToEdit.size();
                                    textInputString = lineToEdit+prevString;
                                    listOfStrings.erase(listOfStrings.begin()+cursorYPos+1);
                                    listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                                    listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                                    log_editable_action();
                                }
                            }
                            delDelay = 0;
                            showCursor = true;
                            cursorTimer = 0;
                            scroll_to_cursor();
                        }
                        codeBeingSuggested = false;
                        highlightedTerm = NULL;

                    }
                    else if( tabDelay > (GPE_MAIN_GUI->normalInputDelayTime+1)*2*FPS_RATIO || ( !userInput->pressed[kb_tab] && userInput->released[kb_tab] ) )
                    {
                        tabDelay = 0;
                        if( !isReadOnly)
                        {
                            int tabStartYPos = 0;
                            int tabEndYPos = 0;
                            if( selectionCursorYPos>selectionEndCursorYPos)
                            {
                                tabEndYPos = selectionCursorYPos;
                                tabStartYPos = selectionEndCursorYPos;
                            }
                            else
                            {
                                tabStartYPos = selectionCursorYPos;
                                tabEndYPos = selectionEndCursorYPos;
                            }

                            int tabCharCount = get_tab_space_count();
                            if( userInput->shiftKeyIsPressed)
                            {
                                std::string strToUnTab = "";
                                if( selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos )
                                {
                                    for( int iTabPos = tabStartYPos; iTabPos <= tabEndYPos; iTabPos++)
                                    {
                                        strToUnTab = listOfStrings[iTabPos];
                                        if( has_early_tab(strToUnTab) )
                                        {
                                            strToUnTab = untab_string(strToUnTab);
                                            listOfStrings[iTabPos] = strToUnTab;
                                            if( iTabPos==selectionCursorYPos && selectionCursorYPos==selectionEndCursorYPos )
                                            {
                                                if( selectionCursorXPos>selectionEndCursorXPos)
                                                {
                                                    selectionCursorXPos-=tabCharCount;
                                                }
                                                else
                                                {
                                                    selectionEndCursorXPos-=tabCharCount;
                                                }
                                            }
                                            else if(iTabPos==selectionEndCursorYPos  )
                                            {
                                                if( selectionCursorYPos>selectionEndCursorYPos)
                                                {
                                                    selectionCursorXPos-=tabCharCount;
                                                }
                                                else
                                                {
                                                    selectionEndCursorXPos-=tabCharCount;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                std::string tabAddition = generate_tabs(1);
                                if( selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos )
                                {
                                    for( int iTabPos = tabStartYPos; iTabPos <= tabEndYPos; iTabPos++)
                                    {
                                        listOfStrings[iTabPos] = tabAddition+listOfStrings[iTabPos];
                                    }
                                    if( selectionCursorYPos==selectionEndCursorYPos)
                                    {
                                        if( selectionCursorXPos>selectionEndCursorXPos)
                                        {
                                            selectionCursorXPos+=tabCharCount;
                                        }
                                        else
                                        {
                                            selectionEndCursorXPos+=tabCharCount;
                                        }
                                    }
                                    else
                                    {
                                        if( selectionCursorYPos>selectionEndCursorYPos)
                                        {
                                            selectionCursorXPos+=tabCharCount;
                                        }
                                        else
                                        {
                                            selectionEndCursorXPos+=tabCharCount;
                                        }
                                    }
                                }
                                else
                                {
                                    delete_selection();
                                    textInputString = get_substring(lineToEdit,0,cursorXPos);
                                    textInputString+=tabAddition;
                                    textInputString+=get_substring(lineToEdit,cursorXPos);
                                    cursorXPos+=tabCharCount;
                                    userInput->inkeys = "";
                                    listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                                    listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                                    scroll_to_cursor();
                                }

                                scroll_to_pos(lineStartYPos, cursorXPos+tabCharCount );
                            }
                            save_edit();
                        }
                        showCursor = true;
                        cursorTimer = 0;
                        codeBeingSuggested = false;
                        highlightedTerm = NULL;
                        tabDelay= 0;
                    }
                    else if( (int)userInput->inkeys.size()>0 && !isReadOnly )
                    {
                        //Type input into textarea
                        delete_selection();
                        log_editable_action();
                        textInputString = get_substring(lineToEdit,0,cursorXPos);
                        std::string preInputString = string_replace_all(textInputString," ","");
                        textInputString+=userInput->inkeys;
                        listOfStrings.erase(listOfStrings.begin()+cursorYPos);
                        std::string restofLine = get_substring(lineToEdit,cursorXPos);
                        if( userInput->inkeys=="{" && (int)restofLine.size()==0 && (int)preInputString.size()==0 )
                        {
                            int numbOfSpaces =  get_leading_space_count(lineToEdit);
                            cursorXPos = 0;
                            std::string nextString = "";
                            if( numbOfSpaces > 0)
                            {
                                for(int i= 0; i < numbOfSpaces; i++)
                                {
                                    nextString=" "+nextString;
                                }
                                cursorXPos = numbOfSpaces;
                            }
                            std::string bracketString = nextString+"}";
                            nextString="    "+nextString;
                            cursorXPos+=4;

                            textInputString+=restofLine;
                            listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);
                            listOfStrings.insert(listOfStrings.begin()+cursorYPos+1,nextString);
                            listOfStrings.insert(listOfStrings.begin()+cursorYPos+2,bracketString);
                            cursorYPos+=1;
                            scroll_to_pos(cursorYPos+1,cursorXPos);
                            userInput->inkeys = "";
                            save_edit();
                        }
                        else
                        {
                            log_editable_action();
                            cursorXPos+=(int)userInput->inkeys.size();
                            if( userInput->inkeys=="[" )
                            {
                                textInputString+="]";
                            }
                            else if( userInput->inkeys=="{" )
                            {
                                textInputString+="}";
                            }
                            else if( userInput->inkeys=="(" )
                            {
                                textInputString+=")";
                            }
                            textInputString+=restofLine;
                            listOfStrings.insert(listOfStrings.begin()+cursorYPos,textInputString);

                            userInput->inkeys = "";
                            if( isCodeEditor)
                            find_suggested_text();
                            scroll_to_cursor();
                            highlightedTerm = NULL;
                        }
                        userInput->inkeys = "";
                    }
                    else if( userInput->check_keyboard_released(kb_esc) )
                    {
                        GPE_MAIN_GUI->close_finder();
                        codeBeingSuggested = false;
                        highlightedTerm = NULL;
                    }
                }
            }

            parseForErrorsTimerPos++;
            if( parseForErrorsTimerPos >=parseForErrorsTimerGoal)
            {
                if( isCodeEditor && codeEditorType==0)
                {
                    //parse_code_javascript(viewedSpace,cam);
                }
                parseForErrorsTimerPos = 0;
            }
        }
        else
        {
            hasScrollControl = false;
            hasArrowkeyControl = false;
        }

        if( isHovered)
        {
            if( userInput->mouseScrollingUp > 0)
            {
                if( userInput->down[kb_ctrl])
                {
                    move_left(charactersWithinView/8);
                    highlightedTerm = NULL;
                }
                else
                {
                    move_up( 3 );
                    highlightedTerm = NULL;
                }
            }
            else if( userInput->mouseScrollingDown > 0)
            {
                if( userInput->down[kb_ctrl])
                {
                    move_right(charactersWithinView/8);
                    highlightedTerm = NULL;
                }
                else
                {
                    move_down( 3 );
                    highlightedTerm = NULL;
                }
            }
            hasScrollControl= true;
        }

        if( lineStartXPos < 0)
        {
            lineStartXPos = 0;
        }
        if( lineStartYPos < 0)
        {
            lineStartYPos = 0;
        }
    }

    GPE_MAIN_GUI->textAreaFindBox.x = barBox.x+lineCountBoxWidth;
    //if( showXScroll && textXScroll!=NULL)
    {
        //GPE_MAIN_GUI->textAreaFindBox.y = barBox.y+textEditorButtonBar->get_height()+renderBox.h+textXScroll->barBox.h;
    }
    //else
    {
        GPE_MAIN_GUI->textAreaFindBox.y = barBox.y+textEditorButtonBar->get_height()+renderBox.h;
    }
    GPE_MAIN_GUI->textAreaFindBox.w = barBox.w-lineCountBoxWidth;

    int findAllResult = 0;
    switch(GPE_MAIN_GUI->textSearchMode )
    {
        //find
        case 1:
            if( GPE_MAIN_GUI->findTextStringBox->has_content() )
            {
                if( GPE_MAIN_GUI->findTextStringBox->was_submitted() || GPE_MAIN_GUI->findButton->is_clicked() )
                {
                    if( find_string(GPE_MAIN_GUI->findTextStringBox->get_string(),GPE_MAIN_GUI->findMatchCase->is_clicked(),false)==false )
                    {
                        cursorXPos = 0;
                        cursorYPos = 0;
                        lineStartXPos = 0;
                        lineStartYPos = 0;
                        if( find_string(GPE_MAIN_GUI->findTextStringBox->get_string(),true,GPE_MAIN_GUI->findMatchCase->is_clicked(),false)==false)
                        {
                            GPE_MAIN_GUI->update_temporary_message("Searched for","["+GPE_MAIN_GUI->findTextStringBox->get_string()+"]","Unable to Find String");
                        }
                    }
                    GPE_MAIN_GUI->showFindAllResults = false;
                }
                /*
                else if( GPE_MAIN_GUI->findAllButton->is_clicked() )
                {
                    findAllResult = find_all_strings(GPE_MAIN_GUI->findTextStringBox->get_string(),GPE_MAIN_GUI->findMatchCase->is_clicked() );
                    displayMessageTitle = "Substring Search";
                    displayMessageSubtitle = GPE_MAIN_GUI->findTextStringBox->get_string();

                    if( findAllResult > 0)
                    {
                        displayMessageString = "Found "+int_to_string(findAllResult)+" results";
                        GPE_MAIN_GUI->showFindAllResults = true;
                    }
                    else
                    {
                        displayMessageString ="No matches found";
                        GPE_MAIN_GUI->showFindAllResults = false;
                    }
                    display_user_messaage();
                    GPE_MAIN_GUI->update_temporary_message(displayMessageTitle,displayMessageSubtitle,displayMessageString,5);
                }
                */
            }
        break;

        //goto line
        case 2:
            //GPE_MAIN_GUI->goToLineStringBox->set_string("1");

            if( (int)listOfStrings.size() > 0)
            {
                GPE_MAIN_GUI->goToLineStringBox->descriptionText = "Go To Line: 1 - "+int_to_string( get_line_count() ) ;
            }
            else
            {
                GPE_MAIN_GUI->goToLineStringBox->descriptionText = "Go To Line: ";
            }

            if( ( GPE_MAIN_GUI->goToLineStringBox->was_submitted() || GPE_MAIN_GUI->goToButton->is_clicked() ) &&  GPE_MAIN_GUI->goToLineStringBox->is_valid() )
            {
                scroll_to_pos(GPE_MAIN_GUI->goToLineStringBox->get_held_number()-1 ,0);
            }
        break;

        //find/replace
        case 3:
            if( !isReadOnly)
            {
                if( GPE_MAIN_GUI->findTextStringBox->has_content() )
                {
                    if( GPE_MAIN_GUI->findTextStringBox->was_submitted() || GPE_MAIN_GUI->findButton->is_clicked() )
                    {
                        if( find_string(GPE_MAIN_GUI->findTextStringBox->get_string(),true,GPE_MAIN_GUI->findMatchCase->is_clicked(),false)==false )
                        {
                            cursorXPos = 0;
                            cursorYPos = 0;
                            lineStartXPos = 0;
                            lineStartYPos = 0;
                            if( find_string(GPE_MAIN_GUI->findTextStringBox->get_string(),true,GPE_MAIN_GUI->findMatchCase->is_clicked(),false)==false)
                            {
                                GPE_MAIN_GUI->update_temporary_message("Searched for","["+GPE_MAIN_GUI->findTextStringBox->get_string()+"]","Unable to Find String");
                            }
                        }
                        GPE_MAIN_GUI->showFindAllResults = false;
                    }
                    /*
                    else if( GPE_MAIN_GUI->findAllButton->is_clicked() )
                    {
                        findAllResult = find_all_strings(GPE_MAIN_GUI->findTextStringBox->get_string(),GPE_MAIN_GUI->findMatchCase->is_clicked() );
                        displayMessageTitle = "Substring Search";
                        displayMessageSubtitle = GPE_MAIN_GUI->findTextStringBox->get_string();

                        if( findAllResult > 0)
                        {
                            displayMessageString = "Found "+int_to_string(findAllResult)+" results";
                            GPE_MAIN_GUI->showFindAllResults = true;
                        }
                        else
                        {
                            displayMessageString ="No matches found";
                            GPE_MAIN_GUI->showFindAllResults = false;
                        }
                        display_user_messaage();
                        GPE_MAIN_GUI->update_temporary_message(displayMessageTitle,displayMessageSubtitle,displayMessageString,15);
                    }
                    */
                    else if( GPE_MAIN_GUI->replaceTextStringBox->has_content() )
                    {
                        if( GPE_MAIN_GUI->replaceTextStringBox->was_submitted() || GPE_MAIN_GUI->replaceButton->is_clicked() )
                        {
                            GPE_MAIN_GUI->showFindAllResults = false;
                        }
                        else if( GPE_MAIN_GUI->replaceAllButton->is_clicked() )
                        {
                            if( display_get_prompt("Warning!","All copies of the text will be replaced. Are you sure you want to continue this operation?")==DISPLAY_QUERY_YES )
                            {
                                findAllResult = find_all_strings(GPE_MAIN_GUI->findTextStringBox->get_string(),true);
                                displayMessageTitle = "Replacing Substring";
                                displayMessageSubtitle = GPE_MAIN_GUI->findTextStringBox->get_string();

                                if( findAllResult > 0)
                                {
                                    displayMessageString = "Replaced "+int_to_string(replace_all_found(GPE_MAIN_GUI->findTextStringBox->get_string(), GPE_MAIN_GUI->replaceTextStringBox->get_string() ) )+" copies.";;
                                    GPE_MAIN_GUI->showFindAllResults = true;
                                }
                                else
                                {
                                    displayMessageString ="No matches found";
                                    GPE_MAIN_GUI->showFindAllResults = false;
                                }
                                display_user_messaage();
                                GPE_MAIN_GUI->update_temporary_message(displayMessageTitle,displayMessageSubtitle,displayMessageString,1);
                            }
                        }
                    }
                }
            }
        break;

        default:

        break;
    }

    if( !isReadOnly && pasteCommandGiven && SDL_HasClipboardText()==SDL_TRUE )
    {
        delete_selection();
        paste_clipboard();
        codeBeingSuggested = false;
        userInput->reset_all_input();
        process_self( viewedSpace,cam );
    }

    if( undoableActionOccurred)
    {
        time_t currentTimeNow;
        time(&currentTimeNow);
        if( difftime(currentTimeNow,lastUndoableActionTime ) >=4 )
        {
            save_edit();
        }
    }
}

void GPE_TextAreaInputBasic::redo_edit()
{
    if( can_redo() )
    {
        if( currentPositionInHistory >=0 && currentPositionInHistory+1 < (int)savedHistory.size() )
        {
            GPE_TextAreaInputBasic * tempPlace = savedHistory.at(currentPositionInHistory+1);
            if( tempPlace!=NULL)
            {
                copy_source(tempPlace,true);
                currentPositionInHistory++;
                showCursor = true;
                cursorTimer = 0;
            }
        }
    }
}

void GPE_TextAreaInputBasic::render_code_css(GPE_Renderer * cRender ,SDL_Rect * viewedSpace, SDL_Rect * cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);

    if( viewedSpace!=NULL && cam!=NULL && textEditorButtonBar!=NULL)
    {
        renderBox.x = barBox.x-cam->x;
        renderBox.y = barBox.y-cam->y+textEditorButtonBar->get_height();
        renderBox.w = barBox.w;

        if(showYScroll)
        {
            renderBox.w-=16;
        }
        renderBox.h = barBox.h-textEditorButtonBar->get_height()-32;

        int mostCharactersOfText = get_most_characters_used();
        if( mostCharactersOfText > charactersWithinView && showYScroll )
        {
            mostCharactersOfText-=2;
        }
        int i = 0;
        std::string currStringToRender = "";
        std::string currentLineInView = "";
        //Processes the sythax to re-render each one
        std::string foundSynthaxString = "";
        std::string foundGPEKeyTag= "";
        std::string foundGPEProperty = "";
        int tempSynStringSize = 0;
        int currPosToParse = 0, lineEnd = 0;
        int textRenderXPos = 0, textRenderYPos = 0;
        GPE_Color * color = NULL;
        bool isInBlockCommentMode = false;
        bool isInDoubleQuoteMode = false;
        bool isInSingleQuoteMode = false;
        int minLineToRender = std::max(lineStartYPos-50 ,0);
        int maxLineToRender = std::min(lineStartYPos+linesWithinView ,(int)listOfStrings.size()-1 );
        int endBlockCommentPos = 0;
        int endDQuoteCommentPos = 0;
        int endSQuoteCommentPos = 0;
        bool commentFoundInSymbols = false;
        GPE_ParsedText * mLineComment = new GPE_ParsedText(-1, -1);
        GPE_ParsedText * dqLineComment = new GPE_ParsedText(-1, -1);
        GPE_ParsedText * sqLineComment = new GPE_ParsedText(-1, -1);
        GPE_ParsedText * tempParseTextToAdd = new GPE_ParsedText(-1, -1);

        //Finds the previous mode of  the editor up to 20 lines to the current lineStartYPos
        for( i=minLineToRender; i < lineStartYPos && i < (int)listOfStrings.size(); i++)
        {
            currStringToRender = listOfStrings[i];
            currPosToParse = 0;
            lineEnd = (int)currStringToRender.size();
            while (currPosToParse < lineEnd)
            {
                if( isInBlockCommentMode==false && isInDoubleQuoteMode==false && isInSingleQuoteMode==false)
                {
                    if (currPosToParse < lineEnd)
                    {
                        if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currPosToParse + 1 < lineEnd && currStringToRender[currPosToParse + 1] == '/' )
                        {
                            currPosToParse = lineEnd;
                        }
                        else if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currStringToRender[currPosToParse + 1] == '*' )
                        {
                            isInBlockCommentMode = true;
                            currPosToParse+=2;
                        }
                        else if(currStringToRender[currPosToParse] == '"')
                        {
                            isInDoubleQuoteMode = true;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '\'')
                        {
                            isInSingleQuoteMode = true;
                            currPosToParse++;
                        }
                        else
                        {
                            currPosToParse++;
                        }
                    }
                }

                if( isInBlockCommentMode)
                {
                    endBlockCommentPos = currStringToRender.find("*/");
                    if( endBlockCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endBlockCommentPos+2;
                        isInBlockCommentMode = false;
                    }
                }
                else if( isInDoubleQuoteMode)
                {
                    endDQuoteCommentPos = currStringToRender.find('"',currPosToParse);
                    if( endDQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endDQuoteCommentPos+1;
                        isInDoubleQuoteMode = false;
                    }
                }
                else if( isInSingleQuoteMode)
                {
                    endSQuoteCommentPos = currStringToRender.find("'",currPosToParse);
                    if( endSQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endSQuoteCommentPos+1;
                        isInSingleQuoteMode = false;
                    }
                }
            }
        }

        for( i=lineStartYPos; i <= maxLineToRender; i++)
        {
            //resets highlight boxes and such
            if( commentLineText!=NULL)
            {
                commentLineText->reset_self();
            }
            if( datatypeLineText!=NULL)
            {
                datatypeLineText->reset_self();
            }
            if( dQuoteLineText!=NULL)
            {
                dQuoteLineText->reset_self();
            }
            if( functionLineText!=NULL)
            {
                functionLineText->reset_self();
            }
            if( keywordLineText!=NULL)
            {
                keywordLineText->reset_self();
            }
            if( normalLineText!=NULL)
            {
                normalLineText->reset_self();
            }

            if( numberLineText!=NULL)
            {
                numberLineText->reset_self();
            }

            if( sQuoteLineText!=NULL)
            {
                sQuoteLineText->reset_self();
            }

            if( symbolLineText!=NULL)
            {
                symbolLineText->reset_self();
            };

            currStringToRender = listOfStrings[i];
            currPosToParse = 0;

            lineEnd = (int)currStringToRender.size();

            endBlockCommentPos=(int)std::string::npos;
            endDQuoteCommentPos=(int)std::string::npos;
            endSQuoteCommentPos=(int)std::string::npos;

            foundGPEKeyTag = "";
            foundGPEProperty = "";
            mLineComment->textStart = -1;
            mLineComment->textEnd = -1;
            tempParseTextToAdd->textStart = -1;
            tempParseTextToAdd->textEnd = -1;

            while (currPosToParse < lineEnd)
            {
                if( isInBlockCommentMode==false && isInDoubleQuoteMode==false && isInSingleQuoteMode==false)
                {
                    while (currPosToParse < lineEnd && currStringToRender[currPosToParse]==' ')
                    {
                        currPosToParse++;
                    }
                    if (currPosToParse < lineEnd)
                    {
                        if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currPosToParse + 1 < lineEnd && currStringToRender[currPosToParse + 1] == '/' )
                        {
                            commentLineText->foundParses.push_back( new GPE_ParsedText(currPosToParse, lineEnd));
                            currPosToParse = lineEnd;
                        }
                        else if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currStringToRender[currPosToParse + 1] == '*' )
                        {
                            isInBlockCommentMode = true;
                            mLineComment->textStart = currPosToParse;
                            currPosToParse+=2;
                        }
                        else if(currStringToRender[currPosToParse] == '"')
                        {
                            isInDoubleQuoteMode = true;
                            dqLineComment->textStart = currPosToParse;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '\'')
                        {
                            isInSingleQuoteMode = true;
                            sqLineComment->textStart = currPosToParse;
                            currPosToParse++;
                        }
                        else if (isdigit(currStringToRender[currPosToParse]))
                        {
                            tempParseTextToAdd->textStart = currPosToParse;
                            currPosToParse++;
                            while( (currPosToParse < lineEnd && isdigit( currStringToRender[currPosToParse] )  ) || currStringToRender[currPosToParse] ==' ')
                            {
                                currPosToParse++;
                            }
                            tempParseTextToAdd->textEnd = currPosToParse;
                            numberLineText->foundParses.push_back(tempParseTextToAdd);
                            tempParseTextToAdd = new GPE_ParsedText(0, -1);
                        }
                        else if (GPE_MINI_COMPILER->charIsSymbol(currStringToRender[currPosToParse]))
                        {
                            tempParseTextToAdd->textStart = currPosToParse;
                            currPosToParse++;
                            commentFoundInSymbols = false;
                            while( ( commentFoundInSymbols==false && currPosToParse < lineEnd && GPE_MINI_COMPILER->charIsSymbol(currStringToRender[currPosToParse] ) )|| currStringToRender[currPosToParse] ==' ')
                            {
                                if( lineEnd > currPosToParse+1)
                                {
                                    if( currStringToRender[currPosToParse] == '/' && (currStringToRender[currPosToParse + 1] == '/' || currStringToRender[currPosToParse + 1] == '*' ) )
                                    {
                                        commentFoundInSymbols = true;
                                    }
                                    else if (currStringToRender[currPosToParse] == '*' && currStringToRender[currPosToParse + 1] == '/' )
                                    {
                                        commentFoundInSymbols = true;
                                    }
                                    else
                                    {
                                        currPosToParse++;
                                    }
                                }
                                else
                                {
                                    currPosToParse++;
                                }
                            }
                            tempParseTextToAdd->textEnd = currPosToParse;
                            symbolLineText->foundParses.push_back(tempParseTextToAdd);
                            tempParseTextToAdd = new GPE_ParsedText(0, -1);
                        }
                        else
                        {
                            if (char_is_alpha(currStringToRender[currPosToParse],false,true) )
                            {
                                //color = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;
                                tempParseTextToAdd->textStart = currPosToParse;
                                currPosToParse++;
                                while (currPosToParse < lineEnd && char_is_alnum(currStringToRender[currPosToParse],false,true) )
                                {
                                    currPosToParse++;
                                }
                                tempParseTextToAdd->textEnd = currPosToParse;
                                normalLineText->foundParses.push_back(tempParseTextToAdd);
                                tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                            }
                            // add new cases here:
                            // else if (...)
                            // {
                            //     ...
                            // }
                            else
                            {
                                //color = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;
                                //anything else is just regular text as well...
                                tempParseTextToAdd->textStart = currPosToParse;
                                tempParseTextToAdd->textEnd = currPosToParse+1;
                                normalLineText->foundParses.push_back(tempParseTextToAdd);
                                tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                                currPosToParse++;
                            }
                        }
                    }
                }
                if( isInBlockCommentMode)
                {
                    endBlockCommentPos = currStringToRender.find("*/");
                    if( endBlockCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endBlockCommentPos+2;
                        isInBlockCommentMode = false;
                    }
                    mLineComment->textEnd = currPosToParse;
                    commentLineText->foundParses.push_back(mLineComment);
                    mLineComment = new GPE_ParsedText(0, -1);
                }
                else if( isInDoubleQuoteMode)
                {
                    endDQuoteCommentPos = currStringToRender.find('"',currPosToParse);
                    if( endDQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endDQuoteCommentPos+1;
                        isInDoubleQuoteMode = false;
                    }
                    dqLineComment->textEnd = currPosToParse;
                    dQuoteLineText->foundParses.push_back(dqLineComment);
                    dqLineComment = new GPE_ParsedText(0, -1);
                }
                else if( isInSingleQuoteMode)
                {
                    endSQuoteCommentPos = currStringToRender.find("'",currPosToParse);
                    if( endSQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endSQuoteCommentPos+1;
                        isInSingleQuoteMode = false;
                    }
                    sqLineComment->textEnd = currPosToParse;
                    sQuoteLineText->foundParses.push_back(sqLineComment);
                    sqLineComment = new GPE_ParsedText(0, -1);
                }
            }

            if ( i >=lineStartYPos  )
            {
                textRenderXPos = renderBox.x+lineCountBoxWidth+2;
                textRenderYPos = renderBox.y+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4;

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_Color;
                normalLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_Number_Color;
                numberLineText->render_tokens(cRender,FONT_TEXTINPUT_NUMBER,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color,true );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_Symbols_Color;
                symbolLineText->render_tokens(cRender,FONT_TEXTINPUT_SYMBOL,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                //
                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Function_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Function_Color;
                }
                functionLineText->render_tokens(cRender,FONT_TEXTINPUT_FUNCTION,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                //
                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Keyword_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Keyword_Color;
                }
                keywordLineText->render_tokens(cRender,FONT_TEXTINPUT_KEYWORD,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Project_Keyword_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Project_Keyword_Color;
                }
                projectKeywordLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Project_Function_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Project_Function_Color;
                }
                projectFunctionLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );


                color = GPE_MAIN_TEMPLATE->Text_Box_Font_DataType_Color;
                datatypeLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_DataType_Color;
                datatypeLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_SQuote_Color;
                sQuoteLineText->render_tokens(cRender,FONT_TEXTINPUT_QUOTE,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_DQuote_Color;
                dQuoteLineText->render_tokens(cRender,FONT_TEXTINPUT_QUOTE,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_Comment_Color;
                commentLineText->render_tokens(cRender,FONT_TEXTINPUT_COMMENT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );
            }

        }

        if( mLineComment!=NULL)
        {
            delete mLineComment;
            mLineComment = NULL;
        }
        if( dqLineComment!=NULL)
        {
            delete dqLineComment;
            dqLineComment = NULL;
        }
        if( sqLineComment!=NULL)
        {
            delete sqLineComment;
            sqLineComment = NULL;
        }
        if( tempParseTextToAdd!=NULL)
        {
            delete tempParseTextToAdd;
            tempParseTextToAdd = NULL;
        }
    }
}

void GPE_TextAreaInputBasic::render_code_javascript(GPE_Renderer * cRender ,SDL_Rect * viewedSpace, SDL_Rect * cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( viewedSpace!=NULL && cam!=NULL && textEditorButtonBar!=NULL && has_content() )
    {
        renderBox.x = barBox.x-cam->x;
        renderBox.y = barBox.y-cam->y+textEditorButtonBar->get_height();
        renderBox.w = barBox.w;

        if(showYScroll)
        {
            renderBox.w-=16;
        }
        renderBox.h = barBox.h-textEditorButtonBar->get_height()-32;

        int mostCharactersOfText = get_most_characters_used();
        if( mostCharactersOfText > charactersWithinView && showYScroll )
        {
            mostCharactersOfText-=2;
        }
        int i = 0, j = 0;
        int parsedTokensCount = 0;
        std::string currStringToRender = "";
        std::string currentLineInView = "";
        //Processes the sythax to re-render each one
        std::string foundGPEDataType = "";
        std::string foundGPEFunction = "";
        std::string foundGPEVariable = "";
        std::string foundGPEKeyword = "";
        std::string foundGPEProjectFunction = "";
        std::string foundGPEProjectKeyword = "";
        std::string foundSynthaxString = "";
        int tempSynStringSize = 0;
        int currPosToParse = 0, lineEnd = 0;
        GPE_Color *color = NULL;
        int textRenderXPos = 0, textRenderYPos = 0;
        bool isInBlockCommentMode = false;
        bool isInDoubleQuoteMode = false;
        bool isInSingleQuoteMode = false;
        int minLineToRender = std::max(lineStartYPos-20 ,0);
        int maxLineToRender = std::min(lineStartYPos+linesWithinView ,(int)listOfStrings.size()-1);
        int endBlockCommentPos = 0;
        int endDQuoteCommentPos = 0;
        int endSQuoteCommentPos = 0;
        bool commentFoundInSymbols = false;
        GPE_ParsedText * mLineComment = new GPE_ParsedText(-1, -1);
        GPE_ParsedText * dqLineComment = new GPE_ParsedText(-1, -1);
        GPE_ParsedText * sqLineComment = new GPE_ParsedText(-1, -1);
        GPE_ParsedText * tempParseTextToAdd = new GPE_ParsedText(-1, -1);

        //Finds the previous mode of  the editor up to 20 lines to the current lineStartYPos
        for( i=minLineToRender; i < lineStartYPos && i < (int)listOfStrings.size(); i++)
        {
            currStringToRender = listOfStrings[i];
            currPosToParse = 0;
            lineEnd = (int)currStringToRender.size();
            while (currPosToParse < lineEnd)
            {
                if( isInBlockCommentMode==false && isInDoubleQuoteMode==false && isInSingleQuoteMode==false)
                {
                    if (currPosToParse < lineEnd)
                    {
                        if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currPosToParse + 1 < lineEnd && currStringToRender[currPosToParse + 1] == '/' )
                        {
                            currPosToParse = lineEnd;
                        }
                        else if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currStringToRender[currPosToParse + 1] == '*' )
                        {
                            isInBlockCommentMode = true;
                            currPosToParse+=2;
                        }
                        else if(currStringToRender[currPosToParse] == '"')
                        {
                            isInDoubleQuoteMode = true;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '\'')
                        {
                            isInSingleQuoteMode = true;
                            currPosToParse++;
                        }
                        else
                        {
                            currPosToParse++;
                        }
                    }
                }

                if( isInBlockCommentMode)
                {
                    endBlockCommentPos = currStringToRender.find("*/");
                    if( endBlockCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endBlockCommentPos+2;
                        isInBlockCommentMode = false;
                    }
                }
                else if( isInDoubleQuoteMode)
                {
                    endDQuoteCommentPos = currStringToRender.find('"',currPosToParse);
                    if( endDQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endDQuoteCommentPos+1;
                        isInDoubleQuoteMode = false;
                    }
                }
                else if( isInSingleQuoteMode)
                {
                    endSQuoteCommentPos = currStringToRender.find("'",currPosToParse);
                    if( endSQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endSQuoteCommentPos+1;
                        isInSingleQuoteMode = false;
                    }
                }
            }
        }

        for( i=lineStartYPos; i <= maxLineToRender; i++)
        {
            //resets highlight boxes and such
            if( commentLineText!=NULL)
            {
                commentLineText->reset_self();
            }
            if( datatypeLineText!=NULL)
            {
                datatypeLineText->reset_self();
            }
            if( dQuoteLineText!=NULL)
            {
                dQuoteLineText->reset_self();
            }
            if( functionLineText!=NULL)
            {
                functionLineText->reset_self();
            }
            if( keywordLineText!=NULL)
            {
                keywordLineText->reset_self();
            }
            if( variableLineText!=NULL)
            {
                variableLineText->reset_self();
            }
            if( normalLineText!=NULL)
            {
                normalLineText->reset_self();
            }

            if( numberLineText!=NULL)
            {
                numberLineText->reset_self();
            }

            if( sQuoteLineText!=NULL)
            {
                sQuoteLineText->reset_self();
            }

            if( symbolLineText!=NULL)
            {
                symbolLineText->reset_self();
            }

            if( projectFunctionLineText!=NULL)
            {
                projectFunctionLineText->reset_self();
            }

            if( projectKeywordLineText!=NULL)
            {
                projectKeywordLineText->reset_self();
            }

            currStringToRender = listOfStrings[i];
            currPosToParse = 0;

            lineEnd = (int)currStringToRender.size();

            endBlockCommentPos=(int)std::string::npos;
            endDQuoteCommentPos=(int)std::string::npos;
            endSQuoteCommentPos=(int)std::string::npos;

            foundGPEKeyword = "";
            foundGPEVariable = "";
            foundGPEDataType = "";
            foundGPEProjectFunction = "";
            foundGPEProjectKeyword = "";
            mLineComment->textStart = 0;
            mLineComment->textEnd = -1;
            tempParseTextToAdd->textStart = 0;
            tempParseTextToAdd->textEnd = -1;

            while (currPosToParse < lineEnd)
            {
                while (currPosToParse < lineEnd && currStringToRender[currPosToParse]==' ')
                {
                    currPosToParse++;
                }
                if( isInBlockCommentMode==false && isInDoubleQuoteMode==false && isInSingleQuoteMode==false)
                {
                    /*
                    while (currPosToParse < lineEnd && currStringToRender[currPosToParse]==' ')
                    {
                        currPosToParse++;
                    }*/
                    if (currPosToParse < lineEnd)
                    {
                        if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currPosToParse + 1 < lineEnd && currStringToRender[currPosToParse + 1] == '/' )
                        {
                            commentLineText->foundParses.push_back( new GPE_ParsedText(currPosToParse, lineEnd));
                            currPosToParse = lineEnd;
                        }
                        else if (currPosToParse+1<lineEnd && currStringToRender[currPosToParse] == '/' && currStringToRender[currPosToParse + 1] == '*' )
                        {
                            isInBlockCommentMode = true;
                            mLineComment->textStart = currPosToParse;
                            currPosToParse+=2;
                        }
                        else if(currStringToRender[currPosToParse] == '"')
                        {
                            isInDoubleQuoteMode = true;
                            dqLineComment->textStart = currPosToParse;
                            currPosToParse++;
                        }
                        else if(currStringToRender[currPosToParse] == '\'')
                        {
                            isInSingleQuoteMode = true;
                            sqLineComment->textStart = currPosToParse;
                            currPosToParse++;
                        }
                        else if (isdigit(currStringToRender[currPosToParse]))
                        {
                            tempParseTextToAdd->textStart = currPosToParse;
                            currPosToParse++;
                            while( (currPosToParse < lineEnd && isdigit( currStringToRender[currPosToParse] )  ) || currStringToRender[currPosToParse] ==' ')
                            {
                                currPosToParse++;
                            }
                            tempParseTextToAdd->textEnd = currPosToParse;
                            numberLineText->foundParses.push_back(tempParseTextToAdd);
                            tempParseTextToAdd = new GPE_ParsedText(0, -1);
                        }
                        else if( GPE_MINI_COMPILER->charIsSymbol(currStringToRender[currPosToParse] ))
                        {
                            tempParseTextToAdd->textStart = currPosToParse;
                            currPosToParse++;
                            commentFoundInSymbols = false;
                            while( ( commentFoundInSymbols==false && currPosToParse < lineEnd && GPE_MINI_COMPILER->charIsSymbol(currStringToRender[currPosToParse] ) )|| currStringToRender[currPosToParse] ==' ')
                            {
                                if( lineEnd > currPosToParse+1)
                                {
                                    if( currStringToRender[currPosToParse] == '/' && (currStringToRender[currPosToParse + 1] == '/' || currStringToRender[currPosToParse + 1] == '*' ) )
                                    {
                                        commentFoundInSymbols = true;
                                    }
                                    else if (currStringToRender[currPosToParse] == '*' && currStringToRender[currPosToParse + 1] == '/' )
                                    {
                                        commentFoundInSymbols = true;
                                    }
                                    else
                                    {
                                        currPosToParse++;
                                    }
                                }
                                else
                                {
                                    currPosToParse++;
                                }
                            }
                            tempParseTextToAdd->textEnd = currPosToParse;
                            symbolLineText->foundParses.push_back(tempParseTextToAdd);
                            tempParseTextToAdd = new GPE_ParsedText(0, -1);
                        }
                        else
                        {
                            if( CURRENT_PROJECT!=NULL)
                            {
                                foundGPEProjectFunction = CURRENT_PROJECT->find_project_function(currStringToRender,currPosToParse);
                                foundGPEProjectKeyword = CURRENT_PROJECT->find_project_keyword(currStringToRender,currPosToParse);
                            }
                            if( (foundGPEProjectFunction )!="")
                            {
                                tempParseTextToAdd->textStart = currPosToParse;
                                while (currPosToParse < lineEnd && foundGPEProjectFunction !="")
                                {
                                    if(foundGPEProjectFunction!="" )
                                    {
                                        currPosToParse+=(int)foundGPEProjectFunction.size();
                                    }
                                    else
                                    {
                                        currPosToParse++;
                                    }
                                    foundGPEProjectFunction= CURRENT_PROJECT->find_project_function(currStringToRender,currPosToParse);
                                }
                                tempParseTextToAdd->textEnd = currPosToParse;
                                projectFunctionLineText->foundParses.push_back(tempParseTextToAdd);
                                tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                            }
                            else if( (foundGPEProjectKeyword )!="")
                            {
                                tempParseTextToAdd->textStart = currPosToParse;
                                while (currPosToParse < lineEnd && foundGPEProjectKeyword !="")
                                {
                                    if(foundGPEProjectKeyword!="" )
                                    {
                                        currPosToParse+=(int)foundGPEProjectKeyword.size();
                                    }
                                    else
                                    {
                                        currPosToParse++;
                                    }
                                    foundGPEProjectKeyword= CURRENT_PROJECT->find_project_keyword(currStringToRender,currPosToParse);
                                }
                                tempParseTextToAdd->textEnd = currPosToParse;
                                projectKeywordLineText->foundParses.push_back(tempParseTextToAdd);
                                tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                            }
                            else
                            {
                                foundGPEDataType= GPE_MINI_COMPILER->find_gpe_datatype(currStringToRender,currPosToParse);
                                if( (foundGPEDataType )!="")
                                {
                                    tempParseTextToAdd->textStart = currPosToParse;
                                    while (currPosToParse < lineEnd && foundGPEDataType !="")
                                    {
                                        if(foundGPEDataType!="" )
                                        {
                                            currPosToParse+=(int)foundGPEDataType.size();
                                        }
                                        else
                                        {
                                            currPosToParse++;
                                        }
                                        foundGPEDataType= GPE_MINI_COMPILER->find_gpe_datatype(currStringToRender,currPosToParse);
                                    }
                                    tempParseTextToAdd->textEnd = currPosToParse;
                                    datatypeLineText->foundParses.push_back(tempParseTextToAdd);
                                    tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                                }
                                else
                                {
                                    foundGPEFunction =GPE_MINI_COMPILER->find_gpe_function(currStringToRender,currPosToParse);
                                    if( (foundGPEFunction )!="")
                                    {
                                        tempParseTextToAdd->textStart = currPosToParse;
                                        while (currPosToParse < lineEnd && foundGPEFunction !="")
                                        {
                                            if(foundGPEFunction!="" )
                                            {
                                                currPosToParse+=(int)foundGPEFunction.size();
                                            }
                                            else
                                            {
                                                currPosToParse++;
                                            }
                                            foundGPEFunction= GPE_MINI_COMPILER->find_gpe_function(currStringToRender,currPosToParse);
                                        }
                                        tempParseTextToAdd->textEnd = currPosToParse;
                                        functionLineText->foundParses.push_back(tempParseTextToAdd);
                                        tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                                    }
                                    else
                                    {
                                        foundGPEVariable = GPE_MINI_COMPILER->find_gpe_variable(currStringToRender,currPosToParse);
                                        if( (foundGPEVariable )!="")
                                        {
                                            tempParseTextToAdd->textStart = currPosToParse;
                                            while (currPosToParse < lineEnd && foundGPEVariable !="")
                                            {
                                                if(foundGPEVariable!="" )
                                                {
                                                    currPosToParse+=(int)foundGPEVariable.size();
                                                }
                                                else
                                                {
                                                    currPosToParse++;
                                                }
                                                foundGPEVariable = GPE_MINI_COMPILER->find_gpe_variable(currStringToRender,currPosToParse);
                                            }
                                            tempParseTextToAdd->textEnd = currPosToParse;
                                            variableLineText->foundParses.push_back(tempParseTextToAdd);
                                            tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                                        }
                                        else
                                        {
                                            foundGPEKeyword = GPE_MINI_COMPILER->find_gpe_keyword(currStringToRender,currPosToParse);
                                            if( (foundGPEKeyword )!="")
                                            {
                                                tempParseTextToAdd->textStart = currPosToParse;
                                                while (currPosToParse < lineEnd && foundGPEKeyword !="")
                                                {
                                                    if(foundGPEKeyword!="" )
                                                    {
                                                        currPosToParse+=(int)foundGPEKeyword.size();
                                                    }
                                                    else
                                                    {
                                                        currPosToParse++;
                                                    }
                                                    foundGPEKeyword = GPE_MINI_COMPILER->find_gpe_keyword(currStringToRender,currPosToParse);
                                                }
                                                tempParseTextToAdd->textEnd = currPosToParse;
                                                keywordLineText->foundParses.push_back(tempParseTextToAdd);
                                                tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                                            }
                                            else if (char_is_alpha(currStringToRender[currPosToParse],false,true) )
                                            {
                                                //color = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;
                                                tempParseTextToAdd->textStart = currPosToParse;
                                                currPosToParse++;
                                                while (currPosToParse < lineEnd && char_is_alnum(currStringToRender[currPosToParse],false,true) )
                                                {
                                                    currPosToParse++;
                                                }
                                                tempParseTextToAdd->textEnd = currPosToParse;
                                                normalLineText->foundParses.push_back(tempParseTextToAdd);
                                                tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                                            }
                                            else
                                            {
                                                if(currStringToRender[currPosToParse]!=' ')
                                                {
                                                    //color = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;
                                                    //anything else is just regular text as well...
                                                    tempParseTextToAdd->textStart = currPosToParse;
                                                    tempParseTextToAdd->textEnd = currPosToParse+1;
                                                    normalLineText->foundParses.push_back(tempParseTextToAdd);
                                                }
                                                tempParseTextToAdd = new GPE_ParsedText(-1, -1);
                                                currPosToParse++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if( isInBlockCommentMode)
                {
                    endBlockCommentPos = currStringToRender.find("*/");
                    if( endBlockCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endBlockCommentPos+2;
                        isInBlockCommentMode = false;
                    }
                    mLineComment->textEnd = currPosToParse;
                    commentLineText->foundParses.push_back(mLineComment);
                    mLineComment = new GPE_ParsedText(0, -1);
                }
                else if( isInDoubleQuoteMode)
                {
                    endDQuoteCommentPos = currStringToRender.find('"',currPosToParse);
                    if( endDQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endDQuoteCommentPos+1;
                        isInDoubleQuoteMode = false;
                    }
                    dqLineComment->textEnd = currPosToParse;
                    dQuoteLineText->foundParses.push_back(dqLineComment);
                    dqLineComment = new GPE_ParsedText(0, -1);
                }
                else if( isInSingleQuoteMode)
                {
                    endSQuoteCommentPos = currStringToRender.find("'",currPosToParse);
                    if( endSQuoteCommentPos==(int)std::string::npos)
                    {
                        currPosToParse = lineEnd;
                    }
                    else
                    {
                        currPosToParse = endSQuoteCommentPos+1;
                        isInSingleQuoteMode = false;
                    }
                    sqLineComment->textEnd = currPosToParse;
                    sQuoteLineText->foundParses.push_back(sqLineComment);
                    sqLineComment = new GPE_ParsedText(0, -1);
                }
            }

            if ( i >=lineStartYPos  )
            {
                textRenderXPos = renderBox.x+lineCountBoxWidth+2;
                textRenderYPos = renderBox.y+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4;

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_Color;
                normalLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_Number_Color;
                numberLineText->render_tokens(cRender,FONT_TEXTINPUT_NUMBER,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color,true );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_Symbols_Color;
                symbolLineText->render_tokens(cRender,FONT_TEXTINPUT_SYMBOL,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                //
                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Function_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Function_Color;
                }
                functionLineText->render_tokens(cRender,FONT_TEXTINPUT_FUNCTION,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                //
                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Keyword_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Keyword_Color;
                }
                keywordLineText->render_tokens(cRender,FONT_TEXTINPUT_KEYWORD,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Project_Keyword_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Project_Keyword_Color;
                }
                projectKeywordLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Project_Function_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Project_Function_Color;
                }
                projectFunctionLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );



                if( USE_COLORBLINDMODE)
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Variable_Alt_Color;
                }
                else
                {
                    color = GPE_MAIN_TEMPLATE->Text_Box_Font_Variable_Color;
                }
                variableLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_DataType_Color;
                datatypeLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_DataType_Color;
                datatypeLineText->render_tokens(cRender,FONT_TEXTINPUT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_SQuote_Color;
                sQuoteLineText->render_tokens(cRender,FONT_TEXTINPUT_QUOTE,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_DQuote_Color;
                dQuoteLineText->render_tokens(cRender,FONT_TEXTINPUT_QUOTE,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );

                color = GPE_MAIN_TEMPLATE->Text_Box_Font_Comment_Color;
                commentLineText->render_tokens(cRender,FONT_TEXTINPUT_COMMENT,currStringToRender,textRenderXPos,textRenderYPos,lineStartXPos,lineStartXPos+charactersWithinView,color );
            }
        }

        if( mLineComment!=NULL)
        {
            delete mLineComment;
            mLineComment = NULL;
        }
        if( dqLineComment!=NULL)
        {
            delete dqLineComment;
            dqLineComment = NULL;
        }
        if( sqLineComment!=NULL)
        {
            delete sqLineComment;
            sqLineComment = NULL;
        }
        if( tempParseTextToAdd!=NULL)
        {
            delete tempParseTextToAdd;
            tempParseTextToAdd = NULL;
        }
    }
}
void GPE_TextAreaInputBasic::render_self(GPE_Renderer * cRender ,SDL_Rect * viewedSpace, SDL_Rect * cam,bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);

    if( viewedSpace!=NULL &&  cam!=NULL && textEditorButtonBar!=NULL)
    {
        int subCopyStartPos = 0;
        if( (int)listOfStrings.size()==0)
        {
            listOfStrings.push_back("");
            reset_self();
        }
        renderBox.x = barBox.x-cam->x;
        renderBox.y = barBox.y-cam->y+textEditorButtonBar->get_height();
        renderBox.w = barBox.w;

        if(showYScroll)
        {
            renderBox.w-=16;
        }
        renderBox.h = get_renderbox_height();

        int mostCharactersOfText = get_most_characters_used();
        if( mostCharactersOfText > charactersWithinView && showYScroll )
        {
            mostCharactersOfText-=2;
        }
        if( forceRedraw)
        {
            int i = 0;

            std::string currentLineInView = "";
            redrawDelay++;
            //if( redrawDelay >= redrawDelayMax)
            {
                redrawDelay = 0;
            }
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Text_Box_Color,false);

            if( has_content() )
            {
                //Calculates and highlights the symbols
                find_connected_symbols();
                if( symbolCursorXPos >= lineStartXPos && symbolCursorYPos >=lineStartYPos )
                {
                    render_rectangle(cRender,
                                     renderBox.x+lineCountBoxWidth+2+( std::min(mostCharactersOfText,symbolCursorXPos)-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                                     renderBox.y+(symbolCursorYPos-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                     renderBox.x+lineCountBoxWidth+2+( std::min(mostCharactersOfText,symbolCursorXPos)-lineStartXPos+1)*TEXTBOX_FONT_SIZE_WIDTH,
                                     renderBox.y+(symbolCursorYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                     GPE_MAIN_TEMPLATE->Text_Box_Font_Comment_Color,false,64);
                }
                if( symbolEndCursorXPos >= lineStartXPos && symbolEndCursorYPos >=lineStartYPos )
                {
                    render_rectangle(cRender,
                                     renderBox.x+lineCountBoxWidth+2+( std::min(mostCharactersOfText,symbolEndCursorXPos)-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                                     renderBox.y+(symbolEndCursorYPos-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                     renderBox.x+lineCountBoxWidth+2+( std::min(mostCharactersOfText,symbolEndCursorXPos)-lineStartXPos+1)*TEXTBOX_FONT_SIZE_WIDTH,
                                     renderBox.y+(symbolEndCursorYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                     GPE_MAIN_TEMPLATE->Text_Box_Font_Comment_Color,false,64);
                }

                //Renders the text highlights
                if(selectionCursorXPos!=selectionEndCursorXPos || selectionCursorYPos!=selectionEndCursorYPos)
                {
                    int minHighlightXPos = 0, maxHighlightXPos = 0;
                    int minHighlightYPos = std::min(selectionCursorYPos, selectionEndCursorYPos);
                    int maxHighlightYPos = std::max(selectionCursorYPos, selectionEndCursorYPos);

                    if( selectionCursorYPos > selectionEndCursorYPos)
                    {
                        minHighlightXPos = selectionEndCursorXPos;
                        maxHighlightXPos = selectionCursorXPos;
                    }
                    else
                    {
                        maxHighlightXPos = selectionEndCursorXPos;
                        minHighlightXPos = selectionCursorXPos;
                    }
                    if(minHighlightYPos!=maxHighlightYPos)
                    {
                        if( (int)listOfStrings.size() > minHighlightYPos && minHighlightYPos>=lineStartYPos && minHighlightYPos < lineStartYPos+linesWithinView )
                        {
                            if( (int)listOfStrings.at(minHighlightYPos).size() > lineStartXPos && ( minHighlightXPos <= lineStartXPos+charactersWithinView) )
                            {
                                render_rectangle(cRender,
                                                 renderBox.x+lineCountBoxWidth+2+std::max(0,minHighlightXPos-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                                                 renderBox.y+(minHighlightYPos-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                                 renderBox.x+lineCountBoxWidth+2+( std::min(mostCharactersOfText,(int)listOfStrings.at(minHighlightYPos).size() )-lineStartXPos+1)*TEXTBOX_FONT_SIZE_WIDTH,
                                                 renderBox.y+(minHighlightYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                                 GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,false);
                            }
                            else
                            {
                                render_rectangle(cRender,
                                renderBox.x+lineCountBoxWidth+2,
                                renderBox.y+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                renderBox.x+lineCountBoxWidth+2+TEXTBOX_FONT_SIZE_WIDTH,
                                renderBox.y+(i-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,false);

                            }
                        }

                        if( maxHighlightYPos-minHighlightYPos > 1)
                        {
                            for( i = minHighlightYPos+1; i <=maxHighlightYPos-1 && i < (int)listOfStrings.size() && i <= lineStartYPos+linesWithinView; i++ )
                            {
                                if( i >=lineStartYPos  && minHighlightYPos < lineStartYPos+linesWithinView)
                                {
                                    if( (int)listOfStrings[i].size() > lineStartXPos )
                                    {
                                            render_rectangle(cRender,
                                                    renderBox.x+lineCountBoxWidth+2,
                                                    renderBox.y+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                                    renderBox.x+lineCountBoxWidth+2+( std::min( mostCharactersOfText,(int)listOfStrings[i].size() )-lineStartXPos )*TEXTBOX_FONT_SIZE_WIDTH,
                                                    renderBox.y+(i-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,false);
                                    }
                                    else
                                    {
                                        render_rectangle(cRender,
                                                    renderBox.x+lineCountBoxWidth+2,
                                                    renderBox.y+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                                    renderBox.x+lineCountBoxWidth+2+TEXTBOX_FONT_SIZE_WIDTH,
                                                    renderBox.y+(i-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,false);
                                    }
                                }
                            }
                        }

                        if( (int)listOfStrings.size() > maxHighlightYPos && maxHighlightYPos>=lineStartYPos  && maxHighlightYPos < lineStartYPos+linesWithinView )
                        {
                            std::string lastStrToHighlight = listOfStrings.at(maxHighlightYPos);
                            if( (int)lastStrToHighlight.size() > lineStartXPos && maxHighlightXPos >= lineStartXPos )
                            {
                                render_rectangle(cRender,
                                                 renderBox.x+lineCountBoxWidth+2,
                                                 renderBox.y+(maxHighlightYPos-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                                 renderBox.x+lineCountBoxWidth+2+( std::min(mostCharactersOfText,maxHighlightXPos)-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                                                 renderBox.y+(maxHighlightYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                                 GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,false);
                            }
                            else
                            {
                                render_rectangle(cRender,
                                            renderBox.x+lineCountBoxWidth+2,
                                            renderBox.y+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                            renderBox.x+lineCountBoxWidth+2+TEXTBOX_FONT_SIZE_WIDTH,
                                            renderBox.y+(i-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,false);
                            }
                        }
                    }
                    else if( maxHighlightXPos >= lineStartXPos && maxHighlightYPos>=lineStartYPos && maxHighlightYPos < lineStartYPos+linesWithinView)
                    {
                        minHighlightXPos = std::min(mostCharactersOfText,minHighlightXPos);
                        maxHighlightXPos = std::min(mostCharactersOfText,maxHighlightXPos);

                        if( minHighlightXPos==maxHighlightXPos)
                        {
                            maxHighlightXPos++;
                        }
                        render_rectangle(cRender,
                                         renderBox.x+lineCountBoxWidth+2+( minHighlightXPos-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                                         renderBox.y+(maxHighlightYPos-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                         renderBox.x+lineCountBoxWidth+2+( maxHighlightXPos-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                                         renderBox.y+(maxHighlightYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                         GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,false);
                    }
                }

                //Renders the texts
                std::string currStringToRender = "";
                if( GPE_MAIN_GUI->showTextEditorSynthaxHightlight && isCodeEditor)
                {
                    //CSS Codes
                    if( codeEditorType==1)
                    {
                        render_code_css(cRender,viewedSpace,cam);
                    }
                    else
                    {
                        //JavaScript Codes
                        render_code_javascript(cRender,viewedSpace,cam);
                    }
                }
                else
                {
                    GPE_Color * textColor = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;
                    int foundSpecialLogPos = 0;
                    for( i=lineStartYPos; i <= lineStartYPos+linesWithinView && i < (int)listOfStrings.size(); i++)
                    {
                        currStringToRender = listOfStrings[i];
                        if( (int)currStringToRender.size() > lineStartXPos)
                        {
                            subCopyStartPos = 0;
                            if( isTextLog)
                            {
                                textColor = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;;
                                foundSpecialLogPos = currStringToRender.find("Error:");
                                if( foundSpecialLogPos!=(int)std::string::npos)
                                {
                                    textColor = GPE_MAIN_TEMPLATE->Input_Error_Box_Color;
                                    subCopyStartPos =7;
                                }
                                else
                                {
                                    foundSpecialLogPos = currStringToRender.find("Warning:");
                                    if( foundSpecialLogPos!=(int)std::string::npos)
                                    {
                                        textColor = GPE_MAIN_TEMPLATE->Text_Box_Font_Keyword_Color;
                                        subCopyStartPos =8;
                                    }
                                    else
                                    {
                                        foundSpecialLogPos = currStringToRender.find("Comment:");
                                        if( foundSpecialLogPos!=(int)std::string::npos)
                                        {
                                            textColor = GPE_MAIN_TEMPLATE->Text_Box_Font_Comment_Color;
                                            subCopyStartPos =8;
                                        }
                                    }
                                }
                            }
                            currStringToRender = get_substring(currStringToRender,lineStartXPos,charactersWithinView );

                            render_new_text(cRender,renderBox.x+lineCountBoxWidth+2,renderBox.y+4+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                                            currStringToRender,textColor,FONT_TEXTINPUT,FA_LEFT,FA_TOP,255 );
                        }
                    }
                }

                //Renders the scrollbars
                if( showXScroll && textXScroll!=NULL)
                {
                    textXScroll->render_self(cRender,viewedSpace,cam);
                }
                if( showYScroll && textYScroll!=NULL)
                {
                    textYScroll->render_self(cRender,viewedSpace,cam);
                }

                //attempt to draw the cursor
                if( cursorYPos < (int) listOfStrings.size() )
                {
                    currentLineInView = listOfStrings[cursorYPos];
                }
            }

            //draws the line count box
            if( lineCountBoxWidth>0 && GPE_MAIN_GUI->showTextEditorLineCount)
            {
                render_rectangle(cRender,barBox.x-cam->x,renderBox.y,barBox.x+lineCountBoxWidth-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Text_Box_Outer_Color,false);
                for( i=lineStartYPos; i <= lineStartYPos+linesWithinView && i < (int)listOfStrings.size(); i++)
                {
                    if( i == cursorYPos)
                    {
                        render_rectangle(cRender,renderBox.x,renderBox.y+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,renderBox.x+lineCountBoxWidth,renderBox.y+(i-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,GPE_MAIN_TEMPLATE->Text_Box_Highlight_Color,false);
                    }
                    render_bitmap_text(cRender,renderBox.x+lineCountBoxWidth/2,renderBox.y+(i-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,int_to_string(1+i),GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_TEXTINPUT,FA_CENTER,FA_TOP,255);
                }
                render_rectangle(cRender,barBox.x-cam->x,renderBox.y,barBox.x+lineCountBoxWidth-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Text_Box_Outline_Color,true);
            }

            render_rectangle(cRender,renderBox.x,renderBox.y,renderBox.x+renderBox.w,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Text_Box_Outline_Color,true);
            //render_horizontal_line_color(cRender,renderBox.y+renderBox.h+GENERAL_GPE_PADDING,renderBox.x+lineCountBoxWidth,renderBox.x+renderBox.w,GPE_MAIN_TEMPLATE->Main_Border_Color);



            if( !isReadOnly )
            {
                render_rectangle(cRender,textEditorButtonBar->get_xpos()-cam->x,textEditorButtonBar->get_ypos()-cam->y,textEditorButtonBar->get_x2pos()-cam->x,textEditorButtonBar->get_y2pos()-cam->y,GPE_MAIN_TEMPLATE->Text_Box_Outer_Color,false);
                textEditorButtonBar->render_self(cRender,viewedSpace,cam);
            }
        }

        if( isInUse && (prevCursorXPos >=lineStartXPos && prevCursorXPos <= lineStartXPos+charactersWithinView) &&  ( prevCursorYPos >=lineStartYPos && prevCursorYPos <= lineStartYPos+linesWithinView ) )
        {
            if( prevCursorXPos!=cursorXPos || prevCursorYPos!=cursorYPos )
            {
                render_vertical_line_color(cRender,renderBox.x+lineCountBoxWidth+2+(prevCursorXPos-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                        renderBox.y+(prevCursorYPos-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                        renderBox.y+(prevCursorYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                        GPE_MAIN_TEMPLATE->Text_Box_Color);
            }
        }

        //renders the cursor blinking effect
        if( isInUse && (cursorXPos >=lineStartXPos && cursorXPos <= lineStartXPos+charactersWithinView) &&  ( cursorYPos >=lineStartYPos && cursorYPos <= lineStartYPos+linesWithinView ) )
        {
            if( showCursor)
            {
                render_vertical_line_color(cRender,renderBox.x+lineCountBoxWidth+2+(cursorXPos-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                    renderBox.y+(cursorYPos-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                    renderBox.y+(cursorYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT-GENERAL_GPE_PADDING/4,
                    GPE_MAIN_TEMPLATE->Main_Box_Font_Color);
            }
            else
            {
                render_vertical_line_color(cRender,renderBox.x+lineCountBoxWidth+2+(cursorXPos-lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH,
                        renderBox.y+(cursorYPos-lineStartYPos)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                        renderBox.y+(cursorYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT+GENERAL_GPE_PADDING/4,
                        GPE_MAIN_TEMPLATE->Text_Box_Color);
            }
        }

        if( isInUse)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Input_Highlight_Outline_Color,true);
            if( !isReadOnly)
            {
                std::string editorFeedbackLine = "Line: "+int_to_string(cursorYPos+1)+", Column: "+int_to_string(cursorXPos+1);
                if( GPE_Main_Statusbar!=NULL)
                {
                    GPE_Main_Statusbar->set_codestring(editorFeedbackLine);
                }
            }
        }

        if( forceRedraw)
        {
            SDL_RenderSetViewport( cRender->get_renderer(), NULL );
            SDL_RenderSetViewport( cRender->get_renderer(), NULL );
            int iRendSuggestion = 0;
            GPE_Compiler_Term * cTerm = NULL;
            std::string fullPhraseToRender = "";
            if( codeBeingSuggested && (int)suggestedCompilerTerms.size() > 0 )
            {
                int suggestionRenderYPos = barBox.y+viewedSpace->y;
                if( cursorYPos >= lineStartYPos)
                {
                    if( cursorYPos+suggestedTextMaxInViewCount <= lineStartYPos+linesWithinView && suggestedTextMaxInViewCount < linesWithinView )
                    {
                        suggestionRenderYPos +=(cursorYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT;
                        suggestionRenderYPos+=textEditorButtonBar->get_height();
                    }
                    else if( suggestedTextMaxInViewCount >= (int)suggestedCompilerTerms.size() )
                    {
                        suggestionRenderYPos += (cursorYPos-lineStartYPos-suggestedTextMaxInViewCount)*GPE_AVERAGE_LINE_HEIGHT;
                        suggestionRenderYPos+=textEditorButtonBar->get_height();
                    }
                    else
                    {
                        suggestionRenderYPos+=(cursorYPos-lineStartYPos-(int)suggestedCompilerTerms.size() )*GPE_AVERAGE_LINE_HEIGHT;
                        suggestionRenderYPos+=textEditorButtonBar->get_height();
                    }

                    int iSuggestedEntry = 0;
                    for( int iSuggestedEntry = iSuggestedStartPos;iSuggestedEntry < (int)suggestedCompilerTerms.size() && iSuggestedEntry <  iSuggestedStartPos+suggestedTextMaxInViewCount;iSuggestedEntry++ )
                    {
                        cTerm = suggestedCompilerTerms[iSuggestedEntry];
                        if( cTerm!=NULL)
                        {
                            if( cTerm->termType==CTERM_FUNCTION)
                            {
                                if( (int)cTerm->termScope.size() > 0 && cTerm->termScope!="User Global" )
                                {
                                    fullPhraseToRender = cTerm->termFunctionReturnType+" "+cTerm->termScope+"."+cTerm->termString+"("+cTerm->get_parameters()+")";
                                }
                                else
                                {
                                    fullPhraseToRender = cTerm->termFunctionReturnType+" "+cTerm->termString+"("+cTerm->get_parameters()+")";
                                }
                            }
                            else if( (int)cTerm->termScope.size() > 0 && cTerm->termScope!="User Global" )
                            {
                                fullPhraseToRender = cTerm->termScope+"."+cTerm->termString;
                            }
                            else
                            {
                                fullPhraseToRender = cTerm->termString;
                            }
                            if( iSuggestedEntry==iSuggestionPos)
                            {
                                render_rectangle(cRender, barBox.x+viewedSpace->x, suggestionRenderYPos+GPE_AVERAGE_LINE_HEIGHT*iRendSuggestion,barBox.x+viewedSpace->x+maxSuggestedTextWidth, suggestionRenderYPos+GPE_AVERAGE_LINE_HEIGHT*(iRendSuggestion+1),GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);
                                render_new_text(cRender,barBox.x+viewedSpace->x+32, suggestionRenderYPos+GPE_AVERAGE_LINE_HEIGHT*iRendSuggestion,fullPhraseToRender,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,FONT_TEXTINPUT,FA_LEFT,FA_TOP,255 );
                            }
                            else
                            {
                                render_rectangle(cRender, barBox.x+viewedSpace->x, suggestionRenderYPos+GPE_AVERAGE_LINE_HEIGHT*iRendSuggestion,barBox.x+viewedSpace->x+maxSuggestedTextWidth, suggestionRenderYPos+GPE_AVERAGE_LINE_HEIGHT*(iRendSuggestion+1),GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);
                                render_new_text(cRender,barBox.x+viewedSpace->x+32, suggestionRenderYPos+GPE_AVERAGE_LINE_HEIGHT*iRendSuggestion,fullPhraseToRender,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TEXTINPUT,FA_LEFT,FA_TOP,255 );
                            }
                            iRendSuggestion++;
                        }
                    }
                    render_rectangle(cRender, barBox.x+viewedSpace->x, suggestionRenderYPos,barBox.x+viewedSpace->x+maxSuggestedTextWidth, suggestionRenderYPos+GPE_AVERAGE_LINE_HEIGHT*(iRendSuggestion+1),GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);

                }
                else
                {
                    codeBeingSuggested = false;
                    suggestedCompilerTerms.clear();
                }
            }
            else if( highlightedTerm!=NULL && highlightYPos >=lineStartYPos && highlightYPos <= lineStartYPos+linesWithinView+3 )
            {
                std::string fullTermDescription = "";
                GPE_MAIN_GUI->highlightedTerm = highlightedTerm;

                GPE_MAIN_GUI->highlightXPos = renderBox.x+viewedSpace->x+lineCountBoxWidth+( (highlightXPos -lineStartXPos)*TEXTBOX_FONT_SIZE_WIDTH);
                int suggestionRenderYPos = 0;

                if( highlightYPos > lineStartYPos+1)
                {
                    if( highlightYPos+3 <= lineStartYPos+linesWithinView)
                    {
                        suggestionRenderYPos = (highlightYPos-lineStartYPos+1)*GPE_AVERAGE_LINE_HEIGHT;
                    }
                    else
                    {
                        suggestionRenderYPos = (highlightYPos-lineStartYPos-4 )*GPE_AVERAGE_LINE_HEIGHT;
                    }
                }
                else
                {
                    suggestionRenderYPos=(highlightYPos-lineStartYPos+3)*GPE_AVERAGE_LINE_HEIGHT;
                }
                GPE_MAIN_GUI->highlightYPos = renderBox.y+viewedSpace->y+suggestionRenderYPos;
            }
            SDL_RenderSetViewport( cRender->get_renderer(), viewedSpace );
        }
    }
}

int GPE_TextAreaInputBasic::replace_all_found(std::string strToReplace, std::string newString)
{
    GPE_TextAnchor * cAnchor = NULL;
    std::string tempLine = "";
    std::string changedLine = "";
    int copiesDeleted = 0;
    export_text_anchors(APP_DIRECTORY_NAME+"replace_test.txt");
    for( int iReplace = (int)anchorPositions.size()-1; iReplace >=0;iReplace--)
    {
        cAnchor = anchorPositions.at( iReplace);
        if( cAnchor!=NULL)
        {
            if( (int)listOfStrings.size() > cAnchor->lineNumber )
            {
                tempLine = listOfStrings.at( cAnchor->lineNumber);
                if( (int)tempLine.size() >= cAnchor->characterNumber+(int)strToReplace.size() )
                {
                    changedLine = tempLine.substr(0,cAnchor->characterNumber)+newString+tempLine.substr(cAnchor->characterNumber+(int)strToReplace.size() );
                    listOfStrings[cAnchor->lineNumber] = changedLine;
                    copiesDeleted++;
                }
            }
        }
    }
    showCursor = true;
    cursorTimer = 0;
    return copiesDeleted;
}

void GPE_TextAreaInputBasic::reset_selection(int resetDirection)
{
    if( resetDirection < 0)
    {
        if(selectionCursorXPos!=selectionEndCursorXPos  || selectionCursorYPos!=selectionEndCursorYPos )
        {
            if( selectionCursorYPos==selectionEndCursorYPos)
            {
                cursorXPos = std::min(selectionCursorXPos, selectionEndCursorXPos);
                cursorYPos = selectionCursorYPos;
            }
            else if( selectionCursorYPos > selectionEndCursorYPos)
            {
                cursorXPos = selectionEndCursorXPos;
                cursorYPos = selectionEndCursorYPos;
            }
            else
            {
                cursorXPos = selectionCursorXPos;
                cursorYPos = selectionCursorYPos;
            }
        }

    }
    if(  resetDirection > 0)
    {
        if(selectionCursorXPos!=selectionEndCursorXPos  || selectionCursorYPos!=selectionEndCursorYPos )
        {
            if( selectionCursorYPos==selectionEndCursorYPos)
            {
                cursorXPos = std::max(selectionCursorXPos, selectionEndCursorXPos);
                cursorYPos = selectionCursorYPos;
            }
            else if( selectionCursorYPos > selectionEndCursorYPos)
            {
                cursorXPos = selectionCursorXPos;
                cursorYPos = selectionCursorYPos;
            }
            else
            {
                cursorXPos = selectionEndCursorXPos;
                cursorYPos = selectionEndCursorYPos;
            }
        }
    }
    selectionCursorXPos = 0;
    selectionCursorYPos = 0;
    selectionEndCursorXPos = 0;
    selectionEndCursorYPos = 0;
    if( listOfStrings.size() <=0)
    {
        listOfStrings.push_back("");
        cursorXPos = 0;
        cursorYPos = 0;
    }
    if( cursorYPos >= (int)listOfStrings.size() )
    {

        cursorYPos= (int)listOfStrings.size() - 1;
        lineToEdit = listOfStrings[cursorYPos];
        cursorXPos = (int)lineToEdit.size();
    }
    else if( cursorXPos > (int)listOfStrings[cursorYPos].size() )
    {
        cursorXPos = (int)listOfStrings[cursorYPos].size();
    }
    showCursor = true;
    cursorTimer = 0;
}

void GPE_TextAreaInputBasic::reset_self()
{
    cursorXPos = 0;
    cursorYPos = 0;
    selectionCursorXPos = 0;
    selectionCursorYPos = 0;
    selectionEndCursorXPos = 0;
    selectionEndCursorYPos = 0;
    bscDelay = 0;
    delDelay = 0;
    enterDelay = 0;
    upDelay = 0;
    downDelay = 0;
    leftDelay = 0;
    rightDelay = 0;
    tabDelay=0;
    showCursor = true;
    cursorTimer = 0;
}

void GPE_TextAreaInputBasic::revise_edit(int editId)
{
    if( editId >=0 && editId < (int)savedHistory.size() )
    {
        GPE_TextAreaInputBasic * tempPlace = savedHistory.at(editId);
        if( tempPlace!=NULL)
        {
            save_edit();
            copy_source(tempPlace,true);
        }
    }
}

void GPE_TextAreaInputBasic::save_edit()
{
    bool currentContentChanged = true;
    bool prevContentChanged = true;
    bool nextContentChanged = true;
    GPE_TextAreaInputBasic * fTextArea = NULL;
    if( currentPositionInHistory > 0 && (int)savedHistory.size() > currentPositionInHistory-1 )
    {
        fTextArea = savedHistory.at(currentPositionInHistory-1);
        if( fTextArea!=NULL)
        {
            if( compare_with(fTextArea)==1)
            {
                prevContentChanged = false;
            }
        }
    }

    if( currentPositionInHistory >= 0 && (int)savedHistory.size() > currentPositionInHistory )
    {
        fTextArea = savedHistory.at(currentPositionInHistory);
        if( fTextArea!=NULL)
        {
            if( compare_with(fTextArea)==1)
            {
                currentContentChanged = false;
            }
        }
    }

    if( currentPositionInHistory >= 0 && (int)savedHistory.size() > currentPositionInHistory+1 )
    {
        fTextArea = savedHistory.at(currentPositionInHistory+1);
        if( fTextArea!=NULL)
        {
            if( compare_with(fTextArea)==1)
            {
                nextContentChanged = false;
            }
        }
    }

    if( currentContentChanged && prevContentChanged && nextContentChanged)
    {
        //int prevSavePos = currentPositionInHistory;
        if( (int)savedHistory.size() >= 128 )
        {
            if( currentPositionInHistory < 32)
            {
                //remove from right
                savedHistory.erase(savedHistory.end());
            }
            else if( currentPositionInHistory > 96)
            {
                //remove from left
                savedHistory.erase(savedHistory.begin());
                currentPositionInHistory--;
            }
            else
            {
                if( currentPositionInHistory>=64)
                {
                    savedHistory.erase(savedHistory.begin());
                    currentPositionInHistory--;
                }
                else
                {
                    savedHistory.erase(savedHistory.end());
                }
            }
        }

        GPE_TextAreaInputBasic * savedText = new GPE_TextAreaInputBasic(false);
        savedText->copy_source(this,true);
        if( currentPositionInHistory >=0 && currentPositionInHistory < (int)savedHistory.size() )
        {
            savedHistory.insert(savedHistory.begin()+currentPositionInHistory+1,savedText);
            currentPositionInHistory++;
        }
        else
        {
            savedHistory.push_back(savedText);
            currentPositionInHistory = savedHistory.size()-1;
        }
    }
    undoableActionOccurred = false;
}

void GPE_TextAreaInputBasic::select_all()
{
    cursorXPos = 0;
    cursorYPos = 0;
    selectionCursorXPos = 0;
    selectionCursorYPos = 0;
    selectionEndCursorXPos = 0;
    selectionEndCursorYPos = 0;
    int listSize = (int)listOfStrings.size() ;
    if( listSize > 0)
    {
        std::string tempStr = listOfStrings.back();
        selectionEndCursorYPos = listSize - 1;
        if( (int)tempStr.size() > 0)
        {
            selectionEndCursorXPos = tempStr.size();
        }
    }
    showCursor = true;
    cursorTimer = 0;
}

void GPE_TextAreaInputBasic::scroll_to_pos(int lineNumberIn, int characterNumberIn)
{
    if( showYScroll )
    {
        showYScroll = true;
        lineStartYPos = lineNumberIn;
        if( lineStartYPos+linesWithinView >= (int)listOfStrings.size() )
        {
            lineStartYPos =  (int)listOfStrings.size() - linesWithinView;
        }
        if( lineStartYPos < 0)
        {
            lineStartYPos = 0;
        }

    }
    if( showXScroll )
    {
        if( characterNumberIn > lineStartXPos+charactersWithinView)
        {
            lineStartXPos = characterNumberIn-charactersWithinView;
        }
        else if( characterNumberIn < lineStartXPos )
        {
            lineStartXPos = characterNumberIn;
        }

        if( lineStartXPos+charactersWithinView > get_most_characters_used() )
        {
            lineStartXPos =  get_most_characters_used() - charactersWithinView;
        }
        if( lineStartXPos < 0)
        {
            lineStartXPos = 0;
        }
    }
    else
    {
        lineStartXPos = 0;
    }
    showCursor = true;
    cursorTimer = 0;
}

void GPE_TextAreaInputBasic::scroll_to_cursor()
{
    if( cursorYPos >= lineStartYPos && cursorYPos <= lineStartYPos+linesWithinView && cursorYPos < (int)listOfStrings.size() )
    {
        if( cursorXPos < lineStartXPos || cursorXPos > lineStartXPos+charactersWithinView)
        {
            scroll_to_pos(lineStartYPos,cursorXPos);
        }
        else
        {
            scroll_to_pos(lineStartYPos, lineStartXPos);
        }
    }
    else
    {
        if( cursorXPos < lineStartXPos ||  cursorXPos > lineStartXPos+charactersWithinView)
        {
            scroll_to_pos(cursorYPos,cursorXPos);
        }
        else
        {
            scroll_to_pos(cursorYPos, lineStartXPos);
        }
    }
}

void GPE_TextAreaInputBasic::scroll_to_selection()
{
    scroll_to_pos( selectionCursorYPos, selectionCursorXPos);
}

void GPE_TextAreaInputBasic::set_read_only()
{
    isReadOnly = true;
    textEditorButtonBar->set_height(0);
}

void GPE_TextAreaInputBasic::set_writeable()
{
    isReadOnly = true;
    textEditorButtonBar->set_height(32);
}

void GPE_TextAreaInputBasic::set_string(std::string newString)
{

}

void GPE_TextAreaInputBasic::set_placeholder(std::string newString)
{

}

void GPE_TextAreaInputBasic::set_xcursor(int newPos)
{
    cursorXPos = newPos;
    std::string cLine = listOfStrings[cursorYPos];
    if( cursorXPos < 0 || cursorXPos < (int)cLine.size() )
    {
        cursorXPos = 0;
    }
    showCursor = true;
    cursorTimer = 0;
}

void GPE_TextAreaInputBasic::set_ycursor(int newPos)
{
    if( newPos >=0 && newPos < (int)listOfStrings.size() )
    {
        cursorYPos = newPos;
        std::string cLine = listOfStrings.at(newPos);
        if( cursorXPos < 0 || cursorXPos < (int)cLine.size() )
        {
            cursorXPos = 0;
        }
    }
    else
    {
        cursorYPos = 0;
        cursorXPos = 0;
    }
    showCursor = true;
    cursorTimer = 0;
}

void GPE_TextAreaInputBasic::undo_edit()
{
    if( can_undo() )
    {
        int editId = currentPositionInHistory;
        /*
        if( undoableActionOccurred)
        {
            save_edit();
        }
        if( currentPositionInHistory > editId)
        {
            currentPositionInHistory--;
        }
        */
        GPE_TextAreaInputBasic * tempPlace = NULL;
        if( currentPositionInHistory-1 >=0 && currentPositionInHistory-1 < (int)savedHistory.size() )
        {
            tempPlace = savedHistory.at(currentPositionInHistory-1);
            if( tempPlace!=NULL)
            {
                copy_source(tempPlace,true);
                currentPositionInHistory--;
            }
        }
        else if( editId==(int)savedHistory.size() && (int)savedHistory.size()>0)
        {
            save_edit();
        }
        showCursor = true;
        cursorTimer = 0;
    }
}

void GPE_TextAreaInputBasic::update_cursor_to_mouse(SDL_Rect *viewedSpace, SDL_Rect *cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    find_mouse_cursor(&cursorXPos, &cursorYPos, viewedSpace, cam);
    lineToEdit = listOfStrings[cursorYPos];
    showCursor = true;
    cursorTimer = 0;
    adjust_fortabs();
}

bool GPE_TextAreaInputBasic::write_data_into_file(std::ofstream * fileTarget, int leftTabAmount, bool useNewLines, bool useLastNewLine )
{
    if( fileTarget!=NULL && leftTabAmount >=0)
    {
        std::string nestedTabsStr = generate_tabs( leftTabAmount  );
        if( fileTarget->is_open() )
        {
            int strSize = (int)listOfStrings.size();

            for( int i = 0; i < strSize-1; i++)
            {
                if( useNewLines)
                {
                    *fileTarget << nestedTabsStr+listOfStrings[i] << "\n";
                }
                else
                {
                    *fileTarget <<nestedTabsStr+listOfStrings[i] << " ";
                }
            }
            if( useNewLines)
            {
                if( useLastNewLine)
                {
                    *fileTarget << nestedTabsStr+listOfStrings[strSize-1] << "\n";
                }
                else
                {
                    *fileTarget << nestedTabsStr+listOfStrings[strSize-1];
                }
            }
            else
            {
                *fileTarget <<nestedTabsStr+listOfStrings[strSize-1] << " ";
            }
            return true;
        }
    }
    return false;
}

bool GPE_TextAreaInputBasic::write_short_data_into_file(std::ofstream * fileTarget, int leftTabAmount, bool useNewLines, bool useLastNewLine )
{
    if( fileTarget!=NULL && leftTabAmount >=0)
    {
        std::string nestedTabsStr = generate_tabs( leftTabAmount  );
        if( fileTarget->is_open() )
        {
            int strSize = (int)listOfStrings.size();
            std::string currentLineToExport = "";
            for( int i = 0; i < strSize-1; i++)
            {
                currentLineToExport= listOfStrings[i];
                if( (int)currentLineToExport.size() > 0)
                {
                    if( useNewLines)
                    {
                        *fileTarget << nestedTabsStr+currentLineToExport << "\n";
                    }
                    else
                    {
                        *fileTarget <<nestedTabsStr+currentLineToExport << " ";
                    }
                }
            }
            if( useNewLines)
            {
                if( useLastNewLine)
                {
                    *fileTarget << nestedTabsStr+listOfStrings[strSize-1] << "\n";
                }
                else
                {
                    *fileTarget << nestedTabsStr+listOfStrings[strSize-1];
                }
            }
            else
            {
                *fileTarget <<nestedTabsStr+listOfStrings[strSize-1] << " ";
            }
            return true;
        }
    }
    return false;
}

GPE_WrappedTextArea::GPE_WrappedTextArea()
{
    guiListTypeName = "wrappedtextarea";
    heldTextArea = new GPE_TextAreaInputBasic();
    heldTextArea->set_read_only();
    heldTextArea->isCodeEditor = false;
    barBox.w = 640;
    barBox.h = 480;
    paragraphText = "";
    hasLineBreak = true;
}

GPE_WrappedTextArea::~GPE_WrappedTextArea()
{
    if( heldTextArea!=NULL)
    {
        delete heldTextArea;
        heldTextArea = NULL;
    }
}

void GPE_WrappedTextArea::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam )
{
    heldTextArea->set_coords(barBox.x,barBox.y);
    heldTextArea->process_self(viewedSpace,cam);
}

void GPE_WrappedTextArea::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw )
{
    heldTextArea->set_coords(barBox.x,barBox.y);
    heldTextArea->render_self(cRender,viewedSpace,cam, forceRedraw);
}

void GPE_WrappedTextArea::set_string( std::string strIn)
{
    if( paragraphText!=strIn)
    {
        paragraphText = strIn;
        update_paragraph();
    }
}

void GPE_WrappedTextArea::set_width(int newWidth)
{
    if( barBox.w!=newWidth)
    {
        barBox.w = newWidth;
        heldTextArea->set_width( barBox.w );
        update_paragraph();
    }
}
void GPE_WrappedTextArea::set_height( int newHeight)
{
    if( barBox.h!=newHeight)
    {
        barBox.h = newHeight;
        heldTextArea->set_height( barBox.h );
        update_paragraph();
    }
}

void GPE_WrappedTextArea::set_max_width( int nMW)
{
    if( barBox.w!=nMW )
    {
        barBox.w = nMW;
        heldTextArea->set_width( barBox.w );
        update_paragraph();
    }
}

void GPE_WrappedTextArea::set_max_height( int nMH)
{
    if( barBox.h!=nMH )
    {
        barBox.h = nMH;
        heldTextArea->set_height( barBox.h );
        update_paragraph();
    }
}
void GPE_WrappedTextArea::update_paragraph(int foundMaxWidth )
{
    if( heldTextArea!=NULL && barBox.w > 0 )
    {
        heldTextArea->reset_self();
        heldTextArea->clear_all_lines();
        if( (int)paragraphText.size() > 0)
        {
            int maxMessageWidth = 0;
            //int maxMessageHeight = 0;
            int defaultFontWidth = 0;;
            int defaultFontHeight = 0;
            int iSubMessage = 0;
            if( FONT_TEXTINPUT!=NULL)
            {
                FONT_TEXTINPUT->get_metrics("A",&defaultFontWidth, &defaultFontHeight);
                FONT_TEXTINPUT->clear_cache();
            }

            std::vector < std::string > messageSubTitles;

            if( defaultFontWidth > 0 && defaultFontHeight > 0)
            {
                maxMessageWidth = ( barBox.w -GENERAL_GPE_PADDING)/ defaultFontWidth;

                if( (int)paragraphText.size() > 0)
                {
                    wrap_string(paragraphText,messageSubTitles,maxMessageWidth,-1);
                }

                maxMessageWidth = 0;
                if( messageSubTitles.size() <= 0)
                {
                    heldTextArea->add_line("");
                }
                else
                {
                    for( iSubMessage = 0; iSubMessage < (int)messageSubTitles.size(); iSubMessage++)
                    {
                        heldTextArea->add_line( messageSubTitles.at(iSubMessage) );
                    }
                }
            }
        }
        else
        {
            heldTextArea->add_line("");
        }
    }
}

GPE_CheckBoxBasic::GPE_CheckBoxBasic(std::string name, std::string descriptor, int xx, int yy, bool isChecked )
{
    guiListTypeName = "checkbox";
    guiListTypeId = 1;
    opName = name;
    descriptionText = descriptor;

    barBox.x = xx;
    barBox.y = yy;
    barBox.w = clickBoxW = 24;
    barBox.h = clickBoxH = 24;
    labelBoxW = 0;
    labelBoxH = 0;
    if( (int)opName.size()>0)
    {
        DEFAULT_FONT->get_metrics(opName,&labelBoxW, &labelBoxH);
        barBox.w+= labelBoxW;
    }

    isClicked = isChecked;
}

GPE_CheckBoxBasic::~GPE_CheckBoxBasic()
{

}

std::string GPE_CheckBoxBasic::get_data()
{
    return guiListTypeName+":"+opName+"==|||=="+int_to_string(isClicked);
}

void GPE_CheckBoxBasic::load_data(std::string dataString)
{
    isClicked = is_bool(dataString);
}


void GPE_CheckBoxBasic::prerender_self(GPE_Renderer * cRender )
{
    //barBox.w = clickBoxW;
    //barBox.h = clickBoxH;
}

void GPE_CheckBoxBasic::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    isHovered = false;
    if(viewedSpace!=NULL && cam!=NULL)
    {
        if( point_between(userInput->mouse_x,userInput->mouse_y,viewedSpace->x,viewedSpace->y,viewedSpace->x+viewedSpace->w,viewedSpace->y+viewedSpace->h) )
        {
            if (point_between(userInput->mouse_x,userInput->mouse_y,barBox.x+viewedSpace->x-cam->x,barBox.y+viewedSpace->y-cam->y,barBox.x+barBox.w+viewedSpace->x-cam->x,barBox.y+barBox.h+viewedSpace->y-cam->y) )
            {
                isHovered = true;
                if( isHovered)
                {
                    GPE_MAIN_GUI->update_tooltip(descriptionText);
                    if( userInput->check_mouse_released(0) )
                    {
                        isClicked = !isClicked;
                        isInUse = true;
                    }
                }
            }
            else if( userInput->check_mouse_released(-1) )
            {
                isInUse = false;
            }
        }
        else if( userInput->check_mouse_released(-1) )
        {
            isInUse = false;
        }
        if( (isInUse || isHovered ) &&( userInput->check_keyboard_pressed( kb_enter ) || userInput->check_keyboard_pressed( kb_space )  ) )
        {
            isClicked = !isClicked;
        }

    }
}

void GPE_CheckBoxBasic::render_self(GPE_Renderer * cRender, SDL_Rect *viewedSpace, SDL_Rect *cam, bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( cam!=NULL && forceRedraw )
    {
        if( isInUse)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+clickBoxW-cam->x,barBox.y+clickBoxH-cam->y,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,false);
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+clickBoxW-cam->x,barBox.y+clickBoxH-cam->y,GPE_MAIN_TEMPLATE->Button_Border_Highlighted_Color,true);
        }
        else if( isHovered)
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+clickBoxW-cam->x,barBox.y+clickBoxH-cam->y,GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,false);
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+clickBoxW-cam->x,barBox.y+clickBoxH-cam->y,GPE_MAIN_TEMPLATE->Button_Border_Highlighted_Color,true);
        }
        else
        {
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+clickBoxW-cam->x,barBox.y+clickBoxH-cam->y,GPE_MAIN_TEMPLATE->Main_Border_Color,false);
            render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+clickBoxW-cam->x,barBox.y+clickBoxH-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,true);
        }
        if( isClicked)
        {
            render_texture_resized(cRender, GPE_CHECKMARK_IMAGE, barBox.x-cam->x,barBox.y-cam->y,clickBoxW,clickBoxH,NULL,NULL,-1,-1,GPE_MAIN_TEMPLATE->Checkbox_Color);
        }
        render_new_text(cRender,barBox.x+clickBoxW+GENERAL_GPE_PADDING-cam->x,barBox.y+barBox.h-cam->y,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_CHECKBOX,FA_LEFT,FA_BOTTOM,255);
    }
}

void GPE_CheckBoxBasic::set_checkbox_size(int nBoxSize, bool resizeBarBox)
{
    if( resizeBarBox)
    {
        barBox.w = nBoxSize+labelBoxW;
    }
    labelBoxW = labelBoxH = nBoxSize;
}

GPE_RadioButtonControllerBasic::GPE_RadioButtonControllerBasic(std::string cName, int cX, int cY, bool alphabetize, int colNum)
{
    guiListTypeName = "radio";
    guiListTypeId = 5;
    hoveredOption = -1;
    selectedId = 0;
    opName = cName;
    barBox.x = cX;
    barBox.y = cY;
    barBox.w = 0;
    barBox.h = 32;
    opWidth = barBox.w;
    opHeight = barBox.h;

    if( (int)opName.size()>0)
    {
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(opName,&textW, &textH);
        opWidth = textW;
        if( barBox.w < textW )
        {
            barBox.w = textW+GENERAL_GPE_PADDING*2;
        }
    }
    allowDuplicates = false;
    keepAlphabetized = alphabetize;
    numCols = std::max(0,colNum);
    rowsPerCol = -1;
}

GPE_RadioButtonControllerBasic::~GPE_RadioButtonControllerBasic()
{
    GPE_KeyPair * kp = NULL;
    for( int i = subOptions.size()-1; i >=0; i--)
    {
        kp = subOptions[i];
        if( kp!=NULL )
        {
            delete kp;
            kp = NULL;
        }
    }
    subOptions.clear();
}


std::string GPE_RadioButtonControllerBasic::get_data()
{
    std::string dataString = guiListTypeName+":"+opName+"==|||==[menu]";
    GPE_KeyPair * tPair = NULL;
    for( int i = 0; i < (int)subOptions.size(); i++ )
    {
        tPair = subOptions[i];
        if( tPair!=NULL)
        {
            dataString+="[option]"+tPair->keyString+":"+tPair->keySubString+":"+int_to_string(tPair->keyValue)+"[/option]";
        }
    }
    dataString+="[/menu]"+int_to_string(selectedId)+",";
    return dataString;
}

void GPE_RadioButtonControllerBasic::load_data(std::string dataString)
{
    if( (int)dataString.size() > 0 )
    {
        std::string optionTag = "[option]";
        int optionTagSize = (int)optionTag.size();

        std::string allOptionsString = "";
        std::string newOptionData = "";
        std::string newOptionString = "";
        std::string newOptionName = "";
        std::string newOptionSubame = "";
        int newOptionId = -1;
        int beginOptionPos=dataString.find_first_of(optionTag);
        if(beginOptionPos!=(int)std::string::npos)
        {
            allOptionsString = split_first_string(dataString,"[/menu]");

            newOptionData = split_first_string(allOptionsString,"[menu]");
            while( (int)allOptionsString.size() > 0)
            {
                newOptionString = split_first_string(allOptionsString,"[/option]");

                beginOptionPos=newOptionString.find_first_of(optionTag);
                if(beginOptionPos!=(int)std::string::npos)
                {
                    //if the beginOptionPos is present, then parse on through and carryon
                    if( (int)newOptionString.size() > beginOptionPos+optionTagSize )
                    {
                        newOptionData = get_substring(newOptionString, beginOptionPos+optionTagSize );

                        newOptionName = split_first_string(newOptionData,":");
                        newOptionSubame = split_first_string(newOptionData,":");
                        newOptionId = string_to_int(newOptionData,-1);
                        if( (int)newOptionName.size() > 0)
                        {
                            add_menu_option(newOptionName,newOptionSubame,newOptionId,false);
                        }
                    }
                    else
                    {
                        return;
                    }
                }
            }
            set_selection( split_first_int(dataString,',') );
            //showJustOptions = is_bool( split_first_string(dataString,",") );
        }
    }
}

void GPE_RadioButtonControllerBasic::remove_data(std::string dataString)
{
    if( (int)dataString.size() > 0)
    {
        std::string optionTag = "[option]";
        int optionTagSize = (int)optionTag.size();

        std::string newOptionData = "";
        std::string newOptionString = "";
        std::string foundOptionName = "";
        int beginOptionPos = -1;
        while( (int)dataString.size() > 0)
        {
            newOptionString = split_first_string(dataString,"[/option]");

            beginOptionPos=newOptionString.find_first_of(optionTag);
            if(beginOptionPos!=(int)std::string::npos)
            {
                //if the beginOptionPos is present, then parse on through and carryon
                foundOptionName = newOptionString.substr(beginOptionPos+optionTagSize,newOptionString.length());
                if( (int)foundOptionName.size() > 0)
                {
                    remove_option(foundOptionName);
                }
            }
        }
    }
}

void GPE_RadioButtonControllerBasic::add_opton(std::string newOption)
{
    if( (int)newOption.size()>0 )
    {
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(newOption,&textW, &textH);
        if( opWidth < textW )
        {
            opWidth = textW;
            barBox.w = textW+GENERAL_GPE_PADDING*2;
            //newTex->loadFromRenderedText(MAIN_RENDERER,newOption,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT);
        }
        GPE_KeyPair * kp = NULL;
        GPE_KeyPair * newOptionPair = new GPE_KeyPair(-1,newOption,newOption);
        if(keepAlphabetized)
        {
            std::string fString = "";
            bool isInserted = false;
            if( rowsPerCol>0)
            for(int i=0; i< (int)subOptions.size() && !isInserted; i++)
            {
                kp = subOptions[i];
                if( kp!=NULL)
                {
                    fString = kp->keyString;
                    if( fString > newOption && !isInserted )
                    {
                        subOptions.insert( subOptions.begin()+i,newOptionPair);
                        isInserted = true;
                        organize_options();
                        return;
                    }
                }
            }
        }
        subOptions.push_back(newOptionPair);
        barBox.h +=32;
        organize_options();
    }
}

void GPE_RadioButtonControllerBasic::add_menu_option(std::string optionName, std::string optionSubStr,int optionValue, bool selectOption)
{
    if( (int)optionName.size()>0 )
    {
        int textW = 0;
        int textH = 0;
        DEFAULT_FONT->get_metrics(optionName,&textW, &textH);
        if( opWidth < textW )
        {
            opWidth = textW;
            barBox.w = textW+GENERAL_GPE_PADDING*2;
            //newTex->loadFromRenderedText(MAIN_RENDERER,optionName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT);
        }
        bool optionExists = false;
        GPE_KeyPair * tOption = NULL;
        for( int i = 0; i < (int)subOptions.size(); i++)
        {
            tOption = subOptions[i];
            if( tOption!=NULL )
            {
                if( tOption->keyString==optionName)
                {
                    optionExists = false;
                    return;
                }
            }
        }
        if( !optionExists)
        {
            GPE_KeyPair * kp = new GPE_KeyPair(optionValue,optionName,optionSubStr);
            subOptions.push_back(kp);
            if( selectOption )
            {
                set_selection( (int)subOptions.size()-1 );
            }
            barBox.h +=32;
            organize_options();
        }
    }
}

std::string GPE_RadioButtonControllerBasic::get_menu_option(int atNumb)
{
    GPE_KeyPair * kp = NULL;
    if( atNumb >=0 && atNumb < (int)subOptions.size() )
    {
        kp = subOptions.at(atNumb);
        if( kp!=NULL)
        {
            return kp->keyString;
        }
    }
    return "";
}

std::string GPE_RadioButtonControllerBasic::get_plain_string()
{
    GPE_KeyPair * kp = NULL;
    if( selectedId >=0 && selectedId < (int)subOptions.size() )
    {
        kp = subOptions[selectedId];
        if( kp!=NULL)
        {
            return "'"+kp->keyString+"'";
        }
    }
    return "''";
}

int GPE_RadioButtonControllerBasic::get_selected_id()
{
    return selectedId;
}

std::string GPE_RadioButtonControllerBasic::get_selected_tag()
{
    GPE_KeyPair * kp = NULL;
    if( selectedId >=0 && selectedId < (int)subOptions.size() )
    {
        kp = subOptions[selectedId];
        return kp->keySubString;
    }
    return "";
}

int GPE_RadioButtonControllerBasic::get_selected_value()
{
    GPE_KeyPair * kp = NULL;
    if( selectedId >=0 && selectedId < (int)subOptions.size() )
    {
        kp = subOptions[selectedId];
        return kp->keyValue;
    }
    return 0;
}

void GPE_RadioButtonControllerBasic::organize_options()
{
    barBox.w = GENERAL_GPE_PADDING*2;
    barBox.h = 32;
    int maxWidthText = 0;
    int textW = 0;
    int textH = 0;
    if( (int)opName.size()>0)
    {
        textW = 0;
        textH = 0;
        DEFAULT_FONT->get_metrics(opName,&textW, &textH);
        opWidth = textW;
        maxWidthText = textW;
        barBox.w += maxWidthText;
    }

    std::string opStr = "";
    GPE_KeyPair * tPair = NULL;
    if( numCols<=1)
    {
        for(int i =0; i < (int)subOptions.size(); i++)
        {
            tPair = subOptions[i];
            if( tPair!=NULL)
            {
                opStr = tPair->keyString;
                if( (int)opStr.size() > 0)
                {
                    textW = 0;
                    textH = 0;
                    DEFAULT_FONT->get_metrics(opStr,&textW, &textH);
                    if( maxWidthText < textW )
                    {
                        maxWidthText = textW;
                    }
                }
                barBox.h+=32;
            }
        }
        barBox.w+=maxWidthText;
    }
}

void GPE_RadioButtonControllerBasic::remove_option(std::string optionToCut)
{
    if( (int)subOptions.size()>0 )
    {
        int removePos = -1;
        GPE_KeyPair * kp = NULL;
        for(int i=(int)subOptions.size()-1; i>=0 && removePos < 0; i--)
        {
            kp = subOptions[i];
            if( kp!=NULL)
            {
                if(  kp->keyString == optionToCut)
                {
                    delete kp;
                    kp = NULL;
                    subOptions.erase(subOptions.begin()+i);
                    if( i==selectedId)
                    {
                        i = -1;
                    }
                    else if( selectedId > i)
                    {
                        selectedId-=1;
                    }
                    removePos = i;
                    barBox.h -=32;
                }
            }
        }
    }
}

void GPE_RadioButtonControllerBasic::remove_option_id(int optionToCut)
{
    if( (int)subOptions.size()>0 )
    {
        if(optionToCut >=0 && optionToCut < (int)subOptions.size() )
        {
            GPE_KeyPair * kp = subOptions.at( optionToCut );
            if( kp!=NULL)
            {
                delete kp;
                kp = NULL;
            }
            subOptions.erase(subOptions.begin()+optionToCut);
            if( optionToCut==selectedId)
            {
                optionToCut = -1;
            }
            else if( selectedId > optionToCut)
            {
                selectedId-=1;
            }
            barBox.h -=32;
        }
    }
}

void GPE_RadioButtonControllerBasic::set_selection(int newSelection)
{
    if( newSelection>=0 && newSelection < (int)subOptions.size() )
    {
        selectedId = newSelection;
    }
}

bool GPE_RadioButtonControllerBasic::set_from_tag(std::string newSelectedTag)
{
    GPE_KeyPair * tempPair = NULL;
    for( int i = (int)(subOptions.size())-1;i >=0; i--)
    {
        tempPair = subOptions[i];
        if( tempPair!=NULL)
        {
            if( tempPair->keySubString == newSelectedTag)
            {
                selectedId = i;
                return true;
            }
        }
    }
    return false;
}

void GPE_RadioButtonControllerBasic::set_value(int valueToSelect)
{
    GPE_KeyPair * tempPair = NULL;
    for( int i = (int)subOptions.size()-1; i>=0; i--)
    {
        tempPair = subOptions[i];
        if( tempPair!=NULL)
        {
            if( tempPair->keyValue==valueToSelect)
            {
                selectedId = i;
                break;
            }
        }
    }
}

void GPE_RadioButtonControllerBasic::prerender_self(GPE_Renderer * cRender )
{

}

void GPE_RadioButtonControllerBasic::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam )
{
    cam = GPE_find_camera(cam);
    viewedSpace = GPE_find_camera(viewedSpace);
    if( cam!=NULL && viewedSpace!=NULL)
    {
        int buttonXPos = barBox.x+viewedSpace->x+16-cam->x;
        int buttonYPos = barBox.y+viewedSpace->y+32-cam->y;
        GPE_GeneralGuiElement::process_self(viewedSpace,cam);
        bool selectionClicked = false;
        if( isInUse)
        {
            hasArrowkeyControl = true;
        }
        else
        {
            hasArrowkeyControl = false;
        }
        //currently only handles single columns
        if( numCols<=1)
        {
            for(int i = 0; i  < (int)subOptions.size(); i++)
            {
                if(point_between( userInput->mouse_x,userInput->mouse_y,buttonXPos,buttonYPos,buttonXPos+32,buttonYPos+32) )
                {
                    hoveredOption = i;
                    if( userInput->check_mouse_released(0) )
                    {
                        selectedId = i;
                        selectionClicked = true;
                    }
                }
                buttonYPos+=32;
            }
            if( hasArrowkeyControl && isInUse )
            {
                if( userInput->check_keyboard_down(kb_left) || userInput->check_keyboard_down(kb_up) )
                {
                    selectedId--;
                }
                if( userInput->check_keyboard_down(kb_right) || userInput->check_keyboard_down(kb_down) )
                {
                    selectedId++;
                }
                if( selectedId >=(int)subOptions.size() )
                {
                    selectedId =(int)subOptions.size()-1;
                }
                if( selectedId < 0)
                {
                    selectedId = 0;
                }
            }
        }
        else
        {

        }
        if( isClicked && !selectionClicked)
        {
            hasArrowkeyControl = true;
        }
    }
}

void GPE_RadioButtonControllerBasic::render_self(GPE_Renderer * cRender , SDL_Rect * viewedSpace, SDL_Rect *cam ,bool forceRedraw )
{
    if( forceRedraw )
    {
        viewedSpace = GPE_find_camera(viewedSpace);
        cam = GPE_find_camera(cam);
        if( viewedSpace!=NULL && cam!=NULL)
        {
            int buttonXPos = barBox.x-cam->x;
            int buttonYPos = barBox.y-cam->y;
            if(showBorderBox)
            {
                if((int)opName.size()>0 )
                {
                    render_line(cRender,buttonXPos,buttonYPos+GPE_TITLE_BPADDING,buttonXPos+GPE_TITLE_BPADDING,buttonYPos+GPE_TITLE_BPADDING,GPE_MAIN_TEMPLATE->Button_Box_Color,255);
                    render_line(cRender,buttonXPos+GPE_TITLE_BPADDING*2+opWidth,buttonYPos+GPE_TITLE_BPADDING,
                                buttonXPos+barBox.w,buttonYPos+GPE_TITLE_BPADDING,GPE_MAIN_TEMPLATE->Button_Box_Color,255);

                    render_line(cRender,buttonXPos,buttonYPos+GPE_TITLE_BPADDING,buttonXPos,buttonYPos+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Color,255);
                    render_line(cRender,buttonXPos,buttonYPos+barBox.h,buttonXPos+barBox.w,buttonYPos+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Color,255);
                    render_line(cRender,buttonXPos+barBox.w,buttonYPos+GPE_TITLE_BPADDING,buttonXPos+barBox.w,buttonYPos+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Color,255);
                    render_new_text(cRender, buttonXPos+GPE_TITLE_BPADDING*1.5,buttonYPos+GPE_TITLE_BPADDING/2,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP,255);
                }
                else
                {
                    render_rectangle(cRender,buttonXPos,buttonYPos,buttonXPos+barBox.w,buttonYPos+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Color,255);
                }
                buttonXPos += 16;
                buttonYPos += 32;
                int renderedInCol = 0;

                GPE_KeyPair * kp = NULL;
                for(int i = 0; i  < (int)subOptions.size(); i++)
                {
                    if( i == hoveredOption )
                    {
                        render_sprite_resized(cRender, GPE_RadioButton_GFX,1, buttonXPos,buttonYPos, 16,16,NULL,NULL);
                    }
                    else
                    {
                        render_sprite_resized(cRender, GPE_RadioButton_GFX, 0,buttonXPos,buttonYPos, 16,16,NULL,NULL);
                    }
                    if( i == selectedId )
                    {
                        render_sprite_resized(cRender, GPE_RadioButton_GFX, 2, buttonXPos,buttonYPos, 16,16,NULL,NULL);
                    }
                    kp = subOptions[i];
                    if( kp!=NULL)
                    {
                        render_new_text(cRender, buttonXPos+32,buttonYPos,kp->keyString,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP,255);
                    }
                    buttonYPos+=32;
                    renderedInCol+=1;
                    /*
                    if( rowsPerCol>0 && numCols>1 )
                    {
                        if(renderedInCol > rowsPerCol)
                        {
                            renderedInCol = 0;
                            buttonXPos+=160; //will be changed later from constant
                            buttonYPos = barBox.y+32;
                        }
                    }
                    */
                }
            }
            if( isInUse)
            {
                render_rectangle(cRender,barBox.x-cam->x,barBox.y-cam->y,barBox.x+barBox.w-cam->x,barBox.y+barBox.h-cam->y,GPE_MAIN_TEMPLATE->Main_Box_Font_URL_Color,true);
            }
        }
    }
}

GPE_Template::GPE_Template()
{
    templateLocalLocation = "default.gpf";
    //sprites
     Main_Menu_Sprite = NULL;
    //For icons and Folders
    Main_Folder_Color = new GPE_Color(1,86,231);
    Main_Folder_Highlighted_Color = new GPE_Color(181,95,62);
    //for bg and standard colors
    Program_Color = new GPE_Color(32,32,32);
    Program_Header_Color = new GPE_Color(62,62,62);

    //For input fields and drop down-related menus
    Input_Highlight_Color = Main_Folder_Color->duplicate_color();
    Input_Highlight_Outline_Color = Main_Folder_Color->duplicate_color();
    Input_Highlight_Alt_Color = new GPE_Color(218,140,16);

    Input_Color = new GPE_Color(27,27,29);
    Input_Error_Box_Color = new GPE_Color(255,29,29);
    Input_Outline_Color = c_ltgray->duplicate_color();
    Input_Font_Color = c_ltgray->duplicate_color();
    Input_Faded_Font_Color = c_gray->duplicate_color();
    Input_Selected_Color = c_olive->duplicate_color();
    Input_Highlight_Font_Color = c_blgray->duplicate_color();
    Input_Error_Font_Color = new GPE_Color(228,8,8);
    Input_Error_Outline_Color = c_maroon->duplicate_color();

    //Used mainly for labels, urls and such
    Checkbox_Color = new GPE_Color(1,86,231);

    //Button colors and such
    Button_Box_Color = new GPE_Color(25,25,25);
    Button_Font_Color = new GPE_Color(249,249,249);
    Button_Font_Highlighted_Color = new GPE_Color(240,240,240);
    Button_Border_Color = new GPE_Color(16,16,16);
    Button_Box_Highlighted_Color = new GPE_Color(40,40,40);
    Button_Box_Selected_Color = new GPE_Color(96,96,96);
    Button_Border_Color = c_dkgray->duplicate_color();
    Button_Border_Highlighted_Color = c_blgray->duplicate_color();
    Button_Border_Selected_Color = c_ltgray->duplicate_color();

    //IconButton colors and such
    Icon_Box_Color = new GPE_Color(25,25,25);
    Icon_Font_Color = new GPE_Color(224,224,224);
    Icon_Font_Highlighted_Color = new GPE_Color(255,255,255);
    Icon_Font_Selected_Color = new GPE_Color(235,235,235);
    Icon_Border_Color = new GPE_Color(16,16,16);
    Icon_Box_Highlighted_Color = new GPE_Color(40,40,40);
    Icon_Box_Selected_Color = new GPE_Color(96,96,96);
    Icon_Border_Color = c_ltgray->duplicate_color();
    Icon_Border_Highlighted_Color = c_blgray->duplicate_color();
    Icon_Border_Selected_Color = new GPE_Color(235, 235, 235);

    Main_Box_Color = new GPE_Color(16,16,16);
    Main_Box_Highlighted_Color = new GPE_Color(24,24,24);
    Main_Box_Faded_Color = new GPE_Color(32,32,32);
    Main_Border_Color = new GPE_Color(27,27,29);
    Main_Border_Highlighted_Color = new GPE_Color( 64,32,250 );
    Main_Box_Font_Color = c_white->duplicate_color();
    Main_Box_Font_URL_Color = new GPE_Color(115,161,196);
    Main_Box_Font_URL_Visited_Color = new GPE_Color(179,204,223);
    Main_Box_Font_Highlight_Color = c_white->duplicate_color();
    Main_Box_Faded_Font_Color = c_ltgray->duplicate_color();



    //for pop up boxes like toolbar options, context menu, tool tip, etc. Essentially top Z-layer
    PopUp_Box_Highlight_Color = new GPE_Color(0,0,220);
    PopUp_Box_Highlight_Alt_Color = new GPE_Color(0,220,0);
    PopUp_Box_Close_Color = c_red->duplicate_color();
    PopUp_Box_Close_Font_Color = c_white->duplicate_color();
    PopUp_Box_Close_Hightlight_Color = c_maroon->duplicate_color();

    PopUp_Box_Color =  new GPE_Color(35,35,35);
    PopUp_Box_Border_Color = c_blgray->duplicate_color();
    PopUp_Box_Font_Color = c_silver->duplicate_color();
    PopUp_Box_Highlight_Font_Color = c_ltgray->duplicate_color();
    PopUp_Box_Faded_Font_Color = c_gray->duplicate_color();

    //For Scroll Boxes
    Scroll_Box_Color = new GPE_Color(55,55,55);
    Scroll_Box_Border_Color = new GPE_Color(0,0,0);
    Scroll_Box_Arrow_Color = new GPE_Color(245, 245, 245);
    Scroll_Box_Camera_Color = new GPE_Color(85, 85, 85);
    Scroll_Box_Camera_Highlight_Color = new GPE_Color(128, 128, 128);

    //for text boxes
    Text_Box_Outer_Color = c_blgray->duplicate_color();
    Text_Box_Outer_Font_Color = c_ltgray->duplicate_color();
    Text_Box_Color = c_alblack->duplicate_color();
    Text_Box_Outline_Color = c_jetblack->duplicate_color();
    Text_Box_Highlight_Color = new GPE_Color(50,35,50);
    Text_Box_Font_Color = c_ltgray->duplicate_color();
    Text_Box_Font_Highlight_Color = c_ltgray->duplicate_color();
    Text_Box_Font_Comment_Color = c_lime->duplicate_color();

    Text_Box_Font_DataType_Color = c_ltpurple->duplicate_color();
    Text_Box_Font_DQuote_Color = c_yellow->duplicate_color();
    Text_Box_Font_Function_Color = c_teal->duplicate_color();
    Text_Box_Font_Function_Alt_Color = c_lime->duplicate_color();
    Text_Box_Font_Keyword_Color = c_ltblue->duplicate_color();
    Text_Box_Font_Variable_Color = new GPE_Color(183,183,255);
    Text_Box_Font_Variable_Alt_Color = new GPE_Color(183,255,183);

    Text_Box_Font_Keyword_Alt_Color = c_green->duplicate_color();
    Text_Box_Font_JavaScript_Color = c_violet->duplicate_color();
    Text_Box_Font_JavaScript_Alt_Color = c_violet->duplicate_color();
    Text_Box_Font_Number_Color = c_fuchsia->duplicate_color();
    Text_Box_Font_SQuote_Color = c_aqua->duplicate_color();
    Text_Box_Font_Symbols_Color = new GPE_Color(255,99,71);

    //Project Variables
    Text_Box_Project_Function_Color = new GPE_Color(135,206,250);
    Text_Box_Project_Function_Alt_Color = new GPE_Color(206,135,250);



    Text_Box_Project_Keyword_Color = new GPE_Color(218,140,16);
    Text_Box_Project_Keyword_Alt_Color = new GPE_Color(50,35,150);
    //for errors
    Main_Error_Font_Color = c_maroon->duplicate_color();
    Main_Warning_Font_Color = c_blue->duplicate_color();
    Main_Suggestion_Font_Color = c_aqua->duplicate_color();

}

GPE_Template::~GPE_Template()
{
    if( Program_Color!=NULL)
    {
        delete Program_Color;
        Program_Color = NULL;
    }
    if( Program_Header_Color!=NULL)
    {
        delete Program_Header_Color;
        Program_Header_Color = NULL;
    }
    if( Main_Folder_Color!=NULL)
    {
        delete Main_Folder_Color;
        Main_Folder_Color = NULL;
    }
    if( Main_Folder_Highlighted_Color!=NULL)
    {
        delete Main_Folder_Highlighted_Color;
        Main_Folder_Highlighted_Color = NULL;
    }

    //For Input Fields, Drop Down Menus & Resource Drop Downs
    if( Input_Highlight_Color!=NULL)
    {
        delete Input_Highlight_Color;
        Input_Highlight_Color = NULL;
    }
    if( Input_Highlight_Outline_Color!=NULL)
    {
        delete Input_Highlight_Outline_Color;
        Input_Highlight_Outline_Color = NULL;
    }
    if( Input_Highlight_Alt_Color!=NULL)
    {
        delete Input_Highlight_Alt_Color;
        Input_Highlight_Alt_Color = NULL;
    }
    if( Input_Color!=NULL)
    {
        delete Input_Color;
        Input_Color = NULL;
    }
    if( Input_Error_Font_Color!=NULL)
    {
        delete Input_Error_Font_Color;
        Input_Error_Font_Color = NULL;
    }
    if( Input_Error_Box_Color!=NULL)
    {
        delete Input_Error_Box_Color;
        Input_Error_Box_Color = NULL;
    }
    if( Input_Error_Outline_Color!=NULL)
    {
        delete Input_Error_Outline_Color;
        Input_Error_Outline_Color = NULL;
    }
    if( Input_Outline_Color!=NULL)
    {
        delete Input_Outline_Color;
        Input_Outline_Color = NULL;
    }
    if( Input_Font_Color!=NULL)
    {
        delete Input_Font_Color;
        Input_Font_Color = NULL;
    }
    if( Input_Highlight_Font_Color!=NULL)
    {
        delete Input_Highlight_Font_Color;
        Input_Highlight_Font_Color = NULL;
    }
    if( Input_Faded_Font_Color!=NULL)
    {
        delete Input_Faded_Font_Color;
        Input_Faded_Font_Color = NULL;
    }
    if( Input_Selected_Color!=NULL)
    {
        delete Input_Selected_Color;
        Input_Selected_Color = NULL;
    }
        //For Gui boxes, like main menu, toolbar and oontext menus
        if( Checkbox_Color!=NULL)
        {
            delete Checkbox_Color;
            Checkbox_Color = NULL;
        }

        if( Button_Box_Highlighted_Color!=NULL)
        {
            delete Button_Box_Highlighted_Color;
            Button_Box_Highlighted_Color = NULL;
        }

        if( Button_Border_Highlighted_Color!=NULL)
        {
            delete Button_Border_Highlighted_Color;
            Button_Border_Highlighted_Color = NULL;
        }

        if( Button_Box_Selected_Color!=NULL)
        {
            delete Button_Box_Selected_Color;
            Button_Box_Selected_Color = NULL;
        }

        if( Main_Box_Faded_Color!=NULL)
        {
            delete Main_Box_Faded_Color;
            Main_Box_Faded_Color = NULL;
        }

        if( Main_Border_Color!=NULL)
        {
            delete Main_Border_Color;
            Main_Border_Color = NULL;
        }

        if( Main_Box_Font_Color!=NULL)
        {
            delete Main_Box_Font_Color;
            Main_Box_Font_Color = NULL;
        }

        if( Main_Box_Font_URL_Color!=NULL)
        {
            delete Main_Box_Font_URL_Color;
            Main_Box_Font_URL_Color = NULL;
        }

        if( Main_Box_Font_URL_Visited_Color!=NULL)
        {
            delete Main_Box_Font_URL_Visited_Color;
            Main_Box_Font_URL_Visited_Color = NULL;
        }

        if( Main_Box_Font_Highlight_Color!=NULL)
        {
            delete Main_Box_Font_Highlight_Color;
            Main_Box_Font_Highlight_Color = NULL;
        }

        if( Main_Box_Faded_Font_Color!=NULL)
        {
            delete Main_Box_Faded_Font_Color;
            Main_Box_Faded_Font_Color = NULL;
        }

        //For Gui boxes, like main menu, toolbar and oontext menus

        if( PopUp_Box_Highlight_Color!=NULL)
        {
            delete PopUp_Box_Highlight_Color;
            PopUp_Box_Highlight_Color = NULL;
        }

        if( PopUp_Box_Highlight_Alt_Color!=NULL)
        {
            delete PopUp_Box_Highlight_Alt_Color;
            PopUp_Box_Highlight_Alt_Color = NULL;
        }

        if( PopUp_Box_Close_Color!=NULL)
        {
            delete PopUp_Box_Close_Color;
            PopUp_Box_Close_Color = NULL;
        }

        if( PopUp_Box_Close_Hightlight_Color!=NULL)
        {
            delete PopUp_Box_Close_Hightlight_Color;
            PopUp_Box_Close_Hightlight_Color = NULL;
        }


        if( PopUp_Box_Close_Font_Color!=NULL)
        {
            delete PopUp_Box_Close_Font_Color;
            PopUp_Box_Close_Font_Color = NULL;
        }


        if( PopUp_Box_Color!=NULL)
        {
            delete PopUp_Box_Color;
            PopUp_Box_Color = NULL;
        }


        if( PopUp_Box_Border_Color!=NULL)
        {
            delete PopUp_Box_Border_Color;
            PopUp_Box_Border_Color = NULL;
        }


        if( PopUp_Box_Font_Color!=NULL)
        {
            delete PopUp_Box_Font_Color;
            PopUp_Box_Font_Color = NULL;
        }


        if( PopUp_Box_Highlight_Font_Color!=NULL)
        {
            delete PopUp_Box_Highlight_Font_Color;
            PopUp_Box_Highlight_Font_Color = NULL;
        }


        if( PopUp_Box_Faded_Font_Color!=NULL)
        {
            delete PopUp_Box_Faded_Font_Color;
            PopUp_Box_Faded_Font_Color = NULL;
        }
        //for text boxes
        if( Text_Box_Outer_Color!=NULL)
        {
            delete Text_Box_Outer_Color;
            Text_Box_Outer_Color = NULL;
        }
        if( Text_Box_Outer_Font_Color!=NULL)
        {
            delete Text_Box_Outer_Font_Color;
            Text_Box_Outer_Font_Color = NULL;
        }
        if( Text_Box_Color!=NULL)
        {
            delete Text_Box_Color;
            Text_Box_Color = NULL;
        }
        if( Text_Box_Outline_Color!=NULL)
        {
            delete Text_Box_Outline_Color;
            Text_Box_Outline_Color = NULL;
        }
        if( Text_Box_Highlight_Color!=NULL)
        {
            delete Text_Box_Highlight_Color;
            Text_Box_Highlight_Color = NULL;
        }
        if( Text_Box_Font_Color!=NULL)
        {
            delete Text_Box_Font_Color;
            Text_Box_Font_Color = NULL;
        }
        if( Text_Box_Font_Comment_Color!=NULL)
        {
            delete Text_Box_Font_Comment_Color;
            Text_Box_Font_Comment_Color = NULL;
        }
        if( Text_Box_Font_Highlight_Color!=NULL)
        {
            delete Text_Box_Font_Highlight_Color;
            Text_Box_Font_Highlight_Color = NULL;
        }

        delete Text_Box_Font_DataType_Color;
        delete Text_Box_Font_DQuote_Color;
        delete Text_Box_Font_Function_Color;
        delete Text_Box_Font_Function_Alt_Color;
        delete Text_Box_Font_Keyword_Color;
        delete Text_Box_Font_Keyword_Alt_Color;
        delete Text_Box_Font_JavaScript_Color;
        delete Text_Box_Font_JavaScript_Alt_Color;
        delete Text_Box_Font_Number_Color;
        delete Text_Box_Font_SQuote_Color;
        delete Text_Box_Font_Symbols_Color;

        if( Text_Box_Project_Function_Color!=NULL )
        {
            delete Text_Box_Project_Function_Color;
            Text_Box_Project_Function_Color = NULL;
        }

        if( Text_Box_Project_Function_Alt_Color!=NULL )
        {
            delete Text_Box_Project_Function_Alt_Color;
            Text_Box_Project_Function_Alt_Color = NULL;
        }

        if( Text_Box_Project_Keyword_Color!=NULL )
        {
            delete Text_Box_Project_Keyword_Color;
            Text_Box_Project_Keyword_Color = NULL;
        }

        if( Text_Box_Project_Keyword_Alt_Color!=NULL )
        {
            delete Text_Box_Project_Keyword_Alt_Color;
            Text_Box_Project_Keyword_Alt_Color = NULL;
        }
        //for errors
        if( Main_Error_Font_Color!=NULL)
        {
            delete Main_Error_Font_Color;
            Main_Error_Font_Color = NULL;
        }
        if( Main_Warning_Font_Color!=NULL)
        {
            delete Main_Warning_Font_Color;
            Main_Warning_Font_Color = NULL;
        }
        if( Main_Suggestion_Font_Color!=NULL)
        {
            delete Main_Suggestion_Font_Color;
            Main_Suggestion_Font_Color = NULL;
        }
}

void GPE_Template::load_theme(std::string themeLocationIn)
{
    //If the level file could be loaded
    std::string themeGlobalLocation = APP_DIRECTORY_NAME+"themes/"+themeLocationIn;
    if( file_exists(themeGlobalLocation) )
    {
        std::ifstream templateFileIn( themeGlobalLocation.c_str() );
        if( !templateFileIn.fail() )
        {
            //makes sure the file is open
            if (templateFileIn.is_open())
            {
                templateLocalLocation = themeLocationIn;
                int equalPos = 0;
                int hashPos = 0;
                std::string firstChar="";
                std::string section="";
                std::string cur_layer="";
                std::string data_format="";
                std::string keyString="";
                std::string valString="";
                std::string subValString="";
                std::string currLine="";
                std::string currLineToBeProcessed;
                //float foundFileVersion = 0;

                int rFound = 0, gFound = 0, bFound = 0;
                while ( templateFileIn.good() )
                {
                    getline (templateFileIn,currLine); //gets the next line of the file
                    currLineToBeProcessed = trim_left_inplace(currLine);
                    currLineToBeProcessed = trim_right_inplace(currLine);
                    //Empty Line skipping is only allowed at the top of the file
                    if(!currLineToBeProcessed.empty() )
                    {
                        //Comment skipping is only allowed at the top of the file
                        if( currLineToBeProcessed[0]!= '#' && currLineToBeProcessed[0]!='/'  )
                        {
                            //searches for an equal character and parses through the variable
                            equalPos = currLineToBeProcessed.find_first_of("=");
                            rFound = 0;
                            gFound = 0;
                            bFound = 0;

                            if(equalPos!=(int)std::string::npos)
                            {
                                //if the equalPos is present, then parse on through and carryon
                                keyString = currLineToBeProcessed.substr(0,equalPos);
                                valString = currLineToBeProcessed.substr(equalPos+1,currLineToBeProcessed.length());

                                hashPos = valString.find_first_of("#");
                                if(hashPos!=(int)std::string::npos)
                                {
                                    HEXtoRGB(valString,rFound,gFound, bFound);
                                }
                                else
                                {
                                    rFound = split_first_int(valString,',');
                                    gFound = split_first_int(valString,',');
                                    bFound = string_to_int(valString);
                                }
                                if( keyString=="MainBackground")
                                {
                                    Program_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="HeaderBackground")
                                {
                                    Program_Header_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="FolderColor")
                                {
                                    Main_Folder_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="FolderHighlightedColor")
                                {
                                    Main_Folder_Highlighted_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="Input")
                                {
                                    Input_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="InputHighlighted")
                                {
                                    Input_Highlight_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="InputHighlightedOutline")
                                {
                                    Input_Highlight_Outline_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="InputHighlightedAlt")
                                {
                                    Input_Highlight_Alt_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="InputBackground")
                                {
                                    Input_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="InputOutline")
                                {
                                    Input_Outline_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="InputFont")
                                {
                                    Input_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="InputFontHighlighted")
                                {
                                    Input_Highlight_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="InputFontFaded")
                                {
                                    Input_Faded_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBorder")
                                {
                                    Main_Border_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBorderHighlighted")
                                {
                                    Main_Border_Highlighted_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBoxHighlightedAlt")
                                {
                                    Button_Box_Selected_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBox")
                                {
                                    Main_Box_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBoxFaded")
                                {
                                    Main_Box_Faded_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBoxOutline" || keyString=="MainBorder" )
                                {
                                    Main_Border_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBoxFont")
                                {
                                    Main_Box_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBoxFontHighlighted")
                                {
                                    Main_Box_Font_Highlight_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBoxFontFaded")
                                {
                                    Main_Box_Faded_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBoxFontURL")
                                {
                                    Main_Box_Font_URL_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="MainBoxFontURLVisited")
                                {
                                    Main_Box_Font_URL_Visited_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="ButtonBox")
                                {
                                    //Butons and such...
                                    Button_Box_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="ButtonBoxHighlighted")
                                {
                                    Button_Box_Highlighted_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="ButtonBoxSelected")
                                {
                                    Button_Box_Selected_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="ButtonBorder")
                                {
                                    Button_Border_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="ButtonBorderHighlighted")
                                {
                                    Button_Border_Highlighted_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="ButtonBorderSelected")
                                {
                                    Button_Border_Selected_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="ButtonFont")
                                {
                                    Button_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="ButtonFontHighlighted")
                                {
                                    Button_Font_Highlighted_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconBox")
                                {
                                    //Butons and such...
                                    Icon_Box_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconBoxHighlighted")
                                {
                                    Icon_Box_Highlighted_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconBoxSelected")
                                {
                                    Icon_Box_Selected_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconBorder")
                                {
                                    Icon_Border_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconBorderHighlighted")
                                {
                                    Icon_Border_Highlighted_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconBorderSelected")
                                {
                                    Icon_Border_Selected_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconFont")
                                {
                                    Icon_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconFontHighlighted")
                                {
                                    Icon_Font_Highlighted_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="IconFontSelected")
                                {
                                    Icon_Font_Selected_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="PopUpBox")
                                {
                                    PopUp_Box_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="PopUpBoxHighlighted")
                                {
                                    PopUp_Box_Highlight_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="PopUpBoxHighlightedAlt")
                                {
                                    PopUp_Box_Highlight_Alt_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="PopUpBoxOutline")
                                {
                                    PopUp_Box_Border_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="PopUpBoxFont")
                                {
                                    PopUp_Box_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="PopUpBoxFontHighlighted")
                                {
                                    PopUp_Box_Highlight_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="PopUpBoxFontFaded")
                                {
                                    PopUp_Box_Faded_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextBoxOuter")
                                {
                                    Text_Box_Outer_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextBoxOuterFont")
                                {
                                    Text_Box_Outer_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextBox")
                                {
                                    Text_Box_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextBoxOutline")
                                {
                                    Text_Box_Outline_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextBoxHighlighted")
                                {
                                    Text_Box_Highlight_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextBoxFont")
                                {
                                    Text_Box_Font_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextBoxFontComment")
                                {
                                    Text_Box_Font_Comment_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontHighlighted")
                                {
                                    Text_Box_Font_Highlight_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontFunction")
                                {
                                    Text_Box_Font_Function_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontKeyword")
                                {
                                    Text_Box_Font_Keyword_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontNumber")
                                {
                                    Text_Box_Font_Number_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontDQuote")
                                {
                                    Text_Box_Font_DQuote_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontSQuote")
                                {
                                    Text_Box_Font_SQuote_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontSymbol")
                                {
                                    Text_Box_Font_Symbols_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontJavaScript")
                                {
                                    Text_Box_Font_JavaScript_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontProjectFunction")
                                {
                                    Text_Box_Project_Function_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontProjectKeyword")
                                {
                                    Text_Box_Project_Keyword_Color->change_rgba(rFound,gFound,bFound);
                                }
                                else if( keyString=="TextFontVariable" )
                                {
                                    Text_Box_Font_Variable_Color->change_rgba(rFound,gFound, bFound );
                                }
                                else if( keyString=="TextFontVariableAlt" )
                                {
                                    Text_Box_Font_Variable_Alt_Color->change_rgba(rFound,gFound, bFound );
                                }
                                else if( keyString=="ScrollBox" )
                                {
                                    Scroll_Box_Color->change_rgba(rFound,gFound, bFound );
                                }
                                else if( keyString=="ScrollBoxBorder" )
                                {
                                    Scroll_Box_Border_Color->change_rgba(rFound,gFound, bFound );
                                }
                                else if( keyString=="ScrollBoxArrow" )
                                {
                                    Scroll_Box_Arrow_Color->change_rgba(rFound,gFound, bFound );
                                }
                                else if( keyString=="ScrollBoxCamera" )
                                {
                                    Scroll_Box_Camera_Color->change_rgba(rFound,gFound, bFound );
                                }
                                else if( keyString=="ScrollBoxCameraHighlight" )
                                {
                                    Scroll_Box_Camera_Highlight_Color->change_rgba(rFound,gFound, bFound );
                                }


                            }
                        }
                    }
                }
                templateFileIn.close();
            }
        }
    }
}


void GPE_set_selected_gresource(generalGameResource *newResource)
{
    SELECTED_GENERAL_RESOUCE = newResource;
}

generalGameResource * GPE_get_selected_gresource()
{
    generalGameResource * returnValue = SELECTED_GENERAL_RESOUCE;
    SELECTED_GENERAL_RESOUCE = NULL;
    return returnValue;
}


GPE_GuiElementList::GPE_GuiElementList()
{
    cameraBox.x = menuBox.x = entireBox.x = barBox.x = 0;
    cameraBox.y = menuBox.y = entireBox.y = barBox.y = 0;
    cameraBox.w = menuBox.w = entireBox.w = barBox.w;
    cameraBox.h = menuBox.h = entireBox.h = barBox.h = RESOURCE_kb_AREA_HEIGHT*3;
    xScroll = new GPE_ScrollBar_XAxis();
    yScroll = new GPE_ScrollBar_YAxis();
    cameraBox.w = menuBox.w = entireBox.w = barBox.w - yScroll->get_box_width();
    barXPadding = GENERAL_GPE_PADDING*2;
    barYPadding = GENERAL_GPE_PADDING*2;
    barXMargin = 0;
    barYMargin = 0;
    isInUse = true;
    subElementsHasArrowControl = false;
    subElementsIsScrolling = false;
    hAlign = FA_LEFT;
    vAlign = FA_TOP;
    optionWithViewId = 0;
    guiListTypeName = "guilist";
    tabDelay = 0;
    leserKeyDelay = 0;
    greaterKeyDelay = 0;
    upDelay = 0;
    downDelay = 0;
    leftDelay = 0;
    rightDelay = 0;
}

GPE_GuiElementList::~GPE_GuiElementList()
{
    if( xScroll!=NULL)
    {
        delete xScroll;
        xScroll = NULL;
    }
    if( yScroll!=NULL)
    {
        delete yScroll;
        yScroll = NULL;
    }
    subOptions.clear();
}

void GPE_GuiElementList::add_gui_element(GPE_GeneralGuiElement *  newElement, bool isNLElement)
{
    if( newElement!=NULL)
    {
        newElement->hasLineBreak = isNLElement;
        /*
        if( isNLElement)
        {
            newElement->hasLineBreak = true;
        }
        else
        {

        }
        */
        subOptions.push_back( newElement);
    }
}

void GPE_GuiElementList::clear_list()
{
    subOptions.clear();
    cameraBox.w = menuBox.w = entireBox.w = barBox.w;
    cameraBox.h = menuBox.h = entireBox.h = barBox.h;

}

void GPE_GuiElementList::scroll_down(int yToMove )
{
    if( yToMove > 0)
    {
        cameraBox.y+=yToMove;
    }
    if( cameraBox.y+cameraBox.h > entireBox.h )
    {
        cameraBox.y = entireBox.h-cameraBox.h;
    }
    if( cameraBox.y < 0)
    {
        cameraBox.y = 0;
    }
}

void GPE_GuiElementList::scroll_up(int yToMove )
{
    if( yToMove > 0)
    {
        cameraBox.y-=yToMove;
    }

    if( cameraBox.y+cameraBox.h > entireBox.h )
    {
        cameraBox.y = entireBox.h-cameraBox.h;
    }
    if( cameraBox.y < 0)
    {
        cameraBox.y = 0;
    }
}

void GPE_GuiElementList::scroll_left(int xToMove )
{
    if( xToMove > 0)
    {
        cameraBox.x-=xToMove;
    }

    if( cameraBox.x+cameraBox.w > entireBox.w )
    {
        cameraBox.x = entireBox.w-cameraBox.w;
    }
    if( cameraBox.x < 0)
    {
        cameraBox.x = 0;
    }
}

void GPE_GuiElementList::scroll_right(int xToMove )
{
    if( xToMove > 0)
    {
        cameraBox.x+=xToMove;
    }
    if( cameraBox.x+cameraBox.w > entireBox.w )
    {
        cameraBox.x = entireBox.w-cameraBox.w;
    }
    if( cameraBox.x < 0)
    {
        cameraBox.x = 0;
    }
}

void GPE_GuiElementList::process_self(SDL_Rect * viewedSpace ,SDL_Rect *cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);

    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isClicked)
    {
        //if( RESOURCE_TO_DRAG==NULL)
        {
            isInUse = true;
            hasScrollControl = true;
            hasArrowkeyControl = true;
        }
    }
    else if( clickedOutside)
    {
        isInUse = false;
        hasScrollControl = false;
        hasArrowkeyControl = false;
    }
    else if( !isInUse)
    {
        hasScrollControl = false;
    }
    entireBox.x = 0;
    entireBox.y = 0;
    entireBox.w = (barXPadding+barXMargin)*2;
    entireBox.h = (barYPadding+barYMargin)*2;

    menuBox.x = barBox.x+viewedSpace->x;
    menuBox.y = barBox.y+viewedSpace->y;
    cameraBox.w = menuBox.w = barBox.w-16;
    cameraBox.h = menuBox.h = barBox.h-16;
    subElementsHasArrowControl = false;
    subElementsIsScrolling = false;
    int xPos = barXMargin+barXPadding;
    int yPos = barYMargin+barYPadding;
    int y2Pos = yPos;
    int rowWidth = 0;
    int maxRowWidth = 0;
    int totalMaxRowWidth = 0;
    int rowHeight = 0;
    bool scrolingHasntOccurred = false;
    if ( xScroll->is_scrolling()==false && yScroll->is_scrolling()==false  )
    {
        scrolingHasntOccurred = true;
    }

    GPE_GeneralGuiElement * cContainer = NULL;
    GPE_GeneralGuiElement * dContainer = NULL;
    int i = 0;
    int j = 0;
    int pastRowChange = 0;
    if( isInUse && hasArrowkeyControl )
    {
        if( userInput->down[kb_tab] && userInput->pressed[kb_tab]==false && userInput->released[kb_tab]==false )
        {
            tabDelay += 0.5;
        }
        else
        {
            tabDelay = -1;
        }
        if( userInput->down[kb_left] && userInput->pressed[kb_left]==false && userInput->released[kb_left]==false )
        {
            leftDelay+=0.5;
        }
        else
        {
            leftDelay = -1;
        }
        if( userInput->down[kb_right] && userInput->pressed[kb_right]==false && userInput->released[kb_right]==false )
        {
            rightDelay+=0.5;
        }
        else
        {
            rightDelay = -1;
        }
        if( userInput->down[kb_up] && userInput->pressed[kb_up]==false && userInput->released[kb_up]==false )
        {
            upDelay+=0.5;
        }
        else
        {
            upDelay = -1;
        }
        if(userInput->down[kb_down] && userInput->pressed[kb_down]==false && userInput->released[kb_down]==false )
        {
            downDelay+=0.5;
        }
        else
        {
            downDelay = -1;
        }
        if( userInput->down[kb_comma] && userInput->pressed[kb_comma]==false && userInput->released[kb_comma]==false )
        {
            leserKeyDelay+=0.5;
        }
        else
        {
            leserKeyDelay = -1;
        }

        if( userInput->down[kb_period] && userInput->pressed[kb_period]==false && userInput->released[kb_period]==false )
        {
            greaterKeyDelay+=0.5;
        }
        else
        {
            greaterKeyDelay = -1;
        }
    }
    else
    {
        tabDelay = -1;
        leserKeyDelay = -1;
        greaterKeyDelay = -1;
        upDelay = -1;
        downDelay = -1;
        leftDelay = -1;
        rightDelay = -1;
    }

    if( hAlign==FA_CENTER)
    {
        xPos = barXPadding;
        yPos = barYPadding;
        y2Pos = yPos;
        int optionsSize = (int)subOptions.size();
        for( i=0; i<optionsSize;i++)
        {
            cContainer = subOptions[i];
            if(cContainer!=NULL)
            {
                if( cContainer->get_element_type() == "labelimage" )
                {
                    cContainer->set_width(barBox.w - (barXPadding+barXMargin)*2 - yScroll->get_box_width() );
                }
                else if( cContainer->get_element_type() == "paragraph" )
                {
                    cContainer->set_width(barBox.w - (barXPadding+barXMargin)*2 - yScroll->get_box_width() );
                }
                if( cContainer->get_height() > rowHeight)
                {
                    rowHeight = cContainer->get_height();
                }
                rowWidth+=cContainer->get_width()+barXPadding;
                if( maxRowWidth < rowWidth)
                {
                    maxRowWidth = rowWidth;
                }
                if( totalMaxRowWidth < maxRowWidth)
                {
                    totalMaxRowWidth = maxRowWidth;
                }
                if( cContainer->hasLineBreak || i>=optionsSize-1 )
                {
                    xPos = barXPadding+abs(maxRowWidth-cameraBox.w)/2;

                    for( j = pastRowChange; j <=i; j++)
                    {
                        dContainer = subOptions[j];
                        if(dContainer!=NULL)
                        {
                            dContainer->set_coords(xPos, y2Pos);
                            xPos+=barXPadding+dContainer->get_width();
                        }
                    }
                    pastRowChange = i+1;
                    //pastRowChange++;
                    entireBox.h+=rowHeight+barYPadding;
                    y2Pos+=rowHeight+barYPadding;
                    rowWidth = 0;
                    rowHeight = 0;
                    maxRowWidth = 0;
                }
            }
        }
        xPos = barXPadding+abs(maxRowWidth-cameraBox.w)/2;
        y2Pos+=rowHeight+barYPadding;
        entireBox.h+=rowHeight+barYPadding;
        pastRowChange++;
        for( j = pastRowChange; j < (int)subOptions.size(); j++)
        {
            cContainer = subOptions[j];
            if(cContainer!=NULL)
            {
                cContainer->set_coords(xPos, y2Pos);
                /*
                if( cContainer->get_element_type() == "labelimage" )
                {
                    cContainer->set_width(barBox.w - (barXPadding+barXMargin)*2 - yScroll->get_box_width() );
                }
                else if( cContainer->get_element_type() == "paragraph" )
                {
                    cContainer->set_width(barBox.w - (barXPadding+barXMargin)*2 - yScroll->get_box_width() );
                }
                */
                if(cContainer->autoResizes)
                {
                    cContainer->set_width(barBox.w - (barXPadding+barXMargin)*2 - yScroll->get_box_width() );
                }
                xPos+=barXPadding+cContainer->get_width();
            }
        }
        entireBox.w = totalMaxRowWidth;
    }
    else
    {
        for( i=0; i < (int)subOptions.size();i++)
        {
            cContainer = subOptions[i];
            if(cContainer!=NULL)
            {
                cContainer->set_coords(xPos, y2Pos);
                /*
                if( cContainer->get_element_type() == "labelimage" )
                {
                    cContainer->set_width(barBox.w - (barXPadding+barXMargin)*2 - yScroll->get_box_width() );
                }
                else if( cContainer->get_element_type() == "paragraph" )
                {
                    cContainer->set_width(barBox.w - (barXPadding+barXMargin)*2 - yScroll->get_box_width() );
                }*/
                if(cContainer->autoResizes)
                {
                    cContainer->set_width(barBox.w - (barXPadding+barXMargin)*2 - yScroll->get_box_width() );
                }
                if( cContainer->get_height() > rowHeight)
                {
                    rowHeight = cContainer->get_height();
                }
                rowWidth+=cContainer->get_width()+barXPadding;
                if( maxRowWidth < rowWidth)
                {
                    maxRowWidth = rowWidth+barXPadding;
                }
                if( cContainer->hasLineBreak || i==(int)subOptions.size()-1 )
                {
                    entireBox.h+=barYMargin+rowHeight+barYPadding;
                    y2Pos+=rowHeight+barYPadding;
                    rowWidth = 0;
                    rowHeight = 0;
                    xPos = barXMargin+barXPadding;
                }
                else
                {
                    xPos = barXMargin+barXPadding+rowWidth;
                }
            }
        }
        entireBox.w = barXMargin+maxRowWidth;
    }

    if( scrolingHasntOccurred)
    {
        for( i=0; i<(int)subOptions.size();i++)
        {
            cContainer = subOptions[i];
            if(cContainer!=NULL)
            {
                cContainer->process_self(&menuBox,&cameraBox);
                if( cContainer->hasScrollControl )
                {
                    subElementsIsScrolling=true;
                }
                if( cContainer->hasArrowkeyControl )
                {
                    subElementsHasArrowControl=true;
                }
                if( cContainer->is_inuse() )
                {
                    optionWithViewId = i;
                }
            }
        }
    }

    //if(  isHovered || (isInUse && subElementsIsScrolling==false && hasScrollControl ) )
    if( isHovered && subElementsIsScrolling==false)
    {
        if( userInput->mouseScrollingUp )
        {
            if( userInput->shiftKeyIsPressed)
            {
                scroll_left( cameraBox.w/8);
            }
            else
            {
                scroll_up( cameraBox.h/8);
            }
        }
        else if( userInput->mouseScrollingDown )
        {
            if( userInput->shiftKeyIsPressed )
            {
                scroll_right( cameraBox.w/8);
            }
            else
            {
                scroll_down( cameraBox.h/8);
            }
        }
    }

    bool directionChangeRequested = false;

    if( hasScrollControl && subElementsIsScrolling==false)
    {
        if( tabDelay > (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO || ( !userInput->pressed[kb_tab] && userInput->released[kb_tab] ) && userInput->check_keyboard_down(kb_ctrl)==false )
        {
            if( userInput->shiftKeyIsPressed)
            {
                optionWithViewId--;
                directionChangeRequested = true;
            }
            else
            {
                optionWithViewId++;
                directionChangeRequested = true;
            }
            tabDelay = -1;
        }
        else if( userInput->check_keyboard_down(kb_ctrl) )
        {
            if( leserKeyDelay > (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO || ( !userInput->pressed[kb_comma] && userInput->released[kb_comma] ) )
            {
                optionWithViewId--;
                directionChangeRequested = true;
                leserKeyDelay = -1;
            }
            else if( greaterKeyDelay > (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO || ( !userInput->pressed[kb_period] && userInput->released[kb_period] ) )
            {
                optionWithViewId++;
                directionChangeRequested = true;
                greaterKeyDelay = -1;
            }
        }

        if( optionWithViewId < 0)
        {
            optionWithViewId = (int)subOptions.size() -1;
        }

        if( optionWithViewId >= (int)subOptions.size() )
        {
            optionWithViewId = 0;
        }

        if( subElementsHasArrowControl==false)
        {
            if( upDelay > (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO || ( !userInput->pressed[kb_up] && userInput->released[kb_up] ) )
            {
                scroll_up( cameraBox.h/4 );
                upDelay = 0;
            }
            else if( downDelay > (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO || ( userInput->pressed[kb_down] && !userInput->released[kb_down] ) )
            {
                scroll_down( cameraBox.h/4 );
                downDelay = 0;
            }
        }
    }
    else if( hasScrollControl && subElementsIsScrolling==false)
    {
        if( userInput->check_keyboard_down(kb_ctrl) )
        {
            if( leserKeyDelay > (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO || ( userInput->pressed[kb_comma] && !userInput->released[kb_comma] ) && userInput->check_keyboard_down(kb_ctrl)==false )
            {
                optionWithViewId--;
                directionChangeRequested = true;
                leserKeyDelay = -1;
            }
            else if( greaterKeyDelay > (GPE_MAIN_GUI->normalInputDelayTime+3)*FPS_RATIO || ( userInput->pressed[kb_period] && !userInput->released[kb_period] ) && userInput->check_keyboard_down(kb_ctrl)==false )
            {
                optionWithViewId++;
                directionChangeRequested = true;
                greaterKeyDelay = -1;
            }
        }
        if( optionWithViewId < 0)
        {
            optionWithViewId = (int)subOptions.size() -1;
        }

        if( optionWithViewId >= (int)subOptions.size() )
        {
            optionWithViewId = 0;
        }
    }

    if( directionChangeRequested)
    {
        for( i=0; i<(int)subOptions.size();i++)
        {
            cContainer = subOptions[i];
            if(cContainer!=NULL)
            {
                if( optionWithViewId == i)
                {
                    cContainer->switch_inuse( true );
                    ///cameraBox.x = cContainer->get_xpos()-(barXPadding+barXMargin-totalMaxRowWidth);
                    if( cameraBox.y > cContainer->get_ypos() || cContainer->get_ypos() > cameraBox.y+cameraBox.h )
                    {
                        cameraBox.y = cContainer->get_ypos()-(barYPadding+barYMargin);
                    }
                }
                else
                {
                    cContainer->switch_inuse( false );
                }
            }
        }
    }

    if( hasScrollControl && subElementsHasArrowControl==false)
    {
        if( leftDelay > (GPE_MAIN_GUI->normalInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_left] && !userInput->released[kb_left] ) )
        {
            scroll_left( cameraBox.w/4 );
            leftDelay =-1;
        }
        else if( rightDelay > (GPE_MAIN_GUI->normalInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_right] && !userInput->released[kb_right] ) )
        {
            scroll_right( cameraBox.w/4 );
            rightDelay = -1;
        }

        if( upDelay > (GPE_MAIN_GUI->normalInputDelayTime+1)*FPS_RATIO || ( !userInput->pressed[kb_up] && userInput->released[kb_up] ) )
        {
            scroll_up( cameraBox.h/4 );
            upDelay = 0;
        }
        else if( downDelay > (GPE_MAIN_GUI->normalInputDelayTime+1)*FPS_RATIO || ( userInput->pressed[kb_down] && !userInput->released[kb_down] ) )
        {
            scroll_down( cameraBox.h/4 );
            downDelay = -1;
        }
    }

    if( optionWithViewId < 0)
    {
        optionWithViewId = (int)subOptions.size() -1;
    }

    if( optionWithViewId >= (int)subOptions.size() )
    {
        optionWithViewId = 0;
    }

    if( xScroll!=NULL && yScroll!=NULL)
    {
        xScroll->barBox.x = barBox.x;
        xScroll->barBox.y = barBox.y+barBox.h;
        xScroll->barBox.w = barBox.w-16;
        xScroll->barBox.h = 16;

        xScroll->fullRect.x = 0;
        xScroll->fullRect.y = 0;
        xScroll->fullRect.w = entireBox.w;
        xScroll->fullRect.h = entireBox.h;

        xScroll->contextRect.x = cameraBox.x;
        xScroll->contextRect.y = cameraBox.y;
        xScroll->contextRect.w = cameraBox.w;
        xScroll->contextRect.h = cameraBox.h;
        if( entireBox.w >=barBox.w)
        {
            xScroll->process_self(viewedSpace,cam,true);
        }
        else
        {
            cameraBox.h+=16;
        }
        if( xScroll->has_moved() || xScroll->is_scrolling() )
        {
            cameraBox.x = xScroll->contextRect.x;
            if( cameraBox.x +cameraBox.w > entireBox.w)
            {
                cameraBox.x = entireBox.w - cameraBox.w;
            }
            if( cameraBox.x < 0)
            {
                cameraBox.x = 0;
            }
        }

        update_rectangle(&yScroll->barBox, barBox.x+barBox.w-16, barBox.y, 16,barBox.h);
        update_rectangle(&yScroll->fullRect, 0, 0, entireBox.w,entireBox.h);
        update_rectangle(&yScroll->contextRect, cameraBox.x, cameraBox.y, cameraBox.w,cameraBox.h);

        //yScroll->process_self( viewedSpace,cam );

        yScroll->process_self(viewedSpace,cam,false);
        if( entireBox.h <= cameraBox.h)
        {
            yScroll->contextRect.y = 0;
            yScroll->contextRect.h = entireBox.h;
            cameraBox.y = 0;
        }
        if( isInUse )
        {

        }

        if( yScroll->has_moved() )
        {
            cameraBox.y = yScroll->contextRect.y;
            /*
            if( cameraBox.y +cameraBox.h > entireBox.h)
            {
                cameraBox.y = entireBox.h - cameraBox.h;
            }
            if( cameraBox.y < 0)
            {
                cameraBox.y = 0;
            }*/
        }
    }

}

void GPE_GuiElementList::render_self(GPE_Renderer * cRender,SDL_Rect * viewedSpace,SDL_Rect *cam , bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( viewedSpace!=NULL && cam!=NULL )
    {
        SDL_RenderSetViewport( cRender->get_renderer(), NULL );
        menuBox.w+=16;
        menuBox.h+=16;
        SDL_RenderSetViewport( cRender->get_renderer(), &menuBox );

        GPE_GeneralGuiElement * cResource = NULL;
        for(int i=0; i<(int)subOptions.size();i++)
        {
            cResource = subOptions[i];
            if(cResource!=NULL)
            {
                cResource->render_self(cRender,&menuBox,&cameraBox,forceRedraw);
            }
        }

        SDL_RenderSetViewport( cRender->get_renderer(), NULL );
        SDL_RenderSetViewport( cRender->get_renderer(), viewedSpace );
        menuBox.w-=16;
        menuBox.h-=16;
        if( xScroll!=NULL && forceRedraw)
        {
            if( entireBox.w >barBox.w)
            {
                xScroll->render_self(cRender,viewedSpace,cam);
            }
        }
        if( yScroll!=NULL && forceRedraw)
        {
            if( entireBox.h >barBox.h )
            {
                yScroll->render_self(cRender,viewedSpace,cam);
            }
        }

        /*if( isInUse && subElementsIsScrolling==false && hasScrollControl && forceRedraw)
        {
            render_rect(cRender,&barBox,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,true);
        }
        else
        {
            render_rect(cRender,&barBox,GPE_MAIN_TEMPLATE->Main_Box_Faded_Color,true);
        }*/
        //if( forceRedraw)
        {
            render_rect(cRender,&barBox,GPE_MAIN_TEMPLATE->Main_Border_Color,true);
        }
    }
}

void GPE_GuiElementList::reset_self()
{
    subOptions.clear();
    cameraBox.x = menuBox.x = entireBox.x = 0;
    cameraBox.y = menuBox.y = entireBox.y = 0;
    cameraBox.w = menuBox.w = entireBox.w = 32;
    cameraBox.h = menuBox.h = entireBox.h = RESOURCE_kb_AREA_HEIGHT*3;
}

void GPE_GuiElementList::set_horizontal_align(int hValue)
{
    hAlign = hValue;
}

void GPE_GuiElementList::set_full_width()
{
    GPE_GeneralGuiElement * tguiElement = NULL;
    int maxWidth = barBox.w-(barXMargin+barXPadding)*2;
    for( int i = (int)subOptions.size()-1; i>=0; i--)
    {
        tguiElement = subOptions[i];
        if( tguiElement!=NULL )
        {
            tguiElement->set_width(maxWidth);
        }
    }
}

void GPE_GuiElementList::set_maxed_out_width()
{
    GPE_GeneralGuiElement * tguiElement = NULL;
    int i = 0;
    int maxWidth = 0;
    for( i = (int)subOptions.size()-1; i>=0; i--)
    {
        tguiElement = subOptions[i];
        if( tguiElement!=NULL )
        {
            if( tguiElement->get_width() > maxWidth)
            {
                maxWidth = tguiElement->get_width();
            }
        }
    }

    for( i = (int)subOptions.size()-1; i>=0; i--)
    {
        tguiElement = subOptions[i];
        if( tguiElement!=NULL )
        {
            tguiElement->set_width(maxWidth);
        }
    }
}

void GPE_GuiElementList::set_maxed_out_height()
{
    GPE_GeneralGuiElement * tguiElement = NULL;
    int i = 0;
    int maxHeight = 0;
    for( i = (int)subOptions.size()-1; i>=0; i--)
    {
        tguiElement = subOptions[i];
        if( tguiElement!=NULL )
        {
            if( tguiElement->get_height() > maxHeight)
            {
                maxHeight = tguiElement->get_height();
            }
        }
    }

    for( i = (int)subOptions.size()-1; i>=0; i--)
    {
        tguiElement = subOptions[i];
        if( tguiElement!=NULL )
        {
            tguiElement->set_height(maxHeight);
        }
    }
}

GPE_ResourceContainer::GPE_ResourceContainer(std::string projFolderName,int  rezPropValue)
{
    foundX2Pos = 0;
    resouceNameChanged = false;
    subContentsModified = false;
    opName = projFolderName;
    parentResource = NULL;
    globalResouceId = -1;
    html5BuildGlobalId = -1;
    projectParentFileName = projectParentName = projFolderName;
    if( rezPropValue<=0)
    {
        isFolder = false;
        isSuperFolder = false;
        isSuperProjectFolder = false;
    }
    else if( rezPropValue==1)
    {
        isSuperProjectFolder = true;
    }
    else if( rezPropValue>1)
    {
        isSuperFolder = true;
    }
    heldResource = NULL;
    containerSprite = NULL;
    optionBox.x = 0;
    optionBox.y = 0;
    optionBox.w = 0;
    optionBox.h = RESOURCE_kb_AREA_HEIGHT;
    int textW = 0;
    int textH = 0;

    if( (int)opName.size()>0 && FONT_TOOLBAR!=NULL)
    {
        FONT_TOOLBAR->get_metrics(opName,&textW, &textH);
    }
    strTexWidth = textW;
    strTexHeight = textH;
    subMenuIsOpen = false;
}

GPE_ResourceContainer::GPE_ResourceContainer(std::string projFolderName, std::string newName, int rType, int rId,bool folder, int globalIdVal,  int rezPropValue)
{
    foundX2Pos = 0;
    resouceNameChanged = false;
    subContentsModified = false;
    parentResource = NULL;
    projectParentFileName = projectParentName = projFolderName;
    opName = newName;
    resourceType = rType;
    resourceId = rId;
    isFolder = folder;
    html5BuildGlobalId = -1;
    globalResouceId = -1;
    if(globalIdVal>=0)
    {
        globalResouceId = globalIdVal;
    }
    optionBox.x = 0;
    optionBox.y = 0;
    optionBox.w = 0;
    optionBox.h = RESOURCE_kb_AREA_HEIGHT;
    containerSprite = NULL;
    containerTexture = NULL;
    spriteFrameNumber = 0;
    heldResource = NULL;
    subMenuIsOpen = false;
    int textW = 0;
    int textH = 0;

    if( (int)opName.size()>0 && FONT_TOOLBAR!=NULL)
    {
        FONT_TOOLBAR->get_metrics(opName,&textW, &textH);
    }
    strTexWidth = textW;
    strTexHeight = textH;

    set_basic_image_value();
    if( rezPropValue==restype_projfolder)
    {
        isSuperProjectFolder = true;
        isSuperFolder = false;
    }
    else if( rezPropValue==restype_superfolder)
    {
        isSuperFolder = true;
        isSuperProjectFolder = false;
    }
    else
    {
        isSuperFolder = false;
        isSuperProjectFolder = false;
    }

}

GPE_ResourceContainer::~GPE_ResourceContainer()
{
    record_error("Deleting Resource named ["+opName+"].");
    if( heldResource!=NULL)
    {
        if( GPE_Main_TabManager!=NULL)
        {
            GPE_Main_TabManager->close_resource_tab(projectParentName,heldResource->globalResouceIdNumber);
        }
        delete heldResource;
        heldResource = NULL;
    }
    GPE_ResourceContainer * tempSubOp = NULL;
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        tempSubOp = subOptions[i];
        if( tempSubOp!=NULL)
        {
            delete tempSubOp;
            tempSubOp = NULL;
        }
    }

    if( containerSprite!=NULL)
    {
        //delete containerSprite;
       //containerSprite = NULL;
    }
    if( containerTexture!=NULL)
    {
        /*delete containerTexture;
        containerTexture = NULL;*/
    }
    subOptions.clear();
    record_error("Resource ["+opName+"] deleted.");

}

void GPE_ResourceContainer::add_resource_container( GPE_ResourceContainer * newResource, bool changeGlobalId, GPE_ResourceContainer * referenceObject)
{
    if( newResource!=NULL)
    {
        newResource->parentResource = this;
        newResource->parentProjectDirectory = parentProjectDirectory;
        newResource->projectParentFileName = projectParentFileName;
        newResource->set_project_parent_name( projectParentFileName);
        if( subMenuIsOpen)
        {
            optionBox.h += newResource->optionBox.h;
        }
        if( changeGlobalId)
        {
            int newId = (int)subOptions.size()+1;
            newResource->set_global_id(newId);
        }
        if( referenceObject!=NULL )
        {
            int foundRef = -1;
            GPE_ResourceContainer * tempResource = NULL;
            for( int i = (int)subOptions.size()-1; i>=0; i--)
            {
                tempResource = subOptions[i];
                if( tempResource!=NULL )
                {
                    if( tempResource->matches(referenceObject)==1 )
                    {
                        foundRef = i;
                        break;
                    }
                }
            }
            if( foundRef >=0 && foundRef < (int)subOptions.size() )
            {
                subOptions.insert(subOptions.begin()+foundRef+1,newResource);
            }
            else
            {
                subOptions.push_back(newResource);
            }
        }
        else
        {
            if( newResource->get_resource_type()==RESOURCE_TYPE_PROJECT_SETTINGS)
            {
                subOptions.push_back( newResource );
            }
            else if( RESOURCE_TO_DRAG!=NULL)
            {
                if( RESOURCE_TO_DRAG->matches(newResource) )
                {
                    subOptions.insert(subOptions.begin(),newResource);
                }
                else
                {
                    subOptions.push_back( newResource );
                }
            }
            else
            {
                subOptions.push_back( newResource );
            }
        }
    }
}

GPE_ResourceContainer * GPE_ResourceContainer::add_resource_folder( std::string resourceTypeName,  int gResId,int rezPropValue)
{
    int newId = (int)subOptions.size()+1;
    GPE_ResourceContainer * newFolder = new GPE_ResourceContainer(projectParentFileName,resourceTypeName,resourceType,newId,true, gResId, rezPropValue);
    newFolder->optionBox.x = optionBox.x;
    newFolder->optionBox.y = optionBox.y+newId*RESOURCE_kb_AREA_HEIGHT;
    //optionBox.h+=RESOURCE_kb_AREA_HEIGHT;
    newFolder->parentResource = this;
    subOptions.push_back(newFolder);
    if( subMenuIsOpen)
    {
        optionBox.h += RESOURCE_kb_AREA_HEIGHT;
    }
    return newFolder;
}

GPE_ResourceContainer * GPE_ResourceContainer::add_newtype_folder( int rType,std::string resourceTypeName, int gResId, int rezPropValue)
{
    int newId = (int)subOptions.size()+1;
    GPE_ResourceContainer * newFolder = new GPE_ResourceContainer(projectParentFileName,resourceTypeName,rType,newId,true, gResId,rezPropValue);
    newFolder->optionBox.x = optionBox.x;
    newFolder->optionBox.y = optionBox.y+newId*RESOURCE_kb_AREA_HEIGHT;
    //optionBox.h+=RESOURCE_kb_AREA_HEIGHT;
    newFolder->parentResource = this;
    subOptions.push_back(newFolder);
    optionBox.h += RESOURCE_kb_AREA_HEIGHT;
    return newFolder;
}

void GPE_ResourceContainer::delete_resource(GPE_ResourceContainer * otherContainer)
{
    remove_resource(otherContainer);
}

bool GPE_ResourceContainer::detect_name_change(bool autoChange)
{
    if( heldResource!=NULL)
    {
        std::string fName = heldResource->get_current_name();
        if( fName!=opName)
        {
            if( autoChange)
            {
                set_name( fName  );
            }
            return true;
        }
    }
    return false;
}

GPE_ResourceContainer * GPE_ResourceContainer::get_resource_at(int resourcePos, bool nestDown)
{
    if((int)subOptions.size()>0)
    {
        if(resourcePos>=0 && resourcePos<(int)subOptions.size() )
        {
            return subOptions.at(resourcePos);
        }
    }
    return NULL;
}

GPE_ResourceContainer * GPE_ResourceContainer::find_resource_from_id(int resourceIdToFind, bool nestDown, bool includeSelf)
{
    GPE_ResourceContainer * rFound = NULL;
    GPE_ResourceContainer * nResource = NULL;
    if( globalResouceId==resourceIdToFind && includeSelf)
    {
        return this;
    }
    if( (int)subOptions.size()>0 )
    {
        for( int i= 0 ; i < (int)subOptions.size(); i++)
        {
            nResource = subOptions[i];
            if( nResource!=NULL)
            {
                rFound = nResource->find_resource_from_id(resourceIdToFind);
                if( rFound!=NULL)
                {
                    break;
                }
            }
        }
    }
    return rFound;
}

GPE_ResourceContainer * GPE_ResourceContainer::get_usable_resource()
{
    GPE_ResourceContainer * rFound = NULL;
    GPE_ResourceContainer * nResource = NULL;
    if( heldResource!=NULL )
    {
        return this;
    }
    if( (int)subOptions.size()>0 )
    {
        for( int i= 0 ; i < (int)subOptions.size(); i++)
        {
            nResource = subOptions[i];
            if( nResource!=NULL)
            {
                rFound = nResource->get_usable_resource();
                if( rFound!=NULL)
                {
                    break;
                }
            }
        }
    }
    return rFound;

}

GPE_ResourceContainer * GPE_ResourceContainer::find_resource_from_name(std::string rNameToFind, bool nestDown)
{
    bool foundResult = false;
    GPE_ResourceContainer * fContainer = NULL;
    GPE_ResourceContainer * soughtContainer = NULL;
    if( rNameToFind.size()> 0 )
    {
        if((int)subOptions.size()>0)
        {
            for( int i = 0; i < (int)subOptions.size() && foundResult == false; i++)
            {
                fContainer = subOptions[i];
                if( fContainer!=NULL)
                {
                    if( rNameToFind.compare( fContainer->get_name() ) ==0)
                    {
                        foundResult = true;
                        soughtContainer= fContainer;
                    }
                    else if( nestDown)
                    {
                         if( fContainer->find_resource_from_name(rNameToFind,nestDown)!=NULL)
                         {
                             foundResult = true;
                             soughtContainer = fContainer->find_resource_from_name(rNameToFind,nestDown);
                         }
                    }
                }
            }
        }
    }
    if( foundResult)
    {
        return soughtContainer;
    }
    return NULL;
}

GPE_ResourceContainer * GPE_ResourceContainer::find_resource_target(std::string rNameToFind, bool nestDown)
{
    int foundId = string_to_int(rNameToFind,-1);
    if( foundId > 0)
    {
        return find_resource_from_id(foundId,nestDown,false);
    }
    else
    {
        return find_resource_from_name(rNameToFind,nestDown);
    }
    return NULL;
}

std::string GPE_ResourceContainer::get_name()
{
    return opName;
}

std::string GPE_ResourceContainer::get_project_name()
{
    return projectParentName;
}

int GPE_ResourceContainer::get_global_id()
{
    return globalResouceId;
}

generalGameResource * GPE_ResourceContainer::get_held_resource()
{
    return heldResource;
}

int GPE_ResourceContainer::get_resource_count()
{
    int returnNumb = 0;
    if( !isFolder &&  !isSuperFolder &&  !isSuperProjectFolder)
    {
        returnNumb = 1;
    }
    GPE_ResourceContainer * tempContainer = NULL;
    for( int i = subOptions.size()-1; i >=0; i--)
    {
        tempContainer = subOptions[i];
        if( tempContainer!=NULL)
        {
            returnNumb+=tempContainer->get_resource_count();
        }
    }
    return returnNumb;
}


int GPE_ResourceContainer::get_resource_id()
{
    return resourceId;
}

int GPE_ResourceContainer::get_resource_type()
{
    return resourceType;
}


int GPE_ResourceContainer::get_resource_image_frame()
{
    return spriteFrameNumber;
}

GPE_Sprite * GPE_ResourceContainer::get_resource_sprite()
{
    if( !isFolder && !isSuperProjectFolder)
    {
        if( resourceType == RESOURCE_TYPE_OBJECT )
        {
            gameObjectResource * heldGOResource = (gameObjectResource*) heldResource;
            if( heldGOResource!=NULL && heldGOResource->projectParentFolder!=NULL)
            {
                GPE_ResourceContainer * allSpritesFolder = heldGOResource->projectParentFolder->find_resource_from_name(RESOURCE_TYPE_NAMES[RESOURCE_TYPE_SPRITE]+"s");
                if( allSpritesFolder!=NULL)
                {
                    GPE_ResourceContainer *objTypeContainer = allSpritesFolder->find_resource_from_id(heldGOResource->spriteIndex);
                    if( objTypeContainer!=NULL)
                    {
                       spriteResource * heldSpriteResouce = (spriteResource*) objTypeContainer->heldResource;
                       if( heldSpriteResouce!=NULL)
                       {
                           if( heldSpriteResouce->spriteInEditor!=NULL)
                           {
                               return heldSpriteResouce->spriteInEditor;
                           }
                       }
                    }
                }
            }
        }
        else if( resourceType== RESOURCE_TYPE_SPRITE )
        {
            spriteResource * heldGOResource = (spriteResource*) heldResource;
            if( heldGOResource!=NULL && heldGOResource->projectParentFolder!=NULL)
            {
                if( heldGOResource->spriteInEditor!=NULL)
                {
                    return heldGOResource->spriteInEditor;
                }
            }
        }
    }
    return NULL;
}

GPE_Texture * GPE_ResourceContainer::get_resource_texture()
{
    if( !isFolder && !isSuperProjectFolder)
    {
        if( resourceType == RESOURCE_TYPE_TEXTURE )
        {
            textureResource * heldGOResource = (textureResource*) heldResource;
            if( heldGOResource!=NULL && heldGOResource->projectParentFolder!=NULL)
            {
                if( heldGOResource->textureInEditor!=NULL && heldGOResource->textureInEditor->get_width() > 0 )
                {
                    return heldGOResource->textureInEditor;
                }
            }
        }
        else if( resourceType== RESOURCE_TYPE_TILESHEET )
        {
            tilesheetResource * heldGOResource = (tilesheetResource*) heldResource;
            if( heldGOResource!=NULL && heldGOResource->projectParentFolder!=NULL)
            {
                if( heldGOResource->tilesheetInEditor!=NULL && heldGOResource->tilesheetInEditor->tsImage!=NULL)
                {
                    return heldGOResource->tilesheetInEditor->tsImage;
                }
            }
        }
    }
    return containerTexture;
}

int GPE_ResourceContainer::get_options_width()
{
    int maxFoundWith = 0;
    GPE_ResourceContainer * tempOption = NULL;
    for( int i = subOptions.size()-1; i>=0; i--)
    {
        tempOption = subOptions[i];
        if( tempOption!=NULL)
        {
            if( tempOption->strTexWidth > maxFoundWith)
            {
                maxFoundWith = tempOption->strTexWidth;
            }
        }
    }
    return maxFoundWith;
}

int GPE_ResourceContainer::get_size()
{
    return (int)subOptions.size();
}

void GPE_ResourceContainer::grab_useable_resources(std::vector <GPE_ResourceContainer * > &rVector)
{
    GPE_ResourceContainer * nResource = NULL;
    if( heldResource!=NULL )
    {
        rVector.push_back(this);
    }
    if( (int)subOptions.size()>0 )
    {
        for( int i= 0 ; i < (int)subOptions.size(); i++)
        {
            nResource = subOptions[i];
            if( nResource!=NULL)
            {
               nResource->grab_useable_resources(rVector);
            }
        }
    }
}

void GPE_ResourceContainer::integrate_into_synthax()
{
    if( heldResource!=NULL)
    {
        heldResource->integrate_into_synthax();
    }

    GPE_ResourceContainer * tSub = NULL;
    for( int i = 0; i < (int)subOptions.size(); i++)
    {
        tSub = subOptions[i];
        if( tSub!=NULL)
        {
            tSub->integrate_into_synthax();
        }
    }
}

bool GPE_ResourceContainer::is_folder()
{

    return isFolder;
}

bool GPE_ResourceContainer::is_super_folder()
{
    return isSuperFolder;
}

bool GPE_ResourceContainer::is_super_project_folder()
{
    return isSuperProjectFolder;
}

bool GPE_ResourceContainer::is_child_of(GPE_ResourceContainer * otherContainer)
{
    if( otherContainer!=NULL)
    {
        int i;
        GPE_ResourceContainer * tempSubOption = NULL;
        if( matches(otherContainer)==1 )
        {
            return true;
        }
        for( i = subOptions.size()-1; i >=0; i--)
        {
            tempSubOption = subOptions[i];
            if( tempSubOption!=NULL)
            {
                if( tempSubOption->is_child_of(otherContainer) )
                {
                    return true;
                }
            }
        }
    }
    return false;
}

bool GPE_ResourceContainer::can_obtain(GPE_ResourceContainer * otherContainer)
{
    if( otherContainer!=NULL)
    {
        if( otherContainer->is_super_folder()==false && otherContainer->is_super_project_folder()==false )
        {
            if(  projectParentFileName.compare(otherContainer->projectParentFileName )==0 && get_resource_type()==otherContainer->get_resource_type() )
            {
                if( otherContainer->is_child_of(this) ==false )
                {
                    return true;
                }
                else
                {
                    record_error("Can not move["+otherContainer->get_name()+"] into ["+get_name()+"] folder.");
                }
            }
            else
            {
                record_error("Can not move["+otherContainer->get_name()+"] into ["+get_name()+"] folder[Different Folder Type].");
            }
        }
        else
        {
            record_error("Can not move super folder["+otherContainer->get_name()+".Illegal editor operation.");
        }
    }
    return false;
}

int GPE_ResourceContainer::matches(GPE_ResourceContainer * otherContainer)
{
    if( otherContainer!=NULL)
    {
        if( get_global_id()==otherContainer->get_global_id() )
        {
            if( otherContainer->isFolder== isFolder)
            {
                if( projectParentFileName.compare(otherContainer->projectParentFileName )==0)
                {
                    if( otherContainer->heldResource!=NULL && heldResource!=NULL)
                    {
                        if( resourceType == otherContainer->resourceType)
                        {
                            if( resourceId==otherContainer->resourceId)
                            {
                                return 1;
                            }
                        }
                    }
                    else if( otherContainer->heldResource==NULL && heldResource==NULL)
                    {
                        if( resourceType == otherContainer->resourceType)
                        {
                            if( resourceId==otherContainer->resourceId)
                            {
                                return 1;
                            }
                        }

                    }
                }
            }
            return 0;
        }
    }
    return -1;
}

void GPE_ResourceContainer::open_folder()
{
    subMenuIsOpen = true;
}

void GPE_ResourceContainer::preprocess_container(std::string alternatePath, int backupId)
{
    if( heldResource!=NULL)
    {
        heldResource->preprocess_self(alternatePath);
    }
    GPE_ResourceContainer * cResource = NULL;
    for(int i = 0; i<(int)subOptions.size();i+=1)
    {
        cResource = subOptions[i];
        if(cResource != NULL)
        {
            cResource->preprocess_container();
            cResource->detect_name_change(true);
        }
    }
}

void GPE_ResourceContainer::prerender_self(GPE_Renderer * cRender)
{

    if( heldResource!=NULL)
    {
        heldResource->prerender_self(cRender);
    }
    GPE_ResourceContainer * tSubOption= NULL;
    for( int i = 0; i < (int)subOptions.size(); i++)
    {
        tSubOption = subOptions[i];
        if( tSubOption!=NULL)
        {
            tSubOption->prerender_self(cRender);
        }
    }
}

int GPE_ResourceContainer::process_container(int xPos, int yPos, int selectedId, SDL_Rect * viewedSpace, SDL_Rect * cam, bool mouseInRange )
{
    int returnAnswer = -1;
    int lxPos = xPos-cam->x+viewedSpace->x;
    int lyPos = yPos-cam->y+viewedSpace->y;
    int lx2Pos = lxPos+cam->w;
    int ly2Pos = lyPos+RESOURCE_kb_AREA_HEIGHT;
    bool folderOpened = false;
    subContentsModified = false;
    foundX2Pos = xPos+strTexWidth+RESOURCE_kb_AREA_HEIGHT*3/2;
    if( isFolder || isSuperFolder || isSuperProjectFolder )
    {
        GPE_ResourceContainer * cResource = NULL;
        int subYPos = yPos+RESOURCE_kb_AREA_HEIGHT;
        if( mouseInRange && userInput->check_mouse_pressed(0) )
        {
            if(point_between(userInput->mouse_x,userInput->mouse_y,lxPos,lyPos,lx2Pos,ly2Pos) )
            {
                CURRENT_PROJECT_NAME = projectParentFileName;
                CURRENT_PROJECT = GPE_MAIN_GUI->find_project_from_filename(CURRENT_PROJECT_NAME);
                if( CURRENT_PROJECT==NULL)
                {
                    record_error("Null Project Found for"+opName+".");
                }
                if( !isSuperFolder && !isSuperProjectFolder)
                {
                    RESOURCE_TO_DRAG = this;
                }
            }
        }
        else if(mouseInRange && userInput->check_mouse_released(0) )
        {
            if(point_between(userInput->mouse_x,userInput->mouse_y,lxPos,lyPos,lx2Pos,ly2Pos) )
            {
                returnAnswer = globalResouceId;
                CURRENT_PROJECT_NAME = projectParentFileName;
                CURRENT_PROJECT = GPE_MAIN_GUI->find_project_from_filename(CURRENT_PROJECT_NAME);
                if( CURRENT_PROJECT==NULL)
                {
                    record_error("Null Project Found for"+opName+".");
                }
                bool openAllowed = true;
                if( RESOURCE_TO_DRAG!=NULL)
                {
                    LAST_CLICKED_RESOURCE = this;
                    if( RESOURCE_TO_DRAG->matches(this)!=1)
                    {
                        openAllowed = false;
                    }
                }
                if( openAllowed)
                {
                    if( !subMenuIsOpen)
                    {
                        folderOpened = true;
                    }
                    else
                    {
                        subMenuIsOpen = false;
                    }
                    if(folderOpened  )
                    {
                        subMenuIsOpen = true;
                        //opens folder
                        /*
                        cResource = NULL;
                        for(int i = 0; i<(int)subOptions.size();i+=1)
                        {
                            cResource = subOptions[i];
                            if(cResource != NULL)
                            {
                                cResource->process_container(xPos+RESOURCE_kb_AREA_HEIGHT,subYPos,selectedId,viewedSpace,cam,mouseInRange);
                                subYPos += cResource->optionBox.h;
                                optionBox.h += cResource->optionBox.h;
                            }
                        }*/
                    }
                }
            }
        }
        else if( mouseInRange && userInput->check_mouse_released(1) )
        {
            if(point_within(userInput->mouse_x,userInput->mouse_y,lxPos,lyPos,lx2Pos,ly2Pos) )
            {
                returnAnswer = globalResouceId;
                CURRENT_PROJECT_NAME = projectParentFileName;
                CURRENT_PROJECT = GPE_MAIN_GUI->find_project_from_filename(CURRENT_PROJECT_NAME);
                if( CURRENT_PROJECT==NULL)
                {
                    record_error("Null Project Found for"+opName+".");
                }
                LAST_CLICKED_RESOURCE = this;
                LAST_CLICKED_RESTYPE = resourceType;
                RESOURCEMENU_WAS_RIGHTCLICKED = true;
                RESOURCE_TO_DRAG = NULL;
            }
        }

        if( subMenuIsOpen )
        {
            cResource = NULL;
            subYPos = yPos+RESOURCE_kb_AREA_HEIGHT;
            optionBox.h = RESOURCE_kb_AREA_HEIGHT;
            int subAnswer = -1;
            for(int i = 0; i<(int)subOptions.size();i+=1)
            {
                cResource = subOptions[i];
                if(cResource != NULL)
                {
                    subAnswer = cResource->process_container(xPos,subYPos,selectedId,viewedSpace,cam,mouseInRange);
                    if(subAnswer>=0)
                    {
                        returnAnswer = subAnswer;
                    }
                    optionBox.h+= cResource->optionBox.h;
                    subYPos += cResource->optionBox.h;
                    if( cResource->resouceNameChanged)
                    {
                        subContentsModified= true;
                    }
                    if ( cResource->heldResource!=NULL)
                    {
                        if( cResource->heldResource->is_modified() )
                        {
                            subContentsModified = true;
                        }
                    }
                    if( foundX2Pos <  cResource->foundX2Pos )
                    {
                        foundX2Pos = cResource->foundX2Pos;
                    }
                }
            }
        }
        else
        {
            optionBox.h = RESOURCE_kb_AREA_HEIGHT;
            foundX2Pos = xPos+strTexWidth+RESOURCE_kb_AREA_HEIGHT/2;
        }
    }
    else
    {
        optionBox.h = RESOURCE_kb_AREA_HEIGHT;
        if( resourceType == RESOURCE_TYPE_SPRITE)
        {
            spriteResource * heldSpriteC = (spriteResource *)heldResource;
            if( heldSpriteC!=NULL)
            {
                spriteFrameNumber = 0;
                containerSprite = heldSpriteC->spriteInEditor;
                if( containerSprite==NULL)
                {
                    containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resouces/buttons/magnet.png");
                }
            }
        }
        else
        {
            set_basic_image_value();
        }

        if( mouseInRange && userInput->check_mouse_doubleclicked(0))
        {
            if( point_within(userInput->mouse_x,userInput->mouse_y,lxPos,lyPos,lx2Pos,ly2Pos ) )
            {
                if(globalResouceId == selectedId)
                {
                    GPE_set_selected_gresource(heldResource);
                }
                returnAnswer = globalResouceId;
                CURRENT_PROJECT_NAME = projectParentFileName;
                CURRENT_PROJECT = GPE_MAIN_GUI->find_project_from_filename(CURRENT_PROJECT_NAME);
                if( CURRENT_PROJECT==NULL)
                {
                    record_error("Null Project Found for"+opName+".");
                }
                LAST_CLICKED_RESOURCE = this;
                RESOURCE_TO_DRAG = NULL;
            }
        }
        else if( mouseInRange && userInput->check_mouse_released(0) )
        {
            if( point_within(userInput->mouse_x,userInput->mouse_y,lxPos,lyPos,lx2Pos,ly2Pos ) )
            {
                if(globalResouceId == selectedId)
                {
                    //GPE_set_selected_gresource(heldResource);
                }
                returnAnswer = globalResouceId;
                CURRENT_PROJECT_NAME = projectParentFileName;
                CURRENT_PROJECT = GPE_MAIN_GUI->find_project_from_filename(CURRENT_PROJECT_NAME);
                if( CURRENT_PROJECT==NULL)
                {
                    record_error("Null Project Found for"+opName+".");
                }
                LAST_CLICKED_RESOURCE = this;
            }
        }
        else if( mouseInRange && userInput->check_mouse_released(1) )
        {
            if( point_within(userInput->mouse_x,userInput->mouse_y,viewedSpace->x-cam->x,lyPos,lx2Pos,ly2Pos) )
            {
                returnAnswer = globalResouceId;
                CURRENT_PROJECT_NAME = projectParentFileName;
                CURRENT_PROJECT = GPE_MAIN_GUI->find_project_from_filename(CURRENT_PROJECT_NAME);
                if( CURRENT_PROJECT==NULL)
                {
                    record_error("Null Project Found for"+opName+".");
                }
                LAST_CLICKED_RESOURCE = this;
                RESOURCEMENU_WAS_RIGHTCLICKED = true;
            }
        }
        else if( mouseInRange && userInput->check_mouse_pressed(0) )
        {
            if( point_within(userInput->mouse_x,userInput->mouse_y,viewedSpace->x-cam->x,lyPos,lx2Pos,ly2Pos) )
            {
                RESOURCE_TO_DRAG = this;
            }
        }
        if(heldResource!=NULL)
        {
            std::string heldResName = heldResource->get_name();
            if( opName!=heldResName )
            {
                if( heldResName.size()>0 && is_alnum(heldResName,false,true)  )
                {
                    resouceNameChanged = true;
                    opName = heldResName;
                }
            }
        }
    }
    return returnAnswer;
}

bool GPE_ResourceContainer::read_data_from_projectfile(std::ofstream * fileTarget)
{
    if( fileTarget!=NULL)
    {
        if( fileTarget->is_open() )
        {
            return true;
        }
    }
    return false;
}

void GPE_ResourceContainer::render_contained_object(GPE_Renderer * cRender,SDL_Rect *viewedSpace ,SDL_Rect *cam)
{

}

void GPE_ResourceContainer::render_option(GPE_Renderer * cRender, int xPos, int yPos, int selectedIdNumber, SDL_Rect * viewedSpace, SDL_Rect * cam , bool renderSubOptions, bool renderAutomatically)
{
    if( cRender==NULL)
    {
        cRender = MAIN_RENDERER;
    }

    bool selfIsInView = false;
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( cam!=NULL && viewedSpace!=NULL)
    {
        int rendY = yPos;
        if( rendY>=cam->y && rendY <=cam->y+cam->h )
        {
            selfIsInView = true;
        }
        else if( rendY+RESOURCE_kb_AREA_HEIGHT >=cam->y && rendY+RESOURCE_kb_AREA_HEIGHT <=cam->y+cam->h  )
        {
            selfIsInView = true;
        }

        if( isFolder && renderSubOptions )
        {
            if(subMenuIsOpen)
            {
                if( (selfIsInView || renderAutomatically) && (int)subOptions.size() > 0 )
                {
                    render_new_text(cRender,xPos-cam->x,yPos-cam->y,"-",GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_RESOURCEBAR,FA_LEFT,FA_TOP);
                }
                GPE_ResourceContainer * foundContainer;
                int subXPos = xPos+RESOURCE_kb_AREA_HEIGHT;
                int subYPos = yPos+RESOURCE_kb_AREA_HEIGHT;
                for(int i=0; i< (int)subOptions.size();i+=1)
                {
                    foundContainer = subOptions[i];
                    if(foundContainer!=NULL)
                    {
                        foundContainer->render_option(cRender,subXPos,subYPos,selectedIdNumber,viewedSpace,cam,renderSubOptions,renderAutomatically);
                        subYPos+=foundContainer->optionBox.h;
                    }
                }
            }
            else if( (selfIsInView || renderAutomatically ) && (int)subOptions.size() > 0 )
            {
                render_new_text(cRender,xPos-cam->x,yPos-cam->y,"+",GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_RESOURCEBAR,FA_LEFT,FA_TOP);
            }
        }

        if( selfIsInView || renderAutomatically)
        {
            if(globalResouceId ==selectedIdNumber && projectParentName.compare(CURRENT_PROJECT_NAME)==0 )
            {
                render_rectangle(cRender,xPos-cam->x,yPos-cam->y,xPos+RESOURCE_kb_AREA_HEIGHT*2+GENERAL_NEAR_ICON_YPADDING+strTexWidth-cam->x,yPos+16-cam->y,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,false,64);
            }
            if( (isFolder || isSuperFolder || isSuperProjectFolder ) && containerTexture!=NULL )
            {
                if(projectParentName.compare(CURRENT_PROJECT_NAME)==0 && isSuperProjectFolder)
                {
                    render_texture_resized(cRender,containerTexture,xPos+GENERAL_PLUSMINUX_ICON_SIZE-cam->x,yPos-cam->y,RESOURCE_kb_AREA_HEIGHT,RESOURCE_kb_AREA_HEIGHT,NULL,NULL,FA_LEFT,FA_TOP,GPE_MAIN_TEMPLATE->Main_Folder_Highlighted_Color);
                }
                else
                {
                    render_texture_resized(cRender,containerTexture,xPos+GENERAL_PLUSMINUX_ICON_SIZE-cam->x,yPos-cam->y,RESOURCE_kb_AREA_HEIGHT,RESOURCE_kb_AREA_HEIGHT,NULL,NULL,FA_LEFT,FA_TOP,GPE_MAIN_TEMPLATE->Main_Folder_Color);
                }
            }
            else if( !isSuperProjectFolder && !isFolder && !isSuperFolder )
            {
                render_image(cRender,xPos,yPos,RESOURCE_kb_AREA_HEIGHT,RESOURCE_kb_AREA_HEIGHT,NULL,cam);
            }

            render_new_text(cRender,xPos+RESOURCE_kb_AREA_HEIGHT+GENERAL_PLUSMINUX_ICON_SIZE-cam->x,yPos-cam->y+RESOURCE_kb_AREA_HEIGHT/2,opName,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_RESOURCEBAR,FA_LEFT,FA_CENTER);
            /*if(heldResource!=NULL)
            {
                if(heldResource->is_modified() || resouceNameChanged)
                {
                    render_new_text(cRender,xPos+GENERAL_PLUSMINUX_ICON_SIZE-cam->x,yPos-cam->y,"!",GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,FONT_RESOURCEBAR,FA_RIGHT,FA_TOP);
                }
            }
            else if( subContentsModified)
            {
                render_new_text(cRender,xPos-cam->x,yPos-cam->y,"!!",GPE_MAIN_TEMPLATE->Button_Box_Selected_Color,FONT_RESOURCEBAR,FA_RIGHT,FA_TOP);
            }*/

            if( (isSuperFolder || isSuperProjectFolder || resourceType == RESOURCE_TYPE_PROJECT_SETTINGS )&& renderAutomatically==false )
            {
                render_horizontal_line_color(cRender,rendY-cam->y,0,viewedSpace->w,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,32);
            }
            lastResTypeRendered = resourceType;
        }
    }
}

void GPE_ResourceContainer::render_image(GPE_Renderer * cRender, int xPos, int yPos, int rWidth, int rHeight,SDL_Rect * viewedSpace ,SDL_Rect *cam, GPE_Color * renderColor)
{
    cam = GPE_find_camera(cam);
    viewedSpace = GPE_find_camera(viewedSpace);
    bool imageWasRendered = false;

    if( (isFolder || isSuperProjectFolder) && containerTexture!=NULL )
    {
        if( rWidth <=0 && rHeight <= 0)
        {
            rWidth = 32;
            rHeight = 32;
        }
        if(projectParentName.compare(CURRENT_PROJECT_NAME)==0 && isSuperProjectFolder)
        {
            render_texture_resized(cRender,containerTexture,xPos+GENERAL_PLUSMINUX_ICON_SIZE-cam->x,yPos-cam->y,rWidth,rHeight,NULL,NULL,FA_LEFT,FA_TOP,GPE_MAIN_TEMPLATE->Main_Folder_Highlighted_Color);
        }
        else
        {
            render_texture_resized(cRender,containerTexture,xPos+GENERAL_PLUSMINUX_ICON_SIZE-cam->x,yPos-cam->y,rWidth,rHeight,NULL,NULL,FA_LEFT,FA_TOP,GPE_MAIN_TEMPLATE->Main_Folder_Color);
        }
    }
    else if( !isSuperProjectFolder)
    {
        if( resourceType == RESOURCE_TYPE_OBJECT )
        {
            gameObjectResource * heldGOResource = (gameObjectResource*) heldResource;
            if( heldGOResource!=NULL && heldGOResource->projectParentFolder!=NULL)
            {
                GPE_ResourceContainer * allObjsFolder = heldGOResource->projectParentFolder->find_resource_from_name(RESOURCE_TYPE_NAMES[RESOURCE_TYPE_SPRITE]+"s");
                if( allObjsFolder!=NULL)
                {
                    GPE_ResourceContainer *objTypeContainer = allObjsFolder->find_resource_from_id(heldGOResource->spriteIndex);
                    if( objTypeContainer!=NULL)
                    {
                        objTypeContainer->render_image(cRender,xPos, yPos, rWidth, rHeight,viewedSpace,cam, renderColor);
                        imageWasRendered= true;
                    }
                }
            }
        }
        else if( resourceType == RESOURCE_TYPE_TEXTURE )
        {
            textureResource * heldGOResource = (textureResource*) heldResource;
            if( heldGOResource!=NULL && heldGOResource->projectParentFolder!=NULL)
            {
                if( heldGOResource->textureInEditor!=NULL)
                {
                    heldGOResource->textureInEditor->render_tex_resized(cRender,xPos-cam->x, yPos-cam->y, rWidth, rHeight,NULL,NULL);
                    imageWasRendered= true;
                }
            }
        }
        else if( resourceType == RESOURCE_TYPE_TILESHEET )
        {
            tilesheetResource * heldGOResource = (tilesheetResource*) heldResource;
            if( heldGOResource!=NULL && heldGOResource->projectParentFolder!=NULL)
            {
                if( heldGOResource->tilesheetInEditor!=NULL && heldGOResource->tilesheetInEditor->tsImage!=NULL)
                {
                    heldGOResource->tilesheetInEditor->tsImage->render_tex_resized(cRender,xPos-cam->x, yPos-cam->y, rWidth, rHeight,NULL,NULL);
                    imageWasRendered= true;
                }
            }
        }
        else if( resourceType== RESOURCE_TYPE_SPRITE )
        {
            spriteResource * heldGOResource = (spriteResource*) heldResource;
            if( heldGOResource!=NULL && heldGOResource->projectParentFolder!=NULL)
            {
                if( heldGOResource->spriteInEditor!=NULL && heldGOResource->spriteInEditor->spriteTexture!=NULL)
                {
                    render_sprite_ext(cRender,heldGOResource->spriteInEditor,heldGOResource->get_preview_frame(),xPos-cam->x,yPos-cam->y,rWidth,rHeight,renderColor);
                    imageWasRendered= true;
                }
            }
        }
    }
    if( imageWasRendered==false && containerTexture!=NULL )
    {
        GPE_Color * imageColor  = GPE_MAIN_TEMPLATE->Main_Box_Font_Color;

        if( rWidth <=0 && rHeight <= 0)
        {
            rWidth = rHeight = 32;
        }
        if(projectParentName.compare(CURRENT_PROJECT_NAME)==0 && isSuperProjectFolder)
        {
            render_texture_resized(cRender,containerTexture,xPos-cam->x,yPos-cam->y,rWidth,rHeight,NULL,NULL,FA_LEFT,FA_TOP,GPE_MAIN_TEMPLATE->Main_Box_Font_Color);
        }
        else
        {
            render_texture_resized(cRender,containerTexture,xPos-cam->x,yPos-cam->y,rWidth,rHeight,NULL,NULL,FA_LEFT,FA_TOP,GPE_MAIN_TEMPLATE->Main_Box_Faded_Font_Color);
        }
    }

}

void GPE_ResourceContainer::remove_resource(GPE_ResourceContainer * otherContainer, bool deleteResource)
{
    if( otherContainer!=NULL )
    {
        GPE_ResourceContainer * tContainer = NULL;
        int resIdToDelete = otherContainer->get_global_id();
        for( int i = (int)subOptions.size()-1; i>=0; i--)
        {
            tContainer = subOptions[i];
            if( tContainer!=NULL && tContainer->get_global_id()==resIdToDelete )
            {
                optionBox.h-=otherContainer->optionBox.h;
                //otherContainer->parentResource = NULL;
                if( deleteResource )
                {
                    GPE_Main_TabManager->close_resource_tab(projectParentName , resIdToDelete );
                    delete tContainer;
                    tContainer = NULL;
                    otherContainer = NULL;
                    //record_error("Rez deletedish...");
                }
                subOptions.erase( subOptions.begin()+i );
                //record_error("Rez deleted...");
            }
        }
    }
}

void GPE_ResourceContainer::save_container(std::string alternatePath, int backupId)
{
    if( heldResource!=NULL)
    {
        heldResource->save_resource(alternatePath, backupId);
    }
}

int GPE_ResourceContainer::search_for_string(std::string needle)
{
    int foundStrings = 0;
    GPE_ResourceContainer * fContainer  = NULL;
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        fContainer = subOptions[i];
        if( fContainer!=NULL)
        {
            foundStrings+=fContainer->search_for_string(needle);
        }
    }
    if( heldResource!=NULL)
    {
        foundStrings+= heldResource->search_for_string(needle);
    }
    return foundStrings;
}

int GPE_ResourceContainer::search_and_replace_string(std::string needle, std::string newStr)
{
    int foundStrings = 0;
    GPE_ResourceContainer * fContainer  = NULL;
    for( int i = (int)subOptions.size()-1; i >=0; i--)
    {
        fContainer = subOptions[i];
        if( fContainer!=NULL)
        {
            foundStrings+=fContainer->search_and_replace_string(needle, newStr);
        }
    }
    if( heldResource!=NULL)
    {
        foundStrings+=heldResource->search_and_replace_string(needle, newStr);
    }
    return foundStrings;
}
void GPE_ResourceContainer::set_basic_image_value()
{
    if( isFolder)
    {
        containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/folder.png");
    }
    else
    {
        switch( resourceType)
        {
            case RESOURCE_TYPE_SPRITE:
                containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/magnet.png");
            break;
            case RESOURCE_TYPE_TEXTURE:
                   containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/image.png");
            break;
            case RESOURCE_TYPE_TILESHEET:
                   containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/th-large.png");
            break;
            case RESOURCE_TYPE_AUDIO:
                containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/volume-up.png");
            break;
            case RESOURCE_TYPE_VIDEO:
                containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/film.png");
            break;
            case RESOURCE_TYPE_OBJECT:
                containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/automobile-colored.png");
            break;
            case RESOURCE_TYPE_FUNCTION:
                containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/code.png");
            break;
            case RESOURCE_TYPE_FONT:
                containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/font.png");
            break;
            case RESOURCE_TYPE_SCENE:
                containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/area-chart.png");
            break;
            default:
                containerTexture = rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/diamond.png");
            break;
        }
    }
}

void GPE_ResourceContainer::set_held_resource(generalGameResource * newGenResource)
{
    heldResource = newGenResource;
}

void GPE_ResourceContainer::set_global_id(int newId)
{
    globalResouceId = newId;
    if( heldResource!=NULL)
    {
        heldResource->set_global_rid(newId);
    }
}

void GPE_ResourceContainer::set_global_html5id(int newId)
{
    html5BuildGlobalId = newId;
    if( heldResource!=NULL)
    {
        heldResource->html5BuildGlobalId = newId;
    }
}

void GPE_ResourceContainer::set_name(std::string newName)
{
    opName = newName;
    int textW = 0;
    int textH = 0;

    if( (int)opName.size()>0 && FONT_TOOLBAR!=NULL)
    {
        FONT_TOOLBAR->get_metrics(opName,&textW, &textH);
    }
    strTexWidth = textW;
    strTexHeight = textH;
    if( heldResource!=NULL)
    {
        heldResource->set_name(newName);
    }
}

void GPE_ResourceContainer::set_project_parent_name(std::string newParentName)
{
    projectParentFileName = newParentName;
    if( heldResource!=NULL)
    {
        heldResource->parentProjectName = projectParentFileName;
    }
    int sSize = (int)subOptions.size();
    if( sSize > 0)
    {
        GPE_ResourceContainer * cResource = NULL;
        for( int i = 0; i < sSize; i++)
        {
            cResource = subOptions[i];
            if( cResource!=NULL)
            {
                cResource->set_project_parent_name(newParentName);
            }
        }
    }
}

bool GPE_ResourceContainer::write_data_into_projectfile(std::ofstream * fileTarget, int nestedFoldersIn)
{
    bool foundProblem = false;
    std::string nestedTabsStr = generate_tabs( nestedFoldersIn );
    if( fileTarget!=NULL)
    {
        if( fileTarget->is_open() )
        {
            if( isSuperProjectFolder)
            {
                *fileTarget << "[Project=" << opName<< "]\n";
            }
            else if(isSuperFolder)
            {
                *fileTarget << nestedTabsStr << "[SuperFolder=" << opName<< "]\n";
                displayMessageTitle = "Saving SuperFolder";
                displayMessageSubtitle = opName;
                displayMessageString = "...";
                display_user_messaage();
            }
            else if( isFolder)
            {
                *fileTarget << nestedTabsStr << "[Folder=" << opName << "," << globalResouceId << "]\n";
            }
            if( heldResource!=NULL)
            {
                set_name( heldResource->get_current_name() );
                heldResource->save_resource();
                foundProblem = heldResource->write_data_into_projectfile(fileTarget,nestedFoldersIn);
            }
            int sSize = (int)subOptions.size();
            if( sSize > 0)
            {
                GPE_ResourceContainer * cResource = NULL;
                for( int i = 0; i < sSize; i++)
                {
                    cResource = subOptions[i];
                    if( cResource!=NULL)
                    {
                        if( cResource->write_data_into_projectfile(fileTarget,nestedFoldersIn+1) )
                        {
                            foundProblem = true;
                        }
                    }
                }
            }
            if( isSuperProjectFolder)
            {
                *fileTarget << nestedTabsStr << "[/Project]\n";
            }
            else if(isSuperFolder)
            {
                *fileTarget << nestedTabsStr << "[/SuperFolder]\n";
            }
            else if( isFolder)
            {
                *fileTarget << nestedTabsStr << "[/Folder]\n";
            }
        }
    }
    if( foundProblem==false)
    {
        resouceNameChanged = false;
    }
    return !foundProblem;
}

GPE_ProjectFolder::GPE_ProjectFolder(std::string name, std::string directoryIn, std::string fileNameIn)
{
    int iLayerN = 0;
    for( iLayerN = 0; iLayerN < 32; iLayerN++)
    {
        projectLayerNames[iLayerN] = "";
    }

    projectLayerNames[0] = "Default Background Layer";
    projectLayerNames[1] = "Default Object Layer";
    for( iLayerN = 2; iLayerN < 24; iLayerN++)
    for( iLayerN = 2; iLayerN < 24; iLayerN++)
    {
        projectLayerNames[iLayerN] = "Custom Layer"+int_to_string(iLayerN-2);
    }
    for( iLayerN = 24; iLayerN < 32; iLayerN++)
    {
        projectLayerNames[iLayerN] = "Default Tile Layer"+int_to_string(iLayerN-24);
    }


    myProjectLanguage = PROJECT_LANGUAGE_JS;
    time( &lastTimeBackedUp);
    GLOBAL_REZ_ID_COUNT = 0;
    projectName = name;
    projectStartDirectoryName = projectDirectory = directoryIn;
    projectFileName = fileNameIn;
    RESC_PROJECT_FOLDER = NULL;
    RESC_SPRITES = NULL;
    RESC_TEXTURES = NULL;
    RESC_TILESHEETS = NULL;
    RESC_3DMODELS = NULL;
    RESC_AUDIO = NULL;
    RESC_VIDEOS = NULL;
    RESC_FUNCTIONS = NULL;
    RESC_OBJECTS = NULL;
    RESC_PATHS = NULL;
    RESC_SCENES = NULL;
    RESC_ACHIEVEMENTS = NULL;
    RESC_FONTS = NULL;
    RESC_SHADERS = NULL;
    for( int i = 0; i < res_type_count; i++)
    {
         RESC_ALL[i] = NULL;
         CREATED_RESOURCE_COUNT[i] = 0;
    }
    RESC_PROJECT_FOLDER = GPE_MAIN_GUI->mainResourceBar->add_project_folder(0,projectFileName,projectName);
    RESC_PROJECT_FOLDER->parentProjectDirectory = projectDirectory;
    RESC_PROJECT_FOLDER->projectParentFileName = projectFileName;
    RESC_PROJECT_FOLDER->open_folder();

    RESC_TEXTURES =  RESC_ALL[RESOURCE_TYPE_TEXTURE] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_TEXTURE,"Textures", increment_resouce_count(), restype_superfolder);
    RESC_TILESHEETS =  RESC_ALL[RESOURCE_TYPE_TILESHEET] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_TILESHEET,"Tilesheets", increment_resouce_count(), restype_superfolder);
    RESC_SPRITES =  RESC_ALL[RESOURCE_TYPE_SPRITE] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_SPRITE,"Sprites", increment_resouce_count(), restype_superfolder);
    RESC_AUDIO =  RESC_ALL[RESOURCE_TYPE_AUDIO] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_AUDIO,"Audio", increment_resouce_count(), restype_superfolder);
    RESC_VIDEOS =  RESC_ALL[RESOURCE_TYPE_VIDEO] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_VIDEO,"Videos", increment_resouce_count(), restype_superfolder);
    RESC_FUNCTIONS =  RESC_ALL[RESOURCE_TYPE_FUNCTION] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_FUNCTION,"Functions", increment_resouce_count(), restype_superfolder);
    RESC_PATHS =  RESC_ALL[RESOURCE_TYPE_PATH] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_PATH,"Paths", increment_resouce_count(), restype_superfolder);
    RESC_OBJECTS =  RESC_ALL[RESOURCE_TYPE_OBJECT] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_OBJECT,"Objects", increment_resouce_count(), restype_superfolder);
    RESC_SCENES =  RESC_ALL[RESOURCE_TYPE_SCENE] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_SCENE,"Scenes", increment_resouce_count(), restype_superfolder);
    //RESC_ACHIEVEMENTS =  RESC_ALL[RESOURCE_TYPE_ACHIEVEMENT] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_ACHIEVEMENT,"Achievements", increment_resouce_count(), restype_superfolder);
    RESC_FONTS =  RESC_ALL[RESOURCE_TYPE_FONT] =RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_FONT,"Fonts", increment_resouce_count(), restype_superfolder);
    RESC_DICTIONARIES =  RESC_ALL[RESOURCE_TYPE_DICTIONARY]  = NULL;//=RESC_PROJECT_FOLDER->add_newtype_folder(RESOURCE_TYPE_DICTIONARY,"Dictionaries", increment_resouce_count(), restype_superfolder);

    int projectPropertiesId = increment_resouce_count();
    RESC_PROJECT_SETTINGS = new GPE_ResourceContainer(projectFileName, RESOURCE_TYPE_NAMES[RESOURCE_TYPE_PROJECT_SETTINGS] , RESOURCE_TYPE_PROJECT_SETTINGS,projectPropertiesId ,false, projectPropertiesId,-1);
    RESC_PROJECT_SETTINGS->parentProjectDirectory = projectDirectory;

    RESC_PROJECT_FOLDER->add_resource_container(RESC_PROJECT_SETTINGS,true);
    projectPropertiesResource * projectProps = new projectPropertiesResource(RESC_PROJECT_FOLDER);
    projectProps->set_name( RESOURCE_TYPE_NAMES[RESOURCE_TYPE_PROJECT_SETTINGS] );
    projectProps->set_parent_project( projectFileName );
    RESC_PROJECT_SETTINGS->set_held_resource(projectProps);
    GLOBAL_REZ_ID_COUNT = 1000;
    projectFilePreviousVersion = projectFileVersion = GPE_VERSION_DOUBLE_NUMBER;
}

GPE_ProjectFolder::~GPE_ProjectFolder()
{
    record_error("Deleting RESC_PROJECT_FOLDER" );
    if( RESC_PROJECT_FOLDER!=NULL )
    {
        delete RESC_PROJECT_FOLDER;
        RESC_PROJECT_FOLDER = NULL;
    }
}

bool GPE_ProjectFolder::add_project_function(std::string nName, std::string nDescription,std::string  nParameters, std::string tFunctionReturnType,std::string nScope)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)projectFunctions.size()-1; i>=0; i--)
    {
        tTerm = projectFunctions[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==nName)
            {
                return false;
            }
        }
    }
    tTerm = new GPE_Compiler_Term(nName, nParameters, tFunctionReturnType, nDescription, CTERM_FUNCTION,nScope);
    projectFunctions.push_back( tTerm);
    return true;
}

bool GPE_ProjectFolder::add_project_keyword(std::string nName, std::string nDescription,int nType,std::string nScope)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)projectKeywords.size()-1; i>=0; i--)
    {
        tTerm = projectKeywords[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==nName)
            {
                return false;
            }
        }
    }
    tTerm = new GPE_Compiler_Term(nName, "", "", nDescription, nType,nScope);
    projectKeywords.push_back( tTerm);
    return true;
}

void GPE_ProjectFolder::clear_project_functions()
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)projectFunctions.size()-1; i>=0; i--)
    {
        tTerm = projectFunctions[i];
        if( tTerm!=NULL)
        {
            delete tTerm;
            tTerm = NULL;
        }
    }
    projectFunctions.clear();
}

void GPE_ProjectFolder::clear_project_keywords()
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)projectKeywords.size()-1; i>=0; i--)
    {
        tTerm = projectKeywords[i];
        if( tTerm!=NULL)
        {
            delete tTerm;
            tTerm = NULL;
        }
    }
    projectKeywords.clear();
}

bool GPE_ProjectFolder::export_and_play_native(bool launchProgram)
{
    if( RESC_PROJECT_SETTINGS!=NULL && RESC_PROJECT_SETTINGS->get_held_resource()!=NULL)
    {
        projectPropertiesResource * projectSettingsObject = (projectPropertiesResource*)RESC_PROJECT_SETTINGS->get_held_resource();
        return projectSettingsObject->export_and_play_native(launchProgram);
    }
    return false;
}

std::string GPE_ProjectFolder::find_project_function(std::string strBeingChecked, int startPos)
{
    GPE_Compiler_Term * tTerm = NULL;
    int strSize = (int)strBeingChecked.size();
    if( strSize>0 && strSize > startPos)
    {
        std::string strToSearch = "";
        int tempStrSize = 0;
        int j = 0;
        bool allMatched = false;

        for( int i = (int)projectFunctions.size()-1; i>=0; i--)
        {
            tTerm= projectFunctions[i];
            if( tTerm!=NULL)
            {
                strToSearch = tTerm->termString;

                tempStrSize = strToSearch.size();
                if(strSize >=  startPos+tempStrSize && tempStrSize>0)
                {
                    allMatched = true;
                    for( j = 0; j < tempStrSize; j++)
                    {
                        if(strBeingChecked[startPos+j]!=strToSearch[j])
                        {
                            allMatched = false;
                        }
                    }
                    if( allMatched ==true)
                    {
                        if( strSize >= startPos+tempStrSize)
                        {
                            //if( char_is_alnum(strBeingChecked[startPos+tempStrSize],false,false)==false )
                            {
                                return strToSearch;
                            }
                        }
                    }
                }
            }
        }
    }
    return "";
}

std::string GPE_ProjectFolder::find_project_keyword(std::string strBeingChecked, int startPos)
{
    GPE_Compiler_Term * tTerm = NULL;
    int strSize = (int)strBeingChecked.size();
    if( strSize>0 && strSize > startPos)
    {
        std::string strToSearch = "";
        int tempStrSize = 0;
        int j = 0;
        bool allMatched = false;
        for( int i = (int)projectKeywords.size()-1; i>=0; i--)
        {
            tTerm= projectKeywords[i];
            if( tTerm!=NULL)
            {
                strToSearch = tTerm->termString;

                tempStrSize = strToSearch.size();
                if(strSize >=  startPos+tempStrSize && tempStrSize>0)
                {
                    allMatched = true;
                    for( j = 0; j < tempStrSize; j++)
                    {
                        if(strBeingChecked[startPos+j]!=strToSearch[j])
                        {
                            allMatched = false;
                        }
                    }
                    if( allMatched ==true)
                    {
                        if( strSize >= startPos+tempStrSize)
                        {
                            if( char_is_alnum(strBeingChecked[startPos+tempStrSize],false,false)==false )
                            {
                                return strToSearch;
                            }
                        }
                    }
                }
            }
        }
    }
    return "";
}

bool GPE_ProjectFolder::clean_build_folder( int buildMetaTemplate )
{
    std::string projectBuildDirectory = "";
    std::string folderDeletionName  = "";
    if( buildMetaTemplate == GPE_BUILD_HTML5)
    {
        projectBuildDirectory  = fileToDir(projectFileName)+"/gpe_project/builds/html5";
        folderDeletionName = "HTML5";
    }
    else if( buildMetaTemplate == GPE_BUILD_WIIU)
    {
        projectBuildDirectory  = fileToDir(projectFileName)+"/gpe_project/builds/wiiu";
        folderDeletionName = "WiiU";
    }
    else if( buildMetaTemplate == GPE_BUILD_WINDOWS)
    {
        projectBuildDirectory  = fileToDir(projectFileName)+"/gpe_project/builds/windows";
        folderDeletionName = "WINDOWS";
    }
    else if( buildMetaTemplate == GPE_BUILD_LINUX)
    {
        projectBuildDirectory  = fileToDir(projectFileName)+"/gpe_project/builds/linux";
        folderDeletionName = "LINUX";
    }
    else if( buildMetaTemplate == GPE_BUILD_MAC)
    {
        projectBuildDirectory  = fileToDir(projectFileName)+"/gpe_project/builds/osx";
        folderDeletionName = "OSX";
    }
    if( (int)projectBuildDirectory.size() > 0 )
    {
        if( path_exists(projectBuildDirectory) )
        {
            if( display_get_prompt("[WARNING]Function deletion of "+folderDeletionName+" build folder?","Are you sure you will like to delete all the contents of this build directory? This action is irreversible!")==DISPLAY_QUERY_YES)
            {
                GPE_Main_Logs->log_build_line("---");
                GPE_Main_Logs->log_build_line("Cleaning Project ["+projectName+" build folder:");
                GPE_Main_Logs->log_build_line("["+projectBuildDirectory+"]...");
                int filesDeleted =  clean_folder(projectBuildDirectory);
                if( filesDeleted > 0)
                {
                    GPE_Main_Logs->log_build_line("Folder content files were deleted successfully. Estimated ["+int_to_string(filesDeleted)+"] files deleted...");
                }
                else
                {
                    GPE_Main_Logs->log_build_line("0 files were prepared for deleted.");
                }
                GPE_Main_Logs->log_build_line("---");
                return filesDeleted;
            }
        }
        else if( GPE_Main_Logs!=NULL )
        {
            GPE_Main_Logs->log_build_line("---");
            GPE_Main_Logs->log_build_line("Cleaning Project ["+projectName+" build folder:");
            GPE_Main_Logs->log_build_line("["+projectBuildDirectory+"] was not detected.");
            GPE_Main_Logs->log_build_line("Cleaning process aborted.");
        }
    }

    return false;
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_folder(GPE_ResourceContainer * folderContainer, std::string newName, int newResId )
{
    if( folderContainer!=NULL )
    {
        if( newResId < 0)
        {
            newResId = increment_resouce_count();
        }
        if( (int)newName.size() <= 0)
        {
            newName = "New Folder";
        }
        GPE_ResourceContainer *  newFolder= folderContainer->add_resource_folder(newName,newResId,-1);
        newFolder->projectParentFileName = projectFileName;
        //folderContainer->open_folder();
        return newFolder;
    }
    return NULL;
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_resource(int rNewType, GPE_ResourceContainer * folderContainer, std::string newName, int newResId )
{
    if( rNewType >= 0 && rNewType <= RESOURCE_TYPE_QUEST)
    {
        GPE_ResourceContainer * RES_FOLDER_HOLDER = RESC_ALL[rNewType];
        if(RES_FOLDER_HOLDER!=NULL)
        {
            CREATED_RESOURCE_COUNT[rNewType]+=1;
            int resourceNumb = CREATED_RESOURCE_COUNT[rNewType];
            if( (int)newName.size() <= 0)
            {
                newName = "new"+RESOURCE_TYPE_NAMES[rNewType]+int_to_string(resourceNumb );
            }
            standardEditableGameResource * newProjectResource;
            switch( rNewType)
            {
                case RESOURCE_TYPE_AUDIO:
                    newProjectResource = new audioResource(RESC_PROJECT_FOLDER);
                break;
                case RESOURCE_TYPE_VIDEO:
                    newProjectResource = new videoResource(RESC_PROJECT_FOLDER);
                break;
                case RESOURCE_TYPE_FONT:
                    newProjectResource = new fontResource(RESC_PROJECT_FOLDER);
                break;
                case RESOURCE_TYPE_FUNCTION:
                    newProjectResource = new functionResource(RESC_PROJECT_FOLDER);
                break;
                case RESOURCE_TYPE_OBJECT:
                    newProjectResource = new gameObjectResource(RESC_PROJECT_FOLDER);
                break;
                //Added since Version 1.12 [BEGIN]
                case RESOURCE_TYPE_PATH:
                    newProjectResource = new gamePathResource(RESC_PROJECT_FOLDER);
                break;
                case RESOURCE_TYPE_DICTIONARY:
                    newProjectResource = new dictionaryResource(RESC_PROJECT_FOLDER);
                break;
                //Added since Version 1.12 [END]
                case RESOURCE_TYPE_SCENE:
                    newProjectResource = new gameSceneResource(RESC_PROJECT_FOLDER);
                break;
                case RESOURCE_TYPE_SPRITE:
                    newProjectResource = new spriteResource(RESC_PROJECT_FOLDER);
                break;
                case RESOURCE_TYPE_TEXTURE:
                    newProjectResource = new textureResource(RESC_PROJECT_FOLDER);
                break;
                case RESOURCE_TYPE_TILESHEET:
                    newProjectResource = new tilesheetResource(RESC_PROJECT_FOLDER);
                break;
                default:
                    newProjectResource = NULL;
                break;
            }

            if( folderContainer==NULL )
            {
                folderContainer = RES_FOLDER_HOLDER;
            }

            if( folderContainer!=NULL )
            {
                if( newProjectResource!=NULL)
                {
                    if( newResId < 0)
                    {
                        newProjectResource->set_global_rid( increment_resouce_count() );
                    }
                    else
                    {
                        newProjectResource->set_global_rid( newResId );
                    }
                    newProjectResource->set_name( newName);
                    newProjectResource->set_parent_name( projectFileName);
                    newProjectResource->parentProjectName = projectFileName;
                    newProjectResource->parentProjectDirectory = projectDirectory;
                    newProjectResource->resourceType = rNewType;
                    GPE_ResourceContainer * newContainer = new GPE_ResourceContainer(projectFileName,newName,rNewType,resourceNumb,false,newProjectResource->get_global_rid() );
                    newContainer->set_held_resource(newProjectResource);
                    folderContainer->add_resource_container(newContainer);
                    //folderContainer->open_folder();
                    newContainer->parentProjectDirectory = projectDirectory;
                    return newContainer;
                }
            }
        }
    }
    return NULL;
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_audio( GPE_ResourceContainer * folderContainer,std::string newName, int newResId  )
{
    return create_blank_resource(RESOURCE_TYPE_AUDIO, folderContainer, newName, newResId);
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_video( GPE_ResourceContainer * folderContainer,std::string newName, int newResId  )
{
    return create_blank_resource(RESOURCE_TYPE_VIDEO, folderContainer, newName, newResId);
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_path( GPE_ResourceContainer * folderContainer,std::string newName, int newResId  )
{
    return create_blank_resource(RESOURCE_TYPE_PATH, folderContainer, newName, newResId);
}

//
GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_font(GPE_ResourceContainer * folderContainer, std::string newName, int newResId )
{
    return create_blank_resource(RESOURCE_TYPE_FONT, folderContainer, newName, newResId);
}
//

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_function(GPE_ResourceContainer * folderContainer, std::string newName, int newResId )
{
    return create_blank_resource(RESOURCE_TYPE_FUNCTION, folderContainer, newName, newResId);
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_sprite(GPE_ResourceContainer * folderContainer, std::string newName, int newResId )
{
    return create_blank_resource(RESOURCE_TYPE_SPRITE, folderContainer, newName, newResId);
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_texture(GPE_ResourceContainer * folderContainer, std::string newName, int newResId )
{
    return create_blank_resource(RESOURCE_TYPE_TEXTURE, folderContainer, newName, newResId);
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_tilesheet(GPE_ResourceContainer * folderContainer, std::string newName, int newResId )
{
    return create_blank_resource(RESOURCE_TYPE_TILESHEET, folderContainer, newName, newResId);
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_gameobject(GPE_ResourceContainer * folderContainer, std::string newName, int newResId )
{
    return create_blank_resource(RESOURCE_TYPE_OBJECT, folderContainer, newName, newResId);
}

GPE_ResourceContainer *  GPE_ProjectFolder::create_blank_scene(GPE_ResourceContainer * folderContainer,std::string newName, int newResId )
{
    return create_blank_resource(RESOURCE_TYPE_SCENE, folderContainer, newName, newResId);
}

//Export HTML5
//Build HTML5
bool GPE_ProjectFolder::export_project_html5(std::string projectBuildDirectory , int buildMetaTemplate, bool runGameOnCompile, bool inDebugMode)
{
    GPE_ResourceContainer * firstObjectContainer = RESC_OBJECTS->get_usable_resource();
    GPE_ResourceContainer * firstSceneContainer = RESC_SCENES->get_usable_resource();
    bool hadSaveErrors = false;
    int BUILD_SCREEN_WIDTH = 640;
    int BUILD_SCREEN_HEIGHT = 480;

    GPE_MINI_COMPILER->begin_compiling();
    if( GPE_Main_Logs!=NULL)
    {
        if( buildMetaTemplate!=GPE_BUILD_WINDOWS && buildMetaTemplate!=GPE_BUILD_MAC  && buildMetaTemplate!=GPE_BUILD_LINUX )
        {
            GPE_Main_Logs->clear_build_log();
            GPE_Main_Logs->log_build_line("-------------- Building: ["+projectName+"] ["+GPE_BUILD_NAMES[buildMetaTemplate]+" Export] (Compiler: Pawbitious Compiler)---------------");
        }
        GPE_Main_Logs->log_build_line("Exporting Project...");

        if( firstSceneContainer!=NULL)
        {
            std::string projectFirstLevelName = firstSceneContainer->get_name();
            if( firstObjectContainer!=NULL && GPE_MINI_COMPILER!=NULL)
            {

                if( projectBuildDirectory.empty() )
                {
                    projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/html5";
                }
                if( buildMetaTemplate==GPE_BUILD_HTML5)
                {
                    projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/html5";
                    GPE_MAIN_GUI->setup_build_folder(projectBuildDirectory,GPE_BUILD_HTML5,0,inDebugMode );
                }
                //Grabs the list of resources and such.
                std::vector <GPE_ResourceContainer *> buildTextureOptions;
                std::vector <GPE_ResourceContainer *> buildTilesheetOptions;
                std::vector <GPE_ResourceContainer *> buildSpriteOptions;
                std::vector <GPE_ResourceContainer *> buildAudioOptions;
                std::vector <GPE_ResourceContainer *> buildVideoOptions;
                std::vector <GPE_ResourceContainer *> buildPathsOptions;
                std::vector <GPE_ResourceContainer *> buildFunctionsOptions;
                std::vector <GPE_ResourceContainer *> buildFontOptions;
                std::vector <GPE_ResourceContainer *> buildGameObjectOptions;
                std::vector <GPE_ResourceContainer *> buildGameSceneOptions;
                projectPropertiesResource * projectSettingsObject = (projectPropertiesResource*)RESC_PROJECT_SETTINGS->get_held_resource();
                RESC_TEXTURES->grab_useable_resources(buildTextureOptions);
                RESC_TILESHEETS->grab_useable_resources(buildTilesheetOptions);
                RESC_SPRITES->grab_useable_resources(buildSpriteOptions);
                RESC_AUDIO->grab_useable_resources(buildAudioOptions);
                RESC_VIDEOS->grab_useable_resources(buildVideoOptions);
                RESC_PATHS->grab_useable_resources(buildPathsOptions);
                RESC_FUNCTIONS->grab_useable_resources(buildFunctionsOptions);
                RESC_FONTS->grab_useable_resources(buildFontOptions);
                RESC_OBJECTS->grab_useable_resources(buildGameObjectOptions);
                RESC_SCENES->grab_useable_resources(buildGameSceneOptions);

                //For Mega Looking of resources:
                std::vector <GPE_ResourceContainer *> buildGameBuildAllOptions;
                RESC_TEXTURES->grab_useable_resources(buildGameBuildAllOptions);
                RESC_TILESHEETS->grab_useable_resources(buildGameBuildAllOptions);
                RESC_SPRITES->grab_useable_resources(buildGameBuildAllOptions);
                RESC_AUDIO->grab_useable_resources(buildGameBuildAllOptions);
                RESC_VIDEOS->grab_useable_resources(buildGameBuildAllOptions);
                RESC_PATHS->grab_useable_resources(buildGameBuildAllOptions);
                RESC_FUNCTIONS->grab_useable_resources(buildGameBuildAllOptions);
                RESC_FONTS->grab_useable_resources(buildGameBuildAllOptions);
                RESC_OBJECTS->grab_useable_resources(buildGameBuildAllOptions);
                RESC_SCENES->grab_useable_resources(buildGameBuildAllOptions);

                currentObjParents.clear();
                nextObjParents.clear();
                //temp variables for looping through containers
                int iRes = 0;
                int paramLine = 0;
                int jFontType = 0;
                std::string copyFileDestination;
                int tempParentHTML5Id;
                int foundHtml5BuildId;
                GPE_ResourceContainer * tempContainer = NULL;
                for( iRes = 0; iRes < (int)buildGameBuildAllOptions.size(); iRes++)
                {
                    tempContainer = buildGameBuildAllOptions[iRes];
                    if( tempContainer!=NULL)
                    {
                        if( is_alnum( tempContainer->get_name(),false,true ) )
                        {
                            if( !GPE_MINI_COMPILER->is_compilable_word( tempContainer->get_name() ) )
                            {
                                hadSaveErrors = true;
                                GPE_Main_Logs->log_build_error("Invalid Resource Name Given ["+tempContainer->get_name()+"] conflicts with the GPE engine variable. Please rename your resource!");
                            }
                        }
                        else
                        {
                            hadSaveErrors = true;
                            GPE_Main_Logs->log_build_error("Invalid Resource Name Given ["+tempContainer->get_name()+"].");
                        }
                    }
                }

                if( !hadSaveErrors || MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked()==false )
                {
                    if( projectSettingsObject->projectScreenWidthField->get_held_number() > 0)
                    {
                        BUILD_SCREEN_WIDTH = std::max(160, projectSettingsObject->projectScreenWidthField->get_held_number() );
                    }

                    if( projectSettingsObject->projectScreenHeightField->get_held_number() > 0)
                    {
                        BUILD_SCREEN_HEIGHT = std::max(120,projectSettingsObject->projectScreenHeightField->get_held_number() );
                    }
                    //temp variables for held resources and containers

                    //for preloading of surface and such
                    std::vector <std::string > preloadImgTextures;
                    std::vector <std::string > preloadImgTilesheets;
                    std::vector <std::string > preloadImgSprites;
                    std::vector <std::string > preloadAudio;

                    spriteResource * tempSprRes = NULL;
                    textureResource * tempTexRes = NULL;
                    tilesheetResource * tempTstRes = NULL;
                    audioResource * tempAudRes = NULL;
                    videoResource * tempVidRes = NULL;
                    gamePathResource * tempPathRes = NULL;
                    functionResource * tempFuncRes = NULL;
                    gameObjectResource * tempObjRes = NULL;
                    gameSceneResource * tempScnRes = NULL;
                    //achievementResource * tempAchRes = NULL;
                    fontResource * tempFntRes = NULL;

                    appendToFile(get_user_settings_folder()+"resources_check.txt","Checking all resources..");
                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Textures]");

                    bool hasTextureToUse = false;
                    int amountOfObjectsCompiled = 0;
                    for( iRes = 0; iRes < (int)buildTextureOptions.size(); iRes++)
                    {
                        tempContainer = buildTextureOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                            hasTextureToUse = false;
                            if( tempContainer->get_held_resource()!=NULL)
                            {
                                tempTexRes = (textureResource * )tempContainer->get_held_resource();
                                if( ( tempTexRes!=NULL) && ( tempTexRes->textureInEditor!=NULL) && ( tempTexRes->textureInEditor->get_width() > 0 ) )
                                {
                                    hasTextureToUse = true;
                                    if( tempTexRes->textureInEditor->copy_image_source(projectBuildDirectory+"/resources/textures")  )
                                    {
                                        preloadImgTextures.push_back( getShortFileName(tempTexRes->textureInEditor->get_filename()) );
                                    }
                                }
                                if( hasTextureToUse == false)
                                {
                                    appendToFile(get_user_settings_folder()+"resources_check.txt","Does not contain texture...");
                                }
                            }
                        }
                    }

                    appendToFile(get_user_settings_folder()+"resources_check.txt","[TileSheets]");
                    for( iRes = 0; iRes < (int)buildTilesheetOptions.size(); iRes++)
                    {
                        tempContainer = buildTilesheetOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                            hasTextureToUse = false;
                            if( tempContainer->get_held_resource()!=NULL)
                            {
                                tempTstRes = (tilesheetResource * )tempContainer->get_held_resource();
                                if( ( tempTstRes!=NULL) && ( tempTstRes->tilesheetInEditor!=NULL) && ( tempTstRes->tilesheetInEditor->tsImage!=NULL )&& (tempTstRes->tilesheetInEditor->tsImage->get_width() > 0) )
                                {
                                    hasTextureToUse = true;
                                    if( tempTstRes->tilesheetInEditor->tsImage->copy_image_source(projectBuildDirectory+"/resources/tilesheets")  )
                                    {
                                        preloadImgTilesheets.push_back( getShortFileName(tempTstRes->tilesheetInEditor->tsImage->get_filename()) );
                                    }
                                }
                                if( hasTextureToUse == false)
                                {
                                    appendToFile(get_user_settings_folder()+"resources_check.txt","Tilesheet Does not contain texture image...");
                                }
                            }
                        }
                    }
                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Sprites]");
                    for( iRes = 0; iRes < (int)buildSpriteOptions.size(); iRes++)
                    {
                        tempContainer = buildSpriteOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                            hasTextureToUse = false;
                            if( tempContainer->get_held_resource()!=NULL)
                            {
                                tempSprRes = (spriteResource * )tempContainer->get_held_resource();
                                if( ( tempSprRes!=NULL) && ( tempSprRes->spriteInEditor!=NULL) && ( tempSprRes->spriteInEditor->spriteTexture!=NULL )&& (tempSprRes->spriteInEditor->spriteTexture->get_width() > 0) )
                                {
                                    hasTextureToUse = true;
                                    tempSprRes->save_resource();
                                    if( tempSprRes->spriteInEditor->spriteTexture->copy_image_source(projectBuildDirectory+"/resources/sprites")  )
                                    {
                                        preloadImgSprites.push_back( getShortFileName(tempSprRes->spriteInEditor->spriteTexture->get_filename()) );
                                    }
                                }
                                if( hasTextureToUse == false)
                                {
                                    appendToFile(get_user_settings_folder()+"resources_check.txt","Sprite Does not contain texture image...");
                                }
                            }
                        }
                    }
                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Audio]");
                    for( iRes = 0; iRes < (int)buildAudioOptions.size(); iRes++)
                    {
                        tempContainer = buildAudioOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                        }
                    }

                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Videos]");
                    for( iRes = 0; iRes < (int)buildVideoOptions.size(); iRes++)
                    {
                        tempContainer = buildVideoOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                        }
                    }

                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Paths]");
                    for( iRes = 0; iRes < (int)buildPathsOptions.size(); iRes++)
                    {
                        tempContainer = buildPathsOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +" - "+int_to_string(iRes)+"...");
                        }
                    }

                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Functions]");
                    for( iRes = 0; iRes < (int)buildFunctionsOptions.size(); iRes++)
                    {
                        tempContainer = buildFunctionsOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                        }
                    }

                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Fonts]");
                    for( iRes = 0; iRes < (int)buildFontOptions.size(); iRes++)
                    {
                        tempContainer = buildFontOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempFntRes = (fontResource * ) tempContainer->get_held_resource();
                            tempContainer->set_global_html5id ( iRes);
                            if( tempFntRes!=NULL)
                            {
                                for( jFontType = 0; jFontType < FONT_FILE_TYPES; jFontType++)
                                {
                                    if( (int)tempFntRes->storedFontFileNames[jFontType].size() > 3)
                                    {
                                        copyFileDestination = projectBuildDirectory+"/resources/fonts/"+getShortFileName(tempFntRes->storedFontFileNames[jFontType],true);
                                        if( copy_file(tempFntRes->storedFontFileNames[jFontType],copyFileDestination)==false )
                                        {
                                            appendToFile(get_user_settings_folder()+"resources_check.txt","Unable to copy ["+tempFntRes->storedFontFileNames[jFontType]+"] to ["+copyFileDestination+"]...");
                                        }
                                    }
                                }
                            }
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                        }
                    }

                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Game Objects]");
                    for( iRes = 0; iRes < (int)buildGameObjectOptions.size(); iRes++)
                    {
                        tempContainer = buildGameObjectOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                        }
                    }

                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Scenes]");
                    for( iRes = 0; iRes < (int)buildGameSceneOptions.size(); iRes++)
                    {
                        tempContainer = buildGameSceneOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                        }
                    }

                    //
                    appendToFile(get_user_settings_folder()+"resources_check.txt","[Fonts]");
                    for( iRes = 0; iRes < (int)buildFontOptions.size(); iRes++)
                    {
                        tempContainer = buildFontOptions[iRes];
                        if( tempContainer!=NULL)
                        {
                            tempContainer->set_global_html5id ( iRes);
                            appendToFile(get_user_settings_folder()+"resources_check.txt",tempContainer->get_name() +"...");
                        }
                    }
                    //

                    displayMessageTitle = "Exporting Project";
                    if( buildMetaTemplate >=0 && buildMetaTemplate < GPE_BUILD_OPTIONS)
                    {
                        displayMessageSubtitle = GPE_BUILD_NAMES[buildMetaTemplate]+" Export";
                    }
                    else
                    {
                        displayMessageSubtitle = "Unknown Export";
                    }
                    displayMessageString = projectName;
                    display_user_messaage();

                    //GPE Engine Files
                    std::string buildFileStyleCssFilleName = APP_DIRECTORY_NAME+"build_files/css/style.css";
                    std::string indexStyleCssFileName = projectBuildDirectory+"/css/style.css";
                    if( copy_file( buildFileStyleCssFilleName, indexStyleCssFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copy [style.css] file");
                    }

                    std::string buildFileGPEPowerFilleName = "";
                    std::string indexFileGPEPowerFileName = "";
                    if( MAIN_EDITOR_SETTINGS->useStrictMode->is_clicked() )
                    {
                        GPE_Main_Logs->log_build_line("Using strict mode...");
                        buildFileGPEPowerFilleName = APP_DIRECTORY_NAME+"build_files/js/lib/gpepower_strict_v1_1_2.txt";
                        indexFileGPEPowerFileName =projectBuildDirectory+"/js/lib/gpepower_strict_v1_1_2.js";
                    }
                    else
                    {
                        GPE_Main_Logs->log_build_line("Using non-strict mode...");
                        buildFileGPEPowerFilleName = APP_DIRECTORY_NAME+"build_files/js/lib/gpepower_v1_1_2.txt";
                        indexFileGPEPowerFileName =projectBuildDirectory+"/js/lib/gpepower_v1_1_2.js";
                    }
                    if( inDebugMode)
                    {
                        //APP_DIRECTORY_NAME+"build_files/js/lib/gpepower_debug_strict.txt";
                    }

                    if( buildMetaTemplate ==GPE_BUILD_WIIU)
                    {
                        //Nintendo Web Franmework Export Code
                        //#For those licensed devs see #Wiiu0001
                    }
                    else if( buildMetaTemplate ==GPE_BUILD_WINDOWS || buildMetaTemplate ==GPE_BUILD_MAC || buildMetaTemplate ==GPE_BUILD_LINUX )
                    {
                        std::string buildFileElectronAddonFile = APP_DIRECTORY_NAME+"build_files/js/lib/electron_addon.txt";
                        std::string indexFileElectronAddonFile = projectBuildDirectory+"/js/lib/electron_addon.js";
                        if( copy_file( buildFileElectronAddonFile, indexFileElectronAddonFile)==false )
                        {
                            hadSaveErrors = true;
                            GPE_Main_Logs->log_build_error("Unable to copy Electron Addon");
                        }
                    }

                    if( copy_file( buildFileGPEPowerFilleName, indexFileGPEPowerFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copy GPE HTML5 engine");
                    }

                    std::string buildFileGPESuperArrayFileName = APP_DIRECTORY_NAME+"build_files/js/lib/gpe_superarray.txt";
                    std::string indexFileGPESuperArrayFileName = projectBuildDirectory+"/js/lib/gpe_superarray.js";
                    if( copy_file( buildFileGPESuperArrayFileName, indexFileGPESuperArrayFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copy array library");

                    }
                    std::string buildFileGPESuperStringFilleName = APP_DIRECTORY_NAME+"build_files/js/lib/gpe_superstring.txt";
                    std::string indexFileGPESuperStringFileName = projectBuildDirectory+"/js/lib/gpe_superstring.js";
                    if( copy_file( buildFileGPESuperStringFilleName, indexFileGPESuperStringFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to superstring library");
                    }

                    /*std::string buildFileScreenfullgFilleName = APP_DIRECTORY_NAME+"build_files/js/lib/screenfull.txt";
                    std::string indexFileScreenfullFileName = projectBuildDirectory+"/js/lib/screenfull.js";
                    if( copy_file( buildFileScreenfullgFilleName, indexFileScreenfullFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to screenfull library");
                    }*/

                    std::string buildFileGPEFrameManagerFilleName = APP_DIRECTORY_NAME+"build_files/js/lib/frame_management.txt";
                    std::string indexFileGPEFrameManagerFileName = projectBuildDirectory+"/js/lib/frame_management.js";
                    if( copy_file( buildFileGPEFrameManagerFilleName, indexFileGPEFrameManagerFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copy frame management library");
                    }
                    ///GPE Intro Files

                    std::string buildFileGPELogoStartFilleName = APP_DIRECTORY_NAME+"build_files/res/gpe_logo_start.png";
                    std::string indexFileGPELogoStartFileName = projectBuildDirectory+"/res/gpe_logo_start.png";
                    if( copy_file( buildFileGPELogoStartFilleName, indexFileGPELogoStartFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copyGPE logo.");
                    }
                    std::string buildFileIntroAudioStartAACFilleName = APP_DIRECTORY_NAME+"build_files/res/gpe_intro.aac";
                    std::string indexFileGPEIntroAudioStartAACFileName = projectBuildDirectory+"/res/gpe_intro.aac";
                    if( copy_file( buildFileIntroAudioStartAACFilleName, indexFileGPEIntroAudioStartAACFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copy gpe_intro.aac");
                    }
                    std::string buildFileIntroAudioStartMP3FilleName = APP_DIRECTORY_NAME+"build_files/res/gpe_intro.mp3";
                    std::string indexFileIntroAudioStartMP3FileName = projectBuildDirectory+"/res/gpe_intro.mp3";
                    if( copy_file( buildFileIntroAudioStartMP3FilleName, indexFileIntroAudioStartMP3FileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copy gpe_intro.mp3");
                    }
                    std::string buildFileIntroAudioStartOOGFilleName = APP_DIRECTORY_NAME+"build_files/res/gpe_intro.ogg";
                    std::string indexFileGPEIntroAudioStartOOGFileName = projectBuildDirectory+"/res/gpe_intro.ogg";
                    if( copy_file( buildFileIntroAudioStartOOGFilleName, indexFileGPEIntroAudioStartOOGFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copy gpe_intro.ogg");
                    }
                    std::string buildFileIntroAudioStartWAVFilleName = APP_DIRECTORY_NAME+"build_files/res/gpe_intro.wav";
                    std::string indexFileGPEIntroAudioStartWAVFileName = projectBuildDirectory+"/res/gpe_intro.wav";
                    if( copy_file( buildFileIntroAudioStartWAVFilleName, indexFileGPEIntroAudioStartWAVFileName)==false )
                    {
                        hadSaveErrors = true;
                        GPE_Main_Logs->log_build_error("Unable to copy gpe_intro.wav");
                    }

                    if( !hadSaveErrors || MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked()==false )
                    {
                        std::string indexHTML5FileName = projectBuildDirectory+"/index.html";
                        GPE_Main_Logs->log_build_line("Creating [index.html] file.");
                        std::ofstream indexHTML5FILE ( indexHTML5FileName.c_str() );

                        if (indexHTML5FILE.is_open())
                        {
                            indexHTML5FILE << "<!DOCTYPE HTML> \n";
                            indexHTML5FILE << "<html style='margin: 0px; padding: 0px;'> \n";
                            indexHTML5FILE << "<!--  Game Pencil Engine Project File --> \n";
                            indexHTML5FILE << "<!--  Created automatically via the Game Pencil Engine Editor -->\n";
                            indexHTML5FILE << "<!--  Warning: Manually editing this file may cause unexpected bugs and errors. -->\n";
                            indexHTML5FILE << "<!--  If you have any problems reading this file please report it to debug@pawbyte.com -->\n";
                            indexHTML5FILE << "    <head>\n";
                            if( buildMetaTemplate ==GPE_BUILD_HTML5 && projectSettingsObject->projectHtmlHeaderCode!=NULL)
                            {
                                if( projectSettingsObject->headerCodeBeforeGPECheckbox!=NULL && projectSettingsObject->headerCodeBeforeGPECheckbox->is_clicked() )
                                {
                                    if( projectSettingsObject->projectHtmlHeaderCode->has_content() )
                                    {
                                        projectSettingsObject->projectHtmlHeaderCode->write_data_into_file(&indexHTML5FILE,2,true);
                                        indexHTML5FILE << "\n";
                                    }
                                }
                            }

                            indexHTML5FILE << "        <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>\n";
                            indexHTML5FILE << "        <meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1.0'> \n";
                            indexHTML5FILE << "        <title>" << projectSettingsObject->projectGameShortTitleField->get_string() << "</title> \n";
                            indexHTML5FILE << "        <link rel='stylesheet' type='text/css'  href='css/style.css'> \n";
                            indexHTML5FILE << "        <link rel='stylesheet' type='text/css'  href='css/gpe_custom_style.css'> \n";

                            if( buildMetaTemplate ==GPE_BUILD_WIIU)
                            {
                                //Nintendo Web Franmework Export Code
                                //#For those licensed devs see #Wiiu0002
                            }
                            else if( buildMetaTemplate ==GPE_BUILD_WINDOWS || buildMetaTemplate ==GPE_BUILD_MAC || buildMetaTemplate ==GPE_BUILD_LINUX )
                            {
                                indexHTML5FILE << "        <script src='js/lib/electron_addon.js'></script> \n";
                            }
                            indexHTML5FILE << "        <script src='js/lib/frame_management.js'></script> \n";
                            //indexHTML5FILE << "        <script src='js/lib/screenfull.js'></script> \n";
                            indexHTML5FILE << "        <script src='js/lib/gpe_superarray.js'></script> \n";
                            indexHTML5FILE << "        <script src='js/gpe_settings.js'></script> \n";
                            indexHTML5FILE << "        <script src='js/lib/gpepower_strict_v1_1_2.js'></script>	 \n";
                            if( buildMetaTemplate ==GPE_BUILD_WIIU)
                            {
                                //Nintendo Web Franmework Export Code
                                //#For those licensed devs see #Wiiu0003

                            }
                            //indexHTML5FILE << "        <script src='js/gpe_app.js'></script>	 \n";
                             if( buildMetaTemplate ==GPE_BUILD_HTML5 && projectSettingsObject->projectHtmlHeaderCode!=NULL)
                            {
                                if( projectSettingsObject->headerCodeBeforeGPECheckbox==NULL || projectSettingsObject->headerCodeBeforeGPECheckbox->is_clicked()==false )
                                {
                                    if( projectSettingsObject->projectHtmlHeaderCode->has_content() )
                                    {
                                        projectSettingsObject->projectHtmlHeaderCode->write_data_into_file(&indexHTML5FILE,2,true);
                                        indexHTML5FILE << "\n";

                                    }
                                }
                            }
                            indexHTML5FILE << "     </head>\n";
                            indexHTML5FILE << "     <body>\n";
                            indexHTML5FILE << "        <canvas id='gpeCanvas' width='auto' height='"<< BUILD_SCREEN_HEIGHT << "' oncontextmenu='return false;'></canvas> \n";
                            if( buildMetaTemplate ==GPE_BUILD_HTML5 && projectSettingsObject->checkBoxShowPublisherInfo!=NULL)
                            {
                                if(projectSettingsObject->checkBoxShowPublisherInfo->is_clicked() )
                                {
                                    if( projectSettingsObject->projectGameTitleField->has_content() )
                                    {
                                        indexHTML5FILE << "     <h2>" << projectSettingsObject->projectGameTitleField->get_string() << "</h2>\n";
                                    }

                                    if( projectSettingsObject->projectGameDescriptionField->has_content() )
                                    {
                                        indexHTML5FILE << "     <h3>" << projectSettingsObject->projectGameDescriptionField->get_string() << "</h3>\n";
                                    }

                                    if( projectSettingsObject->projectGameNotes!=NULL)
                                    {
                                        if( projectSettingsObject->projectGameNotes->has_content() )
                                        {
                                            indexHTML5FILE << "     <p>";
                                            projectSettingsObject->projectGameNotes->write_data_into_file(&indexHTML5FILE,2,true);
                                            indexHTML5FILE << "</p>\n";
                                        }
                                    }
                                    if( buildMetaTemplate ==GPE_BUILD_HTML5 && projectSettingsObject->projectHtmlCode!=NULL)
                                    {
                                        if( projectSettingsObject->projectHtmlCode->has_content() )
                                        {
                                            projectSettingsObject->projectHtmlCode->write_data_into_file(&indexHTML5FILE,2,true);
                                        }
                                    }

                                    if( projectSettingsObject->projectGamePublisherField->has_content() )
                                    {
                                        indexHTML5FILE << "     <p>Published by " << projectSettingsObject->projectGamePublisherField->get_string() << "</p>\n";
                                    }

                                    if( projectSettingsObject->projectGameDeveloperField->has_content() )
                                    {
                                        indexHTML5FILE << "     <p>Developed by " << projectSettingsObject->projectGameDeveloperField->get_string() << "</p>\n";
                                    }

                                    if( projectSettingsObject->projectGameCopyrightField->has_content() )
                                    {
                                        indexHTML5FILE << "     <p>Copyright " << projectSettingsObject->projectGameCopyrightField->get_string() << " "<<projectSettingsObject->projectGameDateField->get_string() <<"</p>\n";
                                    }

                                    if( projectSettingsObject->projectGameWebsiteField->has_content() )
                                    {
                                        indexHTML5FILE << "     <p> <a ahref='" << projectSettingsObject->projectGameWebsiteField->get_string() << "'>For more information on game click here</a></p>\n";
                                    }

                                    if( projectSettingsObject->projectGameEmailField->has_content() )
                                    {
                                        indexHTML5FILE << "     <p> Email <a ahref='mailto:" << projectSettingsObject->projectGameEmailField->get_string() << "?Subject=Hello'>"<< projectSettingsObject->projectGameEmailField->get_string() << " for assistance</a></p>\n";
                                    }
                                }
                            }

                            if( buildMetaTemplate==GPE_BUILD_HTML5 && projectSettingsObject->warnOnCloseCheckbox->is_clicked() )
                            {
                                indexHTML5FILE << "<script type='text/javascript'>\n";
                                indexHTML5FILE << "window.onbeforeunload = function () {return 'Are you sure that you want to leave this page? Game Data may be lost';}\n";
                                indexHTML5FILE << "</script>\n";
                            }
                            indexHTML5FILE << "    </body>\n";
                            indexHTML5FILE << "</html> \n";

                            indexHTML5FILE.close();
                            std::string indexGameSettingsFileName = projectBuildDirectory+"/js/gpe_settings.js";
                            std::ofstream indexJSSettingsFILE ( indexGameSettingsFileName.c_str() );
                            if (indexJSSettingsFILE.is_open())
                            {
                                indexJSSettingsFILE << "/*     \n";
                                indexJSSettingsFILE << "#    --------------------------------------------------  #\n";
                                indexJSSettingsFILE << "#       \n";
                                indexJSSettingsFILE << "#       \n";
                                indexJSSettingsFILE << "#  Game Pencil Engine Game File \n";
                                indexJSSettingsFILE << "#  Created automatically via the Game Pencil Engine Editor \n";
                                indexJSSettingsFILE << "#  Warning: Manually editing this file may cause unexpected bugs and errors. \n";
                                indexJSSettingsFILE << "#  If you have any problems reading this file please report it to debug@pawbyte.com . \n";
                                indexJSSettingsFILE << "#     \n";
                                indexJSSettingsFILE << "#      \n";
                                indexJSSettingsFILE << "#    --------------------------------------------------  # \n";
                                indexJSSettingsFILE << "*/     \n\n";
                                indexJSSettingsFILE << "var game = game || {};\n \n";
                                int fpsValue = projectSettingsObject->projectSettingsFPSRate->get_selected_value();
                                if( fpsValue > 0)
                                {
                                    if( buildMetaTemplate == GPE_BUILD_WIIU && fpsValue > 30)
                                    {
                                        /* Wiiu0004
                                        Changing the FPS to 30 is completely optional here, but die to lack of support I decided to limit FPS to 30 manually.
                                        */
                                        indexJSSettingsFILE << "GPE_STANDARD_FPS = 30;\n \n";

                                    }
                                    else
                                    {
                                        indexJSSettingsFILE << "GPE_STANDARD_FPS ="+int_to_string(fpsValue)+";\n \n";
                                    }
                                }
                                else
                                {
                                    indexJSSettingsFILE << "GPE_STANDARD_FPS = 60;\n \n";
                                    indexJSSettingsFILE << "GPE_FPS_UNCAPPED = true;\n \n";
                                }
                                indexJSSettingsFILE << "GPE_STANDARD_INTERVAL = 1000/GPE_STANDARD_FPS;;\n \n";
                                indexJSSettingsFILE << "var GPE_SETTINGS_APP_LOGO_LOCATION = 'res/gpe_logo_start.png'; \n";
                                indexJSSettingsFILE << "var GPE_SETTINGS_START_SCENE = '"+projectFirstLevelName+"'; \n";


                                indexJSSettingsFILE << "var GPE_SETTINGS_SCREEN_WIDTH = "<< BUILD_SCREEN_WIDTH << ";\n";
                                indexJSSettingsFILE << "var GPE_SETTINGS_SCREEN_HEIGHT = "<< BUILD_SCREEN_HEIGHT << ";\n";

                                indexJSSettingsFILE << "var GPE_SETTINGS_PROG_NAME = '" << projectSettingsObject->projectGameTitleField->get_string() << "';\n";
                                indexJSSettingsFILE << "var GPE_SETTINGS_VERSION_NUMBER = "<< projectSettingsObject->projectGameVersionField->get_string()<< ";\n";
                                indexJSSettingsFILE << "var GPE_MAX_OBJECT_TYPES = "<< (int)buildGameObjectOptions.size() << ";\n";
                                if( buildMetaTemplate ==GPE_BUILD_WIIU)
                                {
                                        indexJSSettingsFILE << "var GPE_SETTINGS_SYSTEM_OS = 'WiiU';\n";
                                }
                                else
                                {
                                    indexJSSettingsFILE << "var GPE_SETTINGS_SYSTEM_OS = 'Browser';\n";
                                }
                                indexJSSettingsFILE << "var GPE_GAME_PUBLISHER = '" << projectSettingsObject->projectGamePublisherField->get_string()<< "';\n";
                                indexJSSettingsFILE << "var GPE_GAME_DEVELOPER = '" << projectSettingsObject->projectGameDeveloperField->get_string() << "';\n";
                                indexJSSettingsFILE << "var GPE_GAME_OBJECTS_COUNT = "+int_to_string( (int)buildGameObjectOptions.size() )+";\n";
                                indexJSSettingsFILE << "var GPE_SETTINGS_IS_DEBUGGING = false;\n";
                                indexJSSettingsFILE << "var GPE_SETTINGS_SHOW_FPS = true;\n";

                                indexJSSettingsFILE << "var GPE_GAME_SCALING_SETTING = " << projectSettingsObject->projectScaleSettings->get_selected_id()<< ";\n";


                                indexJSSettingsFILE << "var GPE_PreloadImageResource = [];\n";
                                int preloadCount = 0;

                                int preloadAudioCount[SUPPORTED_AUDIO_FORMAT_COUNT];
                                preloadAudioCount[aacFileName] = 0;
                                preloadAudioCount[mp3FileName] = 0;
                                preloadAudioCount[oggFileName] = 0;
                                preloadAudioCount[wavFileName] = 0;

                                int iPreloadRes = 0;
                                int jPreloadSubFileType = 0;
                                for( iPreloadRes = 0; iPreloadRes < (int)preloadImgTextures.size(); iPreloadRes++ )
                                {
                                    indexJSSettingsFILE << "GPE_PreloadImageResource[" << int_to_string(preloadCount) << "] = 'resources/textures/" << preloadImgTextures.at( iPreloadRes ) << "';\n";
                                    preloadCount+=1;
                                }
                                for( iPreloadRes = 0; iPreloadRes < (int)preloadImgTilesheets.size(); iPreloadRes++ )
                                {
                                    indexJSSettingsFILE << "GPE_PreloadImageResource[" << int_to_string(preloadCount) << "] = 'resources/tilesheets/" << preloadImgTilesheets.at( iPreloadRes ) << "';\n";
                                    preloadCount+=1;
                                }
                                for( iPreloadRes = 0; iPreloadRes < (int)preloadImgSprites.size(); iPreloadRes++ )
                                {
                                    indexJSSettingsFILE << "GPE_PreloadImageResource[" << int_to_string(preloadCount) << "] = 'resources/sprites/" << preloadImgSprites.at( iPreloadRes ) << "';\n";
                                    preloadCount+=1;
                                }
                                indexJSSettingsFILE << "var GPE_PreloadAudioResource = [];\n";
                                for( jPreloadSubFileType = 0; jPreloadSubFileType < SUPPORTED_AUDIO_FORMAT_COUNT; jPreloadSubFileType++)
                                {
                                    indexJSSettingsFILE << "var GPE_Preload" << SUPPORTED_AUDIO_EXT[jPreloadSubFileType] << "Resource = [];\n";
                                    indexJSSettingsFILE << "GPE_PreloadAudioResource["<< jPreloadSubFileType << "] = GPE_Preload" << SUPPORTED_AUDIO_EXT[jPreloadSubFileType] << "Resource;\n";
                                }

                                for( iPreloadRes = 0; iPreloadRes < (int)buildAudioOptions.size(); iPreloadRes++ )
                                {
                                    tempContainer = buildAudioOptions.at(iPreloadRes);
                                    if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                    {
                                        tempAudRes = (audioResource * ) tempContainer->get_held_resource();
                                        if( tempAudRes!=NULL)
                                        {
                                            for( jPreloadSubFileType = 0; jPreloadSubFileType < SUPPORTED_AUDIO_FORMAT_COUNT; jPreloadSubFileType++)
                                            {
                                                if( tempAudRes->audioFileName[jPreloadSubFileType].size() > 3)
                                                {
                                                    indexJSSettingsFILE << "GPE_Preload" << SUPPORTED_AUDIO_EXT[jPreloadSubFileType] << "Resource[" << int_to_string(preloadAudioCount[jPreloadSubFileType]) << "] = 'resources/audio/" << getShortFileName(tempAudRes->audioFileName[jPreloadSubFileType],true ) << "';\n";
                                                    preloadAudioCount[jPreloadSubFileType]++;
                                                }
                                            }
                                        }
                                    }
                                }

                                if( RESC_PROJECT_SETTINGS!=NULL )
                                {
                                    indexJSSettingsFILE << "var Game_LayerMatrix = [];\n";
                                    indexJSSettingsFILE << "var Game_SelfCollideLayerList = [];\n";
                                    projectPropertiesResource * tProjectProps = (projectPropertiesResource *)RESC_PROJECT_SETTINGS->get_held_resource();
                                    if( tProjectProps!=NULL)
                                    {
                                        int jLayerCol = 0;
                                        for( int iLayerRow = 0; iLayerRow < 32; iLayerRow++)
                                        {
                                            indexJSSettingsFILE << "Game_LayerMatrix.push( [] );\n";
                                            for(  jLayerCol = 0; jLayerCol < 32-iLayerRow; jLayerCol++)
                                            {
                                                if( iLayerRow==jLayerCol)
                                                {
                                                    if( tProjectProps->projectCollisionLayerMatrix[iLayerRow*32+jLayerCol]->is_clicked() )
                                                    {
                                                        indexJSSettingsFILE << "Game_SelfCollideLayerList.push(1);\n";
                                                    }
                                                    else
                                                    {
                                                        indexJSSettingsFILE << "Game_SelfCollideLayerList.push(0);\n";
                                                    }
                                                }
                                                else if( tProjectProps->projectCollisionLayerMatrix[iLayerRow*32+jLayerCol]->is_clicked() )
                                                {
                                                    indexJSSettingsFILE << "Game_LayerMatrix["+int_to_string(iLayerRow)+"].push("+int_to_string( jLayerCol )+");\n";
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        indexJSSettingsFILE << "//RESC_PROJECT_SETTINGS local not reachable...\n";
                                    }
                                }
                                else
                                {
                                    indexJSSettingsFILE << "//RESC_PROJECT_SETTINGS not reachable...\n";
                                }

                                indexJSSettingsFILE.close();
                            }
                            else
                            {
                                hadSaveErrors = true;
                                GPE_Main_Logs->log_build_error("Unable to create [gpe_settings.js]...[Build canceled]");
                            }

                            if( buildMetaTemplate==GPE_BUILD_WINDOWS || buildMetaTemplate==GPE_BUILD_MAC || buildMetaTemplate==GPE_BUILD_LINUX )
                            {
                                std::string indexJsonPackageFileName = projectBuildDirectory+"/package.json";
                                std::ofstream indexJsonPackageFile ( indexJsonPackageFileName.c_str() );
                                GPE_Main_Logs->log_build_line("Creating [package.json] file...");
                                if (indexJsonPackageFile.is_open())
                                {
                                    indexJsonPackageFile << "{\n";
                                    indexJsonPackageFile << "\"name\"             :   \"" << projectSettingsObject->projectGameShortTitleField->get_string() << "\",\n";
                                    indexJsonPackageFile << "\"productName\"      :   \"" << projectSettingsObject->projectGameTitleField->get_string() << "\",\n";
                                    indexJsonPackageFile << "\"description\"      :   \"" << projectSettingsObject->projectGameDescriptionField->get_string() << "\",\n";
                                    indexJsonPackageFile << "\"version\"          :   \"" << projectSettingsObject->projectGameVersionField->get_string() << "\",\n";
                                    indexJsonPackageFile << "\"main\"             :   \"main.js\"\n";
                                    indexJsonPackageFile << "}\n";
                                    indexJsonPackageFile.close();
                                }
                                else
                                {
                                    hadSaveErrors = true;
                                    GPE_Main_Logs->log_build_error("Unable to create [package.json]...[Build canceled]");
                                }
                            }

                            std::string indexJSCustomGameFileName = projectBuildDirectory+"/js/gpe_app.js";
                            std::ofstream indexJSCustomGameFILE ( indexJSCustomGameFileName.c_str() );
                            GPE_Main_Logs->log_build_line("Creating [gpe_app.js] file...");
                            if (indexJSCustomGameFILE.is_open())
                            {
                                indexJSCustomGameFILE << "/*     \n";
                                indexJSCustomGameFILE << "#    --------------------------------------------------  #\n";
                                indexJSCustomGameFILE << "#       \n";
                                indexJSCustomGameFILE << "#       \n";
                                indexJSCustomGameFILE << "#  Game Pencil Engine Game File \n";
                                indexJSCustomGameFILE << "#  Created automatically via the Game Pencil Engine Editor Version "<< int_to_string(GPE_VERSION_DOUBLE_NUMBER) << "\n";
                                indexJSCustomGameFILE << "#  Warning: Manually editing this file may cause unexpected bugs and errors. \n";
                                indexJSCustomGameFILE << "#  If you have any problems reading this file please report it to debug@pawbyte.com . \n";
                                indexJSCustomGameFILE << "#     \n";
                                indexJSCustomGameFILE << "#      \n";
                                indexJSCustomGameFILE << "#    --------------------------------------------------  # \n";
                                indexJSCustomGameFILE << "*/     \n\n";

                                if( MAIN_EDITOR_SETTINGS->useStrictMode->is_clicked() )
                                {
                                    indexJSCustomGameFILE << "'use strict';\n";
                                }
                                currentObjParents.clear();
                                nextObjParents.clear();

                                for( iRes = 0; iRes < (int)buildTextureOptions.size(); iRes++)
                                {
                                    tempContainer = buildTextureOptions[iRes];
                                    if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                    {
                                        tempTexRes = (textureResource * ) tempContainer->get_held_resource();
                                        tempTexRes->build_intohtml5_file(&indexJSCustomGameFILE,0);
                                    }
                                }

                                for( iRes = 0; iRes < (int)buildTilesheetOptions.size(); iRes++)
                                {
                                    tempContainer = buildTilesheetOptions[iRes];
                                    if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                    {
                                        tempTstRes = (tilesheetResource * ) tempContainer->get_held_resource();
                                        tempTstRes->build_intohtml5_file(&indexJSCustomGameFILE,0);
                                    }
                                }


                                for( iRes = 0; iRes < (int)buildSpriteOptions.size(); iRes++)
                                {
                                    tempContainer = buildSpriteOptions[iRes];
                                    if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                    {
                                        tempSprRes = (spriteResource * ) tempContainer->get_held_resource();
                                        tempSprRes->build_intohtml5_file(&indexJSCustomGameFILE,0);
                                    }
                                }


                                for( iRes = 0; iRes < (int)buildAudioOptions.size(); iRes++)
                                {
                                    tempContainer = buildAudioOptions[iRes];
                                    if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                    {
                                        tempAudRes = (audioResource * ) tempContainer->get_held_resource();
                                        tempAudRes->build_intohtml5_file(&indexJSCustomGameFILE,0);
                                        tempAudRes->copy_audio_source(projectBuildDirectory+"/resources/audio");
                                    }
                                }

                                for( iRes = 0; iRes < (int)buildVideoOptions.size(); iRes++)
                                {
                                    tempContainer = buildVideoOptions[iRes];
                                    if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                    {
                                        tempVidRes = (videoResource * ) tempContainer->get_held_resource();
                                        tempVidRes->build_intohtml5_file(&indexJSCustomGameFILE,0);
                                        tempVidRes->copy_video_source(projectBuildDirectory+"/resources/videos");
                                    }
                                }

                                for( iRes = 0; iRes < (int)buildPathsOptions.size(); iRes++)
                                {
                                    tempContainer = buildPathsOptions[iRes];
                                    if( tempContainer!=NULL)
                                    {
                                        indexJSCustomGameFILE << "var " << tempContainer->get_name() << " =  " << tempContainer->get_held_resource()->html5BuildGlobalId << "; \n";
                                        if( tempContainer->get_held_resource()!=NULL )
                                        {
                                            tempPathRes = (gamePathResource * ) tempContainer->get_held_resource();
                                            tempPathRes->build_intohtml5_file(&indexJSCustomGameFILE,0);
                                        }
                                    }
                                }

                                for( iRes = 0; iRes < (int)buildFontOptions.size(); iRes++)
                                {
                                    tempContainer = buildFontOptions[iRes];
                                    if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                    {
                                        tempFntRes = (fontResource * ) tempContainer->get_held_resource();
                                        tempFntRes->build_intohtml5_file(&indexJSCustomGameFILE,0);
                                    }
                                }

                                for( iRes = 0; iRes < (int)buildGameObjectOptions.size(); iRes++)
                                {
                                    tempContainer = buildGameObjectOptions[iRes];
                                    if( tempContainer!=NULL)
                                    {
                                        indexJSCustomGameFILE << "var " << tempContainer->get_name() << " =  " << tempContainer->get_held_resource()->html5BuildGlobalId << "; \n";
                                    }
                                }

                                for( iRes = 0; iRes < (int)buildGameSceneOptions.size(); iRes++)
                                {
                                    tempContainer = buildGameSceneOptions[iRes];
                                    if( tempContainer!=NULL)
                                    {
                                        foundHtml5BuildId = tempContainer->get_held_resource()->html5BuildGlobalId;
                                        indexJSCustomGameFILE << "var " << tempContainer->get_name() << " =  " << foundHtml5BuildId << "; \n";
                                        indexJSCustomGameFILE << "var  _scn_" << tempContainer->get_name() << " =  GPE.add_gamescene("+int_to_string(foundHtml5BuildId)+" , '"+tempContainer->get_name()+"'); \n";
                                    }
                                }

                                /*if( projectSettingsObject->projectGameMacros!=NULL)
                                {
                                    indexJSCustomGameFILE << "//Start of Project Macros \n";
                                    projectSettingsObject->projectGameMacros->write_data_into_file(&indexJSCustomGameFILE,0,true);
                                    indexJSCustomGameFILE << "//End of Project Macros \n";
                                }*/

                                int iErrorLine = 0;
                                for( iRes = 0; iRes < (int)buildFunctionsOptions.size() && ( !hadSaveErrors || MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked()==false ); iRes++)
                                {
                                    tempContainer = buildFunctionsOptions[iRes];
                                    if( tempContainer!=NULL)
                                    {
                                        hasTextureToUse = false;
                                        if( tempContainer->get_held_resource()!=NULL)
                                        {
                                            tempFuncRes = (functionResource * )tempContainer->get_held_resource();
                                            if( ( tempFuncRes!=NULL) && ( tempFuncRes->functionCode!=NULL && tempFuncRes->parametersField!=NULL)  )
                                            {
                                                //record_error("Processing "+tempFuncRes->get_name()+"['s function"+tempFuncRes->parametersField->get_string() +"].");
                                                if( GPE_MINI_COMPILER->process_parameters_string( tempFuncRes->parametersField->get_string() ) )
                                                {
                                                    indexJSCustomGameFILE << "function " << tempContainer->get_name() << "( " << GPE_MINI_COMPILER->newParametersString << " ) \n";
                                                    indexJSCustomGameFILE << "{\n";
                                                    hasTextureToUse = true;
                                                }
                                                else
                                                {
                                                    indexJSCustomGameFILE << "function " << tempContainer->get_name() << "(invaliGPEParameters) \n";
                                                    indexJSCustomGameFILE << "{\n";

                                                    for( iErrorLine = 0; iErrorLine < (int)GPE_MINI_COMPILER->functionParameterErrors.size(); iErrorLine++)
                                                    {
                                                        GPE_Main_Logs->log_build_error("Invalid parameters given for "+tempContainer->get_name()+": "+GPE_MINI_COMPILER->functionParameterErrors[iErrorLine] );
                                                        record_error("Invalid parameters given for "+tempContainer->get_name()+": "+GPE_MINI_COMPILER->functionParameterErrors[iErrorLine] );
                                                    }
                                                    hadSaveErrors = true;
                                                    if( MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked() )
                                                    {
                                                        break;
                                                    }
                                                }

                                                for( paramLine = 0; paramLine < (int)GPE_MINI_COMPILER->defaultParameterLines.size(); paramLine++)
                                                {
                                                    indexJSCustomGameFILE << "     "+GPE_MINI_COMPILER->defaultParameterLines[paramLine] << "\n";
                                                }
                                                if( !tempFuncRes->functionCode->compile_into_code( &indexJSCustomGameFILE, 1,true,true) )
                                                {
                                                    for( iErrorLine=0; iErrorLine < (int)tempFuncRes->functionCode->foundSynthaxErrors.size(); iErrorLine++)
                                                    {
                                                        GPE_Main_Logs->log_build_error( tempContainer->get_name()+": "+tempFuncRes->functionCode->foundSynthaxErrors[iErrorLine] );
                                                    }
                                                    hadSaveErrors = true;
                                                    if( MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked() )
                                                    {
                                                        break;
                                                    }
                                                }
                                                indexJSCustomGameFILE << "}\n\n";
                                            }
                                        }
                                    }
                                }

                                indexJSCustomGameFILE << "\n";
                                if( !hadSaveErrors || MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked()==false )
                                {
                                    std::string tempObjName = "";
                                    std::string tempParentName = "";

                                    //The Glorious object creation code
                                    std::vector< objectResParentChainLink *> ALL_OBJECTS_CHAINS;
                                    objectResParentChainLink * tObjectChainLink = NULL;
                                    for( iRes = 0; iRes < (int)buildGameObjectOptions.size(); iRes++)
                                    {
                                        ALL_OBJECTS_CHAINS.push_back( new objectResParentChainLink(iRes) );
                                    }
                                    GPE_TextAreaInputBasic * tempObjCreationFunc = new GPE_TextAreaInputBasic();
                                    tempObjCreationFunc->clear_all_lines();
                                    tempObjCreationFunc->add_line("GPE.add_new_object = function(newObjType, newX, newY, objectLayerId )");
                                    tempObjCreationFunc->add_line("{");
                                    tempObjCreationFunc->add_line("if( typeof objectLayerId!=\"number\"){objectLayerId = 1;}");
                                    tempObjCreationFunc->add_line("     var newObjOut = IS_NULL;");
                                    tempObjCreationFunc->add_line("     switch( newObjType )");
                                    tempObjCreationFunc->add_line("     {");

                                    //first compiles all objects whose parent is the standard default game object
                                    GPE_ResourceContainer * currObjParent = NULL;
                                    for( iRes = 0; iRes < (int)buildGameObjectOptions.size(); iRes++)
                                    {
                                        tempContainer = buildGameObjectOptions[iRes];
                                        if( tempContainer!=NULL)
                                        {
                                            hasTextureToUse = false;
                                            if( tempContainer->get_held_resource()!=NULL)
                                            {
                                                tempObjRes = (gameObjectResource * )tempContainer->get_held_resource();
                                                if( tempObjRes!=NULL && tempObjRes->get_parent_resource()==NULL)
                                                {
                                                    record_error("Building: ["+tempObjRes->get_name()+"]...");
                                                    if( tempObjRes->build_intohtml5_file(&indexJSCustomGameFILE,0)==false )
                                                    {
                                                        hadSaveErrors = true;
                                                        //GPE_Main_Logs->log_build_error("Error building "+tempObjRes->get_name()+".");
                                                        record_error("Error building "+tempObjRes->get_name()+" (Default Object Parent).");
                                                        if( MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked() )
                                                        {
                                                            break;
                                                        }

                                                    }
                                                    else
                                                    {
                                                        record_error("Built "+tempObjRes->get_name()+" (Default Object Parent).");
                                                    }
                                                    nextObjParents.push_back( tempContainer->get_global_id() );
                                                    tempObjCreationFunc->add_line("         case "+int_to_string(iRes)+":");
                                                    tempObjCreationFunc->add_line("             newObjOut = new GPE._obj_"+tempObjRes->get_name()+"(newX, newY, objectLayerId);");
                                                    tempObjCreationFunc->add_line("         break;");
                                                    amountOfObjectsCompiled++;
                                                }
                                            }
                                        }
                                    }

                                    swap_obj_lists();
                                    //then compiles all objects whose parent is user defined
                                    while( currentObjParents.size() > 0 && ( !hadSaveErrors || MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked()==false ) )
                                    {
                                        for( iRes = 0; iRes < (int)buildGameObjectOptions.size(); iRes++)
                                        {
                                            tempContainer = buildGameObjectOptions[iRes];
                                            if( tempContainer!=NULL)
                                            {
                                                hasTextureToUse = false;
                                                if( tempContainer->get_held_resource()!=NULL)
                                                {
                                                    tempObjRes = (gameObjectResource * )tempContainer->get_held_resource();
                                                    if( tempObjRes!=NULL)
                                                    {
                                                        currObjParent = tempObjRes->parentObjectField->get_selected_container();
                                                        if( currObjParent !=NULL && check_obj_inlist(currObjParent->get_global_id() ) )
                                                        {
                                                            record_error("Building: ["+tempObjRes->get_name()+" - child]...");
                                                            if( tempObjRes->build_intohtml5_file(&indexJSCustomGameFILE,0)==false )
                                                            {
                                                                hadSaveErrors = true;
                                                                //GPE_Main_Logs->log_build_error("Error building "+tempObjRes->get_name()+".");
                                                                record_error("Error building "+tempObjRes->get_name()+".");
                                                                if(  MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked() )
                                                                {
                                                                    break;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                record_error("Built: ["+tempObjRes->get_name()+" - child]...");
                                                            }
                                                            tempObjCreationFunc->add_line("         case "+int_to_string(iRes)+":");
                                                            tempObjCreationFunc->add_line("             newObjOut = new GPE._obj_"+tempObjRes->get_name()+"( newX, newY,objectLayerId);");
                                                            tempObjCreationFunc->add_line("         break;");
                                                            nextObjParents.push_back( tempContainer->get_global_id() );
                                                            amountOfObjectsCompiled++;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        swap_obj_lists();
                                    }

                                    //reverse inherits parents for creation of object families
                                    begin_obj_reverse_inheritence();
                                    record_error("Creating inheritance trees...");
                                    while( currentObjParents.size() > 0)
                                    {
                                        for( iRes = 0; iRes < (int)buildGameObjectOptions.size(); iRes++)
                                        {
                                            tempContainer = buildGameObjectOptions[iRes];
                                            if( tempContainer!=NULL &&  tempContainer->get_held_resource()!=NULL )
                                            {
                                                tempObjRes = (gameObjectResource * )tempContainer->get_held_resource();
                                                if( tempObjRes!=NULL && check_obj_inlist(tempContainer->get_global_id() ) )
                                                {
                                                    currObjParent = tempObjRes->parentObjectField->get_selected_container();
                                                    if( currObjParent !=NULL)
                                                    {
                                                        tempParentHTML5Id = currObjParent->html5BuildGlobalId;
                                                        if( tempParentHTML5Id >=0 && tempParentHTML5Id < (int)ALL_OBJECTS_CHAINS.size() )
                                                        {
                                                            nextObjParents.push_back( currObjParent->get_global_id() );

                                                            if( tempContainer->html5BuildGlobalId >=0 && tempContainer->html5BuildGlobalId < (int)ALL_OBJECTS_CHAINS.size() )
                                                            {
                                                                tObjectChainLink = ALL_OBJECTS_CHAINS[tempContainer->html5BuildGlobalId];
                                                                if( tObjectChainLink->is_inchain(tempParentHTML5Id)==false)
                                                                {
                                                                    tObjectChainLink = ALL_OBJECTS_CHAINS[tempParentHTML5Id];
                                                                    tObjectChainLink->grab_chain(ALL_OBJECTS_CHAINS[tempContainer->html5BuildGlobalId]);
                                                                }
                                                                else
                                                                {
                                                                    //illogcal inheritence circle is occuring, stop it like a Jedi
                                                                    tempObjRes = (gameObjectResource * )currObjParent->get_held_resource();
                                                                    tempObjRes->parentObjectField->set_selection(-1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        swap_obj_lists();
                                    }

                                    //Cleans up all of that messy backward tracing of parental families
                                    indexJSCustomGameFILE << "\n";
                                    indexJSCustomGameFILE << "GPE.activate_object_families= function()\n";
                                    indexJSCustomGameFILE << "{\n";
                                    indexJSCustomGameFILE << "  GPR.GAME_OBJECTS_FAMILIES = [];\n";
                                    int subChainPos = 0;
                                    for( iRes = 0; iRes < (int)ALL_OBJECTS_CHAINS.size(); iRes++)
                                    {
                                        tObjectChainLink = ALL_OBJECTS_CHAINS[iRes];
                                        indexJSCustomGameFILE << "  GPR.GAME_OBJECTS_FAMILIES["+int_to_string(iRes)+"] = [];\n";
                                        if( tObjectChainLink!=NULL)
                                        {
                                            for( subChainPos = 0; subChainPos < (int)tObjectChainLink->heldChains.size(); subChainPos++)
                                            {
                                                //tempSubObjChainLink = ;
                                                indexJSCustomGameFILE << "  GPR.GAME_OBJECTS_FAMILIES["+int_to_string(iRes)+"].push("+int_to_string( tObjectChainLink->heldChains[subChainPos] )+");\n";
                                            }
                                            indexJSCustomGameFILE <<  "\n";
                                        }
                                    }
                                    indexJSCustomGameFILE << "}\n";
                                    indexJSCustomGameFILE << "\n\n";

                                    record_error("Creating Object Chains...");
                                    //Cleans up all of that messy backward tracing of parental families
                                    for( iRes = (int)ALL_OBJECTS_CHAINS.size()-1; iRes >=0; iRes--)
                                    {
                                        tObjectChainLink = ALL_OBJECTS_CHAINS[iRes];
                                        if( tObjectChainLink!=NULL)
                                        {
                                            delete tObjectChainLink;
                                            tObjectChainLink = NULL;
                                        }
                                    }
                                    ALL_OBJECTS_CHAINS.clear();

                                    tempObjCreationFunc->add_line("         default:");
                                    tempObjCreationFunc->add_line("         break;");
                                    tempObjCreationFunc->add_line("     }");
                                    tempObjCreationFunc->add_line("     if(newObjOut!=IS_NULL)");
                                    tempObjCreationFunc->add_line("     {");
                                    tempObjCreationFunc->add_line("         newObjOut.xPos = newX;");
                                    tempObjCreationFunc->add_line("         newObjOut.yPos = newY;");
                                    tempObjCreationFunc->add_line("         newObjOut.sceneLayerPos = objectLayerId;");
                                    tempObjCreationFunc->add_line("         GPR.add_object(newObjOut, false, objectLayerId);");
                                    tempObjCreationFunc->add_line("         return newObjOut;");
                                    tempObjCreationFunc->add_line("     }");
                                    tempObjCreationFunc->add_line("     return IS_NULL;");
                                    tempObjCreationFunc->add_line("};");

                                    tempObjCreationFunc->write_data_into_file(&indexJSCustomGameFILE,0,true,true);
                                    indexJSCustomGameFILE << "GPE.rsm.audioIsReadyForLoading = true; \n";

                                    indexJSCustomGameFILE << "var _scn_temp_layer = IS_NULL; \n\n";
                                    record_error("Creating  scenes...");
                                    for( iRes = 0; iRes < (int)buildGameSceneOptions.size(); iRes++)
                                    {
                                        tempContainer = buildGameSceneOptions[iRes];
                                        if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                        {
                                            tempScnRes = (gameSceneResource * ) tempContainer->get_held_resource();
                                            tempScnRes->build_intohtml5_file(&indexJSCustomGameFILE,0);
                                        }
                                    }
                                    record_error("Scenes created");
                                    if( projectSettingsObject->projectGameMacros!=NULL)
                                    {
                                        indexJSCustomGameFILE << "//Start of Project Macros \n";
                                        projectSettingsObject->projectGameMacros->write_short_data_into_file(&indexJSCustomGameFILE,0,true);
                                        indexJSCustomGameFILE << "//End of Project Macros \n";
                                    }
                                }

                                //Closes the custom gpe_app.js file
                                indexJSCustomGameFILE.close();
                                record_error("Building CSS file..");
                                if( !hadSaveErrors || MAIN_EDITOR_SETTINGS->stopCompileOnError->is_clicked()==false )
                                {
                                    std::string indexCustomCSSGameFileName = projectBuildDirectory+"/css/gpe_custom_style.css";
                                    std::ofstream indexCustomCSSGameFile ( indexCustomCSSGameFileName.c_str() );
                                    GPE_Main_Logs->log_build_line("Creating [gpe_custom_styles.css] file...");
                                    if (indexCustomCSSGameFile.is_open())
                                    {
                                        for( iRes = 0; iRes < (int)buildFontOptions.size(); iRes++)
                                        {
                                            tempContainer = buildFontOptions[iRes];
                                            if( tempContainer!=NULL && tempContainer->get_held_resource()!=NULL)
                                            {
                                                tempFntRes = (fontResource * ) tempContainer->get_held_resource();
                                                tempFntRes->build_css3_file(&indexCustomCSSGameFile,0);
                                            }
                                        }
                                        indexCustomCSSGameFile << "\n";
                                        indexCustomCSSGameFile <<"body\n{\n   background-color: #" << projectSettingsObject->projectWebsiteBackgroundColor->get_hex_string() << ";\n   color: #" << projectSettingsObject->projectTextParagraphColor->get_hex_string()<< ";\n width: 100%;\n height: 100%;\n}\n";
                                        indexCustomCSSGameFile <<"canvas\n{\nborder-color: #" << projectSettingsObject->projectBorderColor->get_hex_string() << ";\n}\n";
                                        indexCustomCSSGameFile <<"h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11, h12\n{\n  color: #" << projectSettingsObject->projectTextHeaderColor->get_hex_string() << ";\n}\n";
                                        indexCustomCSSGameFile <<"p\n{\n  color: #" << projectSettingsObject->projectTextParagraphColor->get_hex_string() << ";\n}\n";
                                        indexCustomCSSGameFile <<"a,a:link\n{\n     color: #" << projectSettingsObject->projectTextLinkColor->get_hex_string() << ";\n}\n";
                                        indexCustomCSSGameFile <<"a:active\n{\n     color: #" << projectSettingsObject->projectTextLinkActiveColor->get_hex_string() << ";\n}\n";
                                        indexCustomCSSGameFile <<"a:hover\n{\n     color: #" << projectSettingsObject->projectTextLinkHoverColor->get_hex_string() << ";\n}\n";
                                        indexCustomCSSGameFile <<"a:visited\n{\n     color: #" << projectSettingsObject->projectTextLinkVisitedColor->get_hex_string() << ";\n}\n";
                                        indexCustomCSSGameFile <<"\n\n";

                                        if( buildMetaTemplate ==GPE_BUILD_HTML5 && projectSettingsObject->projectCSSCode!=NULL )
                                        {
                                            projectSettingsObject->projectCSSCode->write_short_data_into_file(&indexHTML5FILE,2,true);
                                        }
                                        indexCustomCSSGameFile.close();
                                    }
                                    else
                                    {
                                        hadSaveErrors = true;
                                        GPE_Main_Logs->log_build_error("Project Build Error: Unable to create [gpe_custom_style.css]..");
                                    }
                                }
                                //Final check for build errors
                                if( !hadSaveErrors)
                                {
                                    GPE_Main_Logs->log_build_line("Game built with no detected errors.");
                                    if( runGameOnCompile && buildMetaTemplate==GPE_BUILD_HTML5)
                                    {
                                        GPE_Main_Logs->log_build_line("Opening... "+indexHTML5FileName+" .");
                                        GPE_OpenURL(indexHTML5FileName);
                                    }
                                }
                                else
                                {
                                    remove(indexJSCustomGameFileName.c_str());
                                }
                            }
                            else
                            {
                                hadSaveErrors = true;
                                GPE_Main_Logs->log_build_error("Unable to create [gpe_app.js]..");
                            }
                        }
                        else
                        {
                            hadSaveErrors = true;
                            display_user_alert("Project Build Error!","Unable to create game [index.html] file...");
                            GPE_Main_Logs->log_build_error("Unable to create game [index.html] file...");
                        }
                        if(RESC_PROJECT_FOLDER!=NULL)
                        {
                            //hadSaveErrors = RESC_PROJECT_FOLDER->write_data_into_projectfile(&indexHTML5FILE);
                        }
                    }
                    else
                    {
                        hadSaveErrors = true;
                    }
                }
                else
                {
                    hadSaveErrors = true;
                }
            }
            else
            {
                hadSaveErrors = true;
                GPE_Main_Logs->log_build_error("At least one game object must exist in project...[Build canceled]");
            }
        }
        else
        {
            hadSaveErrors = true;
            GPE_Main_Logs->log_build_error("At least one game scene must exist in project...[Build cancelede]");
        }
    }
    if( hadSaveErrors)
    {
        GPE_Main_Logs->log_build_error("Unable to build game!");
        display_user_alert("Project Build Error!","Unable to build game! Please see error log...");
    }
    return hadSaveErrors;
}

bool GPE_ProjectFolder::export_project_wiiu( bool inDebugMode)
{
    displayMessageTitle = "Exporting Project";
    displayMessageSubtitle = "WiiU Export";
    displayMessageString = projectFileName;
    display_user_messaage();
    std::string projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/wiiu";
    projectBuildDirectory = GPE_MAIN_GUI->setup_build_folder(projectBuildDirectory,GPE_BUILD_WIIU,64,inDebugMode);
    return export_project_html5( projectBuildDirectory,GPE_BUILD_WIIU,false,inDebugMode);
}

bool GPE_ProjectFolder::export_project_windows(std::string projectBuildDirectory, int buildBits, bool runGameOnCompile, bool inDebugMode , int nativeBuildType )
{
    bool buildResult = false;
    if( GPE_Main_Logs!=NULL)
    {
        GPE_Main_Logs->clear_build_log();
        GPE_Main_Logs->log_build_line("-------------- Building: ["+projectName+"] ["+GPE_BUILD_NAMES[GPE_BUILD_WINDOWS]+" Export] (Compiler: Pawbitious Compiler)---------------");

        if( nativeBuildType!=Native_None)
        {
            GPE_Main_Logs->log_build_line("-------------- Building: ["+projectName+"] ["+GPE_BUILD_NAMES[GPE_BUILD_WINDOWS]+" Export] (Compiler: Pawbitious Compiler)---------------");
            displayMessageTitle = "Exporting Project";
            displayMessageSubtitle = "Windows Export";
            displayMessageString = projectFileName;
            display_user_messaage();
            if( (int)projectBuildDirectory.size() < 3)
            {
                projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/windows";
            }
            std::string pBuildDirectory = GPE_MAIN_GUI->setup_build_folder(projectBuildDirectory,GPE_BUILD_WINDOWS,buildBits,inDebugMode,nativeBuildType);
            buildResult =  export_project_html5( pBuildDirectory,GPE_BUILD_WINDOWS,runGameOnCompile, inDebugMode );

            if( runGameOnCompile && GPE_FOUND_OS==GPE_IDE_WINDOWS)
            {
                run_project(projectBuildDirectory,GPE_IDE_WINDOWS,buildBits,inDebugMode);
                /*
                std::string appAddonFileName = "";
                if( buildBits==64)
                {
                    appAddonFileName+="_64";
                }
                if( inDebugMode)
                {
                    appAddonFileName+="_debug";
                }
                if( file_exists(pBuildDirectory+"/../../game"+appAddonFileName+".exe") )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../game"+appAddonFileName+".exe");
                }
                else if( file_exists(pBuildDirectory+"/../../electron"+appAddonFileName+".exe") )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../electron"+appAddonFileName+".exe");
                }
                */
            }
        }
        else
        {
            GPE_Main_Logs->open_build_log();
            GPE_Main_Logs->log_build_error("Project not built. Native Build Type NOT Selected");
        }
    }
    else
    {
        record_error("Unable to build game. Internal Log error");
    }
    return buildResult;
}

bool GPE_ProjectFolder::export_project_osx(std::string projectBuildDirectory, int buildBits, bool runGameOnCompile, bool inDebugMode , int nativeBuildType)
{
    bool buildResult = false;
    if( GPE_Main_Logs!=NULL)
    {
        GPE_Main_Logs->clear_build_log();
        GPE_Main_Logs->log_build_line("-------------- Building: ["+projectName+"] ["+GPE_BUILD_NAMES[GPE_BUILD_MAC]+" Export] (Compiler: Pawbitious Compiler)---------------");
        if( nativeBuildType!=Native_None)
        {
            displayMessageTitle = "Exporting Project";
            displayMessageSubtitle = "OSX Export";
            displayMessageString = projectFileName;
            display_user_messaage();
            if( (int)projectBuildDirectory.size() < 3)
            {
                projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/osx";
            }
            std::string pBuildDirectory  = GPE_MAIN_GUI->setup_build_folder(projectBuildDirectory,GPE_BUILD_MAC,buildBits,inDebugMode, nativeBuildType);
            buildResult =  export_project_html5( pBuildDirectory,GPE_BUILD_MAC, runGameOnCompile, inDebugMode );
            if( runGameOnCompile && GPE_FOUND_OS==GPE_IDE_MAC)
            {
                run_project(projectBuildDirectory,GPE_IDE_MAC,buildBits,inDebugMode);

                /*
                std::string appAddonFileName = "";
                if( buildBits==64)
                {
                    appAddonFileName+="_64";
                }
                if( inDebugMode)
                {
                    appAddonFileName+="_debug";
                }
                if( file_exists(pBuildDirectory+"/../../game"+appAddonFileName+".app") )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../game"+appAddonFileName+".app");
                }
                else if( file_exists(pBuildDirectory+"/../../Game"+appAddonFileName+".app") )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../Game"+appAddonFileName+".app");
                }
                else if(file_exists(pBuildDirectory+"/../../Electron"+appAddonFileName+".app") )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../Electron"+appAddonFileName+".app");
                }
                else if(file_exists(pBuildDirectory+"/../../electron"+appAddonFileName+".app") )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../electron"+appAddonFileName+".app");
                }
                */
            }
        }
        else
        {
            GPE_Main_Logs->open_build_log();
            GPE_Main_Logs->log_build_error("Project not built. Native Build Type NOT Selected");
        }
    }
    else
    {
        record_error("Unable to build game. Internal Log error");
    }
    return buildResult;
}

bool GPE_ProjectFolder::export_project_linux(std::string projectBuildDirectory, int buildBits, bool runGameOnCompile, bool inDebugMode , int nativeBuildType)
{
    bool buildResult = false;
    if( GPE_Main_Logs!=NULL)
    {
        GPE_Main_Logs->clear_build_log();
        GPE_Main_Logs->log_build_line("-------------- Building: ["+projectName+"] ["+GPE_BUILD_NAMES[GPE_BUILD_LINUX]+" Export] (Compiler: Pawbitious Compiler)---------------");
        if( nativeBuildType!=Native_None)
        {
            displayMessageTitle = "Exporting Project";
            displayMessageSubtitle = "Linux Export";
            displayMessageString = projectFileName;
            display_user_messaage();
            if( (int)projectBuildDirectory.size() < 3)
            {
                projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/linux";
            }
            std::string pBuildDirectory  = GPE_MAIN_GUI->setup_build_folder(projectBuildDirectory,GPE_BUILD_LINUX,buildBits,inDebugMode, nativeBuildType);
            bool buildResult =  export_project_html5( pBuildDirectory,GPE_BUILD_LINUX, runGameOnCompile , inDebugMode);

            if( runGameOnCompile && GPE_FOUND_OS==GPE_IDE_LINUX )
            {
                run_project(projectBuildDirectory,GPE_IDE_LINUX,buildBits,inDebugMode);
                /*
                std::string appAddonFileName = "";
                if( buildBits==64)
                {
                    appAddonFileName+="_64";
                }
                if( inDebugMode)
                {
                    appAddonFileName+="_debug";
                }
                if( file_exists(pBuildDirectory+"/../../game"+appAddonFileName) )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../game"+appAddonFileName);
                }
                else if( file_exists(pBuildDirectory+"/../../electron"+appAddonFileName) )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../electron"+appAddonFileName);
                }
                else if( file_exists(pBuildDirectory+"/../../Electron"+appAddonFileName) )
                {
                    GPE_OpenProgram(pBuildDirectory+"/../../Electron"+appAddonFileName);
                }
                */
            }
        }
        else
        {
            GPE_Main_Logs->open_build_log();
            GPE_Main_Logs->log_build_error("Project not built. Native Export Mode not selected");
        }
    }
    else
    {
        record_error("Unable to build game. Internal Log error");
    }
    return buildResult;
}

std::string GPE_ProjectFolder::get_project_name()
{
    return projectName;
}

std::string GPE_ProjectFolder::get_project_directory()
{
    return projectDirectory;
}

std::string GPE_ProjectFolder::get_project_file_name()
{
    return projectFileName;
}

int GPE_ProjectFolder::get_resource_count()
{
    if( RESC_PROJECT_FOLDER!=NULL)
    {
        return RESC_PROJECT_FOLDER->get_resource_count();
    }
    return 0;
}

bool GPE_ProjectFolder::load_project_file(std::string projectFileIn )
{
    displayMessageTitle = "Loading Project";
    displayMessageSubtitle = "Opening File";
    displayMessageString = projectFileIn;
    display_user_messaage();

    if( (int)projectFileIn.size() > 0)
    {
        std::ifstream newprofileFile( projectFileIn.c_str() );

        //If the level file could be loaded
        if( !newprofileFile.fail() )
        {
            //makes sure the file is open
            if (newprofileFile.is_open())
            {
                projectFileName = projectFileIn;
                CURRENT_PROJECT_NAME = projectFileIn;
                CURRENT_PROJECT = GPE_MAIN_GUI->find_project_from_name(CURRENT_PROJECT_NAME);
                displayMessageSubtitle = "File Opened";
                display_user_messaage();
                GPE_ResourceContainer * currentResFolder = NULL;
                GPE_ResourceContainer * tempResFolder = NULL;
                GPE_ResourceContainer * containerFolderToEdit = NULL;
                GPE_ResourceContainer * newContainer = NULL;
                spriteResource * tempSprRes = NULL;
                textureResource * tempTexRes = NULL;
                tilesheetResource * tempTstRes = NULL;
                audioResource * tempAudRes = NULL;
                videoResource * tempVidRes = NULL;
                gamePathResource * tempPathRes = NULL;
                functionResource * tempFuncRes = NULL;
                gameObjectResource * tempObjRes = NULL;
                gameSceneResource * tempScnRes = NULL;
                //achievementResource * tempAchRes = NULL;
                fontResource * tempFntRes = NULL;
                std::string firstChar="";
                std::string section="";
                std::string cur_layer="";
                std::string data_format="";
                std::string keyString="";
                std::string valString="";
                std::string subValString="";
                std::string currLine="";
                std::string newResName= "";
                std::string tempNewResName = "";
                int equalPos=-1;
                int endBracketPos = -1;
                int foundResGlobalId = -1;
                int tempStrToInt = -1;
                int iItr = 0;
                int iLang = 0;

                std::vector <spriteResource *> projectGameSprites;
                std::vector <textureResource *> projectGameTextures;
                std::vector <tilesheetResource *> projectGameTilesheets;
                std::vector <audioResource * > projectGameAudio;
                std::vector <videoResource *> projectGameVideos;
                std::vector <gamePathResource *> projectGamePaths;
                std::vector <functionResource *> projectGameFunctions;
                std::vector <gameObjectResource *> projectGameObjects;
                std::vector <gameSceneResource *> projectScenes;
                std::vector <fontResource *> projectGameFonts;

                displayMessageTitle = "Loading Project";
                displayMessageSubtitle = "Reading Project Data";
                displayMessageString = "...";
                display_user_messaage();
                //makes sure the file is in good condition and the version is still unloaded
                while ( newprofileFile.good() )
                {
                    getline (newprofileFile,currLine); //gets the next line of the file
                    currLine = trim_left_inplace(currLine);
                    currLine = trim_right_inplace(currLine);

                    if(!currLine.empty() )
                    {
                        // skips comment lines
                        if( currLine[0]!= '#' && currLine[0]!='/'  )
                        {
                            //searches for an equal character and parses through the variable
                            equalPos=currLine.find_first_of("=");
                            if(equalPos!=(int)std::string::npos)
                            {
                                //if the equalPos is present, then parse on through and carryon
                                keyString = currLine.substr(0,equalPos);
                                valString = currLine.substr(equalPos+1,currLine.length());
                                //finds the version of the game level file
                                if (keyString== "Version")
                                {
                                    projectFilePreviousVersion = projectFileVersion = string_to_double(valString,1);

                                    if( !compare_doubles(projectFileVersion , GPE_VERSION_DOUBLE_NUMBER) && projectFileVersion < GPE_VERSION_DOUBLE_NUMBER )
                                    {
                                        if( display_get_prompt("Project Version Warning!","The following project version varies from the current version of this editor. Are you sure you will like to import this. Please note saving/loading may experience difficulties we recommend you back up these project files/folders before importing...")!=DISPLAY_QUERY_YES )
                                        {
                                            newprofileFile.close();
                                            GPE_Main_Logs->log_general_line("Project import canceled ( Older version )");
                                            return false;
                                        }
                                        else
                                        {
                                            if( GPE_MAIN_GUI->editorReleaseType!=RELEASE_TYPE_RELEASE )
                                            {
                                                if( display_get_prompt("WARNING!","You are using a non-release version of the editor. Are you sure you will like to continue? Potential incompatibility issues may happen in later versions.")!=DISPLAY_QUERY_YES )
                                                {
                                                    newprofileFile.close();
                                                    GPE_Main_Logs->log_general_line("Project import canceled ( Alpha/Beta version )");
                                                    return false;
                                                }
                                            }
                                            GPE_Main_Logs->log_general_line("Attempting to open older project...");
                                        }
                                    }
                                    else if( GPE_MAIN_GUI->editorReleaseType!=RELEASE_TYPE_RELEASE )
                                    {
                                        if( display_get_prompt("WARNING!","You are using a non-release version of the editor. Are you sure you will like to continue? Potential incompatibility issues may happen in later versions.")!=DISPLAY_QUERY_YES )
                                        {
                                            newprofileFile.close();
                                            GPE_Main_Logs->log_general_line("Project import canceled ( Alpha/Beta version )");
                                            return false;
                                        }
                                    }
                                }
                                else if( keyString=="Count" || keyString=="ResourcesCount")
                                {
                                    tempStrToInt = string_to_int(valString);
                                    if( tempStrToInt> 1000)
                                    {
                                        GLOBAL_REZ_ID_COUNT = tempStrToInt;
                                    }
                                }
                                else if(keyString=="ProjectName" || keyString=="Name")
                                {
                                    projectName = valString;
                                    RESC_PROJECT_FOLDER->set_name(projectName);
                                }
                                else if(keyString=="ProjectLanguage" || keyString=="ProgrammingLanguage" || keyString=="CodingLanguage")
                                {
                                    for( iLang = 0; iLang < PROJECT_LANGUAGE_MAX; iLang++)
                                    {
                                        if( valString==PROJECT_LANGUAGE_NAMES[iLang] )
                                        {
                                            myProjectLanguage = iLang;
                                        }
                                    }
                                }
                                else if( keyString == "ProjectIcon")
                                {
                                    projectIconName = valString;
                                }
                                else if(keyString=="[SuperFolder")
                                {
                                    endBracketPos=currLine.find_first_of("]");
                                    if(endBracketPos!=(int)std::string::npos)
                                    {
                                        valString = currLine.substr(equalPos+1,endBracketPos-equalPos-1);
                                        if( (int)valString.size()>0)
                                        {
                                            tempResFolder = RESC_PROJECT_FOLDER->find_resource_from_name(valString,false);
                                            if( tempResFolder!=NULL)
                                            {
                                                containerFolderToEdit = currentResFolder = tempResFolder;
                                                tempResFolder = NULL;
                                            }
                                        }
                                    }
                                }
                                else if(keyString=="[Folder")
                                {
                                    valString = currLine.substr(equalPos+1,endBracketPos-equalPos-1);
                                    if( (int)valString.size()>0 && containerFolderToEdit!=NULL)
                                    {
                                        endBracketPos=currLine.find_first_of("]");
                                        if(endBracketPos!=(int)std::string::npos)
                                        {
                                            valString = currLine.substr(equalPos+1,endBracketPos-equalPos-1);
                                            if( (int)valString.size()>0)
                                            {
                                                newResName = split_first_string(valString,',');
                                                foundResGlobalId = string_to_int(valString,-1);
                                                tempResFolder = containerFolderToEdit->find_resource_from_name(newResName,false);
                                                if( tempResFolder!=NULL)
                                                {
                                                    containerFolderToEdit = containerFolderToEdit->find_resource_from_name(newResName,false);
                                                }
                                                else
                                                {
                                                    containerFolderToEdit = create_blank_folder(containerFolderToEdit,newResName,foundResGlobalId);
                                                }
                                            }
                                        }
                                    }
                                }
                                else if(keyString=="Sprite")
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_sprite(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempSprRes = (spriteResource * )newContainer->get_held_resource();
                                        if( tempSprRes!=NULL)
                                        {
                                            tempSprRes->resourcePostProcessed = false;
                                            projectGameSprites.push_back(tempSprRes);
                                        }
                                    }
                                }
                                else if( keyString=="Texture" || keyString=="texture" )
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_texture(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempTexRes = (textureResource * )newContainer->get_held_resource();
                                        if( tempTexRes!=NULL)
                                        {
                                            tempTexRes->resourcePostProcessed = false;
                                            projectGameTextures.push_back(tempTexRes);
                                        }
                                    }
                                }
                                else if(keyString=="Tilesheet" || keyString=="tilesheet")
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_tilesheet(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempTstRes = (tilesheetResource * )newContainer->get_held_resource();
                                        if( tempTstRes!=NULL)
                                        {
                                            tempTstRes->resourcePostProcessed = false;
                                            projectGameTilesheets.push_back(tempTstRes);
                                        }
                                    }
                                }
                                else if( keyString=="Audio" || keyString=="audio" )
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_audio(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempAudRes = (audioResource * )newContainer->get_held_resource();
                                        if( tempAudRes!=NULL)
                                        {
                                            tempAudRes->resourcePostProcessed = false;
                                            projectGameAudio.push_back( tempAudRes);
                                         }
                                    }
                                }
                                else if( keyString=="Video" || keyString=="video" )
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_video(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempVidRes = (videoResource * )newContainer->get_held_resource();
                                        if( tempVidRes!=NULL)
                                        {
                                            tempVidRes->resourcePostProcessed = false;
                                            projectGameVideos.push_back( tempVidRes);
                                         }
                                    }
                                }
                                 else if( keyString=="Path" || keyString=="path" )
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_path(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempPathRes = (gamePathResource * )newContainer->get_held_resource();
                                        if( tempPathRes!=NULL)
                                        {
                                            tempPathRes->resourcePostProcessed = false;
                                            projectGamePaths.push_back( tempPathRes);
                                         }
                                    }
                                }
                                else if( keyString=="Function" || keyString=="functions" )
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_function(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempFuncRes = (functionResource * )newContainer->get_held_resource();
                                        if( tempFuncRes!=NULL)
                                        {
                                            tempFuncRes->resourcePostProcessed = false;
                                            projectGameFunctions.push_back( tempFuncRes);
                                        }
                                    }
                                }
                                else if( keyString=="Object" || keyString=="object"|| keyString=="GameObject"|| keyString=="Game-Object" || keyString=="Actor"|| keyString=="actor" )
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_gameobject(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempObjRes = (gameObjectResource * )newContainer->get_held_resource();
                                        if( tempObjRes!=NULL)
                                        {
                                            tempObjRes->resourcePostProcessed = false;
                                            projectGameObjects.push_back(tempObjRes);
                                        }
                                    }
                                }
                                else if( keyString=="Scene" || keyString=="scene"|| keyString=="GameScene"|| keyString=="Game-Scene"  )
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_scene(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempScnRes = (gameSceneResource * )newContainer->get_held_resource();
                                        if( tempScnRes!=NULL)
                                        {
                                            tempScnRes->scnPostProcessed = false;
                                            projectScenes.push_back(tempScnRes);
                                        }
                                    }
                                }
                                else if(keyString=="Font" || keyString=="font")
                                {
                                    tempNewResName = split_first_string(valString,',');
                                    foundResGlobalId = split_first_int(valString,',');
                                    newContainer = create_blank_font(containerFolderToEdit,tempNewResName,foundResGlobalId);
                                    if( newContainer->get_held_resource()!=NULL)
                                    {
                                        tempFntRes = (fontResource * )newContainer->get_held_resource();
                                        if( tempFntRes!=NULL)
                                        {
                                            tempFntRes->resourcePostProcessed = false;
                                            projectGameFonts.push_back(tempFntRes);
                                        }
                                    }
                                }
                            }
                            else if(currLine=="[/Folder]")
                            {
                                if( containerFolderToEdit!=NULL)
                                {
                                    if( containerFolderToEdit->parentResource!=NULL)
                                    {
                                        containerFolderToEdit = containerFolderToEdit->parentResource;
                                    }
                                    else
                                    {
                                        containerFolderToEdit = NULL;
                                        tempResFolder = NULL;
                                    }
                                }
                                else
                                {
                                    tempResFolder = NULL;
                                }
                            }
                            else if(currLine=="[/SuperFolder]")
                            {
                                containerFolderToEdit = NULL;
                                tempResFolder = NULL;
                            }
                        }
                    }
                }
                newprofileFile.close();

                std::string projectLayerInfoFileName =projectDirectory+"/gpe_project/project_layer_info.gpf";
                std::ifstream projectLayerInfoFile (projectLayerInfoFileName.c_str() );
                int iLayerN = 0;
                while ( projectLayerInfoFile.good() )
                {
                    getline (projectLayerInfoFile,currLine); //gets the next line of the file
                    currLine = trim_left_inplace(currLine);
                    currLine = trim_right_inplace(currLine);

                    if(!currLine.empty() )
                    {
                        // skips comment lines
                        if( currLine[0]!= '#' && currLine[0]!='/'  )
                        {
                            //searches for an equal character and parses through the variable
                            equalPos=currLine.find_first_of("=");
                            if(equalPos!=(int)std::string::npos)
                            {
                                //if the equalPos is present, then parse on through and carryon
                                keyString = currLine.substr(0,equalPos);
                                valString = currLine.substr(equalPos+1,currLine.length());
                                for( iLayerN = 0; iLayerN < 32; iLayerN++)
                                {
                                    if( keyString == "ProjectLayerName["+int_to_string(iLayerN)+"]" )
                                    {
                                        projectLayerNames[iLayerN]  = valString;
                                    }
                                }
                            }
                        }
                    }
                }

                for( iItr = 0; iItr < (int)projectGameTextures.size(); iItr++)
                {
                    tempTexRes = projectGameTextures[iItr];
                    if( tempTexRes!=NULL)
                    {
                        tempTexRes->preprocess_self();
                    }
                }
                for( iItr = 0; iItr < (int)projectGameTilesheets.size(); iItr++)
                {
                    tempTstRes = projectGameTilesheets[iItr];
                    if( tempTstRes!=NULL)
                    {
                        tempTstRes->preprocess_self();
                    }
                }
                for( iItr = 0; iItr < (int)projectGameSprites.size(); iItr++)
                {
                    tempSprRes = projectGameSprites[iItr];
                    if( tempSprRes!=NULL)
                    {
                        tempSprRes->preprocess_self();
                    }
                }
                for( iItr = 0; iItr < (int)projectGameAudio.size(); iItr++)
                {
                    tempAudRes = projectGameAudio[iItr];
                    if( tempAudRes!=NULL)
                    {
                        tempAudRes->preprocess_self();
                    }
                }
                for( iItr = 0; iItr < (int)projectGameVideos.size(); iItr++)
                {
                    tempVidRes = projectGameVideos[iItr];
                    if( tempVidRes!=NULL)
                    {
                        tempVidRes->preprocess_self();
                    }
                }

                for( iItr = 0; iItr < (int)projectGamePaths.size(); iItr++)
                {
                    tempPathRes = projectGamePaths[iItr];
                    if( tempPathRes!=NULL)
                    {
                        tempPathRes->preprocess_self();
                    }
                }

                for( iItr = 0; iItr < (int)projectGameFonts.size(); iItr++)
                {
                    tempFntRes = projectGameFonts[iItr];
                    if( tempFntRes!=NULL)
                    {
                        tempFntRes->preprocess_self();
                    }
                }

                for( iItr = 0; iItr < (int)projectGameFunctions.size(); iItr++)
                {
                    tempFuncRes = projectGameFunctions[iItr];
                    if( tempFuncRes!=NULL)
                    {
                        tempFuncRes->preprocess_self();
                    }
                }
                for( iItr = 0; iItr < (int)projectGameObjects.size(); iItr++)
                {
                    tempObjRes = projectGameObjects[iItr];
                    if( tempObjRes!=NULL)
                    {
                        tempObjRes->preprocess_self();
                    }
                }
                for( iItr = 0; iItr < (int)projectScenes.size(); iItr++)
                {
                    tempScnRes = projectScenes[iItr];
                    if( tempScnRes!=NULL)
                    {
                        tempScnRes->preprocess_self();
                    }
                }
                RESC_PROJECT_SETTINGS->set_project_parent_name(projectFileIn);
                RESC_PROJECT_SETTINGS->preprocess_container();
                record_error("Project successfully preprocessed.");

                time( &lastTimeBackedUp);
                return true;
            }
            else
            {
                display_user_alert("Project Open Error","Unable to open file");
            }
        }
        else
        {
            display_user_alert("Project Open Error","Unable to process file");
        }
    }
    else
    {
        display_user_alert("Project Open Error","Invalid File given");
    }
    return false;
}

bool GPE_ProjectFolder::check_obj_inlist(int objTypeIdIn)
{
    for( int i = 0; i < (int)currentObjParents.size(); i++)
    {
        if( currentObjParents[i]==objTypeIdIn)
        {
            return true;
        }
    }
    return false;
}

void GPE_ProjectFolder::swap_obj_lists()
{
    currentObjParents.clear();
    if( (int)nextObjParents.size() > 0)
    {
        finalObjParents.clear();
    }
    for( int i = 0; i < (int)nextObjParents.size(); i++)
    {
        currentObjParents.push_back( nextObjParents[i] );
        finalObjParents.push_back( nextObjParents[i] );
    }
    nextObjParents.clear();
}

void GPE_ProjectFolder::begin_obj_reverse_inheritence()
{
    currentObjParents.clear();
    for( int i = 0; i < (int)finalObjParents.size(); i++)
    {
        currentObjParents.push_back( finalObjParents[i] );
    }
    nextObjParents.clear();
}

void GPE_ProjectFolder::integrate_synthax()
{
    clear_project_functions();
    clear_project_keywords();
    CURRENT_PROJECT = this;
    CURRENT_PROJECT_NAME = projectFileName;
    if( RESC_PROJECT_FOLDER!=NULL)
    {
        RESC_PROJECT_FOLDER->integrate_into_synthax();
    }
}


int GPE_ProjectFolder::increment_resouce_count()
{
    GLOBAL_REZ_ID_COUNT+=1;
    return GLOBAL_REZ_ID_COUNT;
}

bool GPE_ProjectFolder::run_project(std::string projectBuildDirectory, int buildMetaTemplate,int buildBits, bool inDebugMode )
{
    if( buildMetaTemplate == GPE_BUILD_HTML5)
    {
        if( projectBuildDirectory.empty() )
        {
            projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/html5";
        }
        if( file_exists(projectBuildDirectory+"/index.html")==true )
        {
            GPE_OpenURL(projectBuildDirectory+"/index.html");
            return true;
        }
        else
        {
            display_user_alert("[Run Project Error]","Please first build this project");
        }
    }
    else if( buildMetaTemplate==GPE_BUILD_WINDOWS && GPE_FOUND_OS==GPE_IDE_WINDOWS)
    {
        if( projectBuildDirectory.empty() )
        {
            projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/windows";
        }
        /*if( buildBits==64)
        {
            projectBuildDirectory+="_64";
        }
        else
        {
            projectBuildDirectory+="_32";
        }
        if( inDebugMode)
        {
            //projectBuildDirectory+="_debug";
        }*/
        if( file_exists(projectBuildDirectory+"/game.exe")==true )
        {
            GPE_OpenProgram(projectBuildDirectory+"/game.exe");
            return true;
        }
        else if( file_exists(projectBuildDirectory+"/electron.exe")==true )
        {
            GPE_OpenProgram(projectBuildDirectory+"/electron.exe");
            return true;
        }
        else
        {
            display_user_alert("[Run Project Error]","Please first build this project");
        }
    }
    else if( buildMetaTemplate==GPE_BUILD_MAC && GPE_FOUND_OS==GPE_IDE_MAC)
    {
        if( projectBuildDirectory.empty() )
        {
            projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/osx";
        }
        /*
        if( buildBits==64)
        {
            projectBuildDirectory+="_64";
        }
        else
        {
            projectBuildDirectory+="_32";
        }
        if( inDebugMode)
        {
            //projectBuildDirectory+="_debug";
        }
        */
        if( file_exists(projectBuildDirectory+"/game.app")==true )
        {
            GPE_OpenProgram(projectBuildDirectory+"/game.app");
            return true;
        }
        else if( file_exists(projectBuildDirectory+"/electron.app")==true )
        {
            GPE_OpenProgram(projectBuildDirectory+"/electron.app");
            return true;
        }
        else
        {
            display_user_alert("[Run Project Error]","Please first build this project");
        }
    }
    else if( buildMetaTemplate==GPE_BUILD_LINUX && GPE_FOUND_OS==GPE_IDE_LINUX)
    {
        if( projectBuildDirectory.empty() )
        {
            projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/linux";
        }
        if( buildBits==64)
        {
            projectBuildDirectory+="_64";
        }
        else
        {
            projectBuildDirectory+="_32";
        }
        if( inDebugMode)
        {
            //projectBuildDirectory+="_debug";
        }
        if( file_exists(projectBuildDirectory+"/game")==true )
        {
            GPE_OpenProgram(projectBuildDirectory+"/game");
            return true;
        }
        else if( file_exists(projectBuildDirectory+"/electron")==true )
        {
            GPE_OpenProgram(projectBuildDirectory+"/electron");
            return true;
        }
        else
        {
            display_user_alert("[Run Project Error]","Please first build this project");
        }
    }
    else if( buildMetaTemplate==GPE_BUILD_WIIU)
    {
        /*
        if( projectBuildDirectory.empty() )
        {
            projectBuildDirectory = fileToDir(projectFileName)+"/gpe_project/builds/wiiu";
        }
        if( file_exists(projectBuildDirectory+"/index.html")==true)
        {
            GPE_OpenURL(projectBuildDirectory+"/index.html");
        }
        else
        {
            display_user_alert("[Run Project Error]","Please first build this project");
        }
        */
        display_user_alert("[Run Project Error]","Please use the WiiU Developer Version!");
    }
    return false;
}

bool GPE_ProjectFolder::save_project()
{
    return save_project_as(projectFileName);
}

bool GPE_ProjectFolder::save_project_as(std::string projectFileNewName)
{
    bool hadSaveErrors = false;
    if( (int)projectFileNewName.size()>3)
    {
        displayMessageTitle = "Saving Project";
        displayMessageSubtitle = "Opening File";
        displayMessageString = projectFileName;
        display_user_messaage();
        record_error(displayMessageTitle+" "+projectFileName);
        bool isSameFileName = false;
        bool saveAuthorized = false;
        if( !compare_doubles(projectFilePreviousVersion , GPE_VERSION_DOUBLE_NUMBER ) && projectFilePreviousVersion < GPE_VERSION_DOUBLE_NUMBER )
        {
            std::string versionComparePhrase = "The following project version varies from the current version of this editor. Are you sure you will like to save this. Please note saving/loading may experience difficulties we recommend you back up these project files/folders ELSEWHERE before saving...";
            if( display_get_prompt("Project Version Warning!",versionComparePhrase)==DISPLAY_QUERY_YES )
            {
                saveAuthorized = true;
            }
            else
            {
                hadSaveErrors = true;
                saveAuthorized= false;
            }
        }
        else
        {
            saveAuthorized = true;
        }

        if( saveAuthorized)
        {
            if( projectFileNewName.compare(projectFileName)==0)
            {
                isSameFileName = true;
            }
            else
            {
                isSameFileName = false;
            }
            if( !isSameFileName)
            {
                projectFileName = projectFileNewName;
                projectDirectory = get_path_from_file(projectFileName);
                std::string newProjectLocalFileName = get_local_from_global_file(projectFileName);
                if( (int)newProjectLocalFileName.size()>0 )
                {
                    projectDirectory = projectDirectory+"/"+projectFileName;
                    display_user_alert("Error:",projectDirectory.c_str() );

                    GPE_MAIN_GUI->setup_project_directory(projectDirectory);
                }
                else
                {
                    display_user_alert("Error!","Unable to save project("+projectFileName+")");
                }
                CURRENT_PROJECT_NAME = projectFileName;
                CURRENT_PROJECT = this;
                if(RESC_PROJECT_FOLDER!=NULL)
                {
                    RESC_PROJECT_FOLDER->set_project_parent_name(projectFileName);
                }
            }
            else
            {
                GPE_MAIN_GUI->setup_project_directory(projectDirectory);
            }

            std::ofstream myfile (projectFileName.c_str() );
            if (myfile.is_open())
            {
                myfile << "#    --------------------------------------------------  # \n";
                myfile << "#     \n";
                myfile << "#     \n";
                myfile << "#    Game Pencil Engine Project File \n";
                myfile << "#    Created automatically via the Game Pencil Engine Editor \n";
                myfile << "#    Warning: Manually editing this file may cause unexpected bugs and errors. \n";
                myfile << "#    If you have any problems reading this file please report it to debug@pawbyte.com . \n";
                myfile << "#     \n";
                myfile << "#     \n";
                myfile << "#    --------------------------------------------------  # \n";
                myfile << "Version=" << GPE_VERSION_DOUBLE_NUMBER << "\n";
                myfile << "Name=" << projectName << "\n";

                myfile << "Count=" << GLOBAL_REZ_ID_COUNT << "\n";
                if( myProjectLanguage >=0 && myProjectLanguage < PROJECT_LANGUAGE_MAX)
                {
                    myfile << "ProjectLanguage=" << PROJECT_LANGUAGE_NAMES[myProjectLanguage] << "\n";
                }
                else
                {
                    myfile << "ProjectLanguage=CPP\n";
                }
                myfile << "ProjectIcon=" << projectIconName << "\n";
                if(RESC_PROJECT_FOLDER!=NULL)
                {
                    hadSaveErrors = RESC_PROJECT_FOLDER->write_data_into_projectfile(&myfile);
                }
                time( &lastTimeBackedUp);
                myfile.close();
            }
            else
            {
                record_error("Unable to open to save ["+projectFileNewName+"].");
                hadSaveErrors = true;
            }
            std::string projectLayerInfoFileName =projectDirectory+"/gpe_project/project_layer_info.gpf";
            record_error("Saving project layer info to "+projectLayerInfoFileName);
            std::ofstream projectLayerInfoFile (projectLayerInfoFileName.c_str() );
            if (projectLayerInfoFile.is_open() )
            {
                projectLayerInfoFile << "#    --------------------------------------------------  # \n";
                projectLayerInfoFile << "#     \n";
                projectLayerInfoFile << "#     \n";
                projectLayerInfoFile << "#    Game Pencil Engine Project Layer InfoFile \n";
                projectLayerInfoFile << "#    Created automatically via the Game Pencil Engine Editor \n";
                projectLayerInfoFile << "#    Warning: Manually editing this file may cause unexpected bugs and errors. \n";
                projectLayerInfoFile << "#    If you have any problems reading this file please report it to debug@pawbyte.com . \n";
                projectLayerInfoFile << "#     \n";
                projectLayerInfoFile << "#     \n";
                projectLayerInfoFile << "#    --------------------------------------------------  # \n";
                projectLayerInfoFile << "Version=" << GPE_VERSION_DOUBLE_NUMBER << "\n";
                for( int iLayerN = 0; iLayerN < 32; iLayerN++)
                {
                    projectLayerInfoFile << "ProjectLayerName["+int_to_string(iLayerN)+"]=" << projectLayerNames[iLayerN] << "\n";
                }
                projectLayerInfoFile.close();
                projectFilePreviousVersion = projectFileVersion = GPE_VERSION_DOUBLE_NUMBER;
            }
            else
            {
                record_error("Unable to open to save ["+projectLayerInfoFileName+"].");
                hadSaveErrors = true;
            }

    }
        else
        {
            GPE_Main_Logs->log_build_error("Save averted for Project["+projectFileName+"](not authorized by user choice).");
        }
    }
    else
    {
        record_error("File named "+projectFileNewName+" is too short and does not fit the proper format for project save feature.");
    }
    integrate_synthax();
    return hadSaveErrors;
}

bool GPE_ProjectFolder::save_project_settings()
{
    if( RESC_PROJECT_SETTINGS!=NULL)
    {
        std::string projectSettingsFileName = projectStartDirectoryName+"gpe_project/project_settings.ini";
        std::ofstream myfile (projectSettingsFileName.c_str() );
        if (myfile.is_open() )
        {
            RESC_PROJECT_SETTINGS->write_data_into_projectfile(&myfile,0);
            myfile.close();
            return true;
        }
    }
    return false;
}

GPE_ResourceManagementBar::GPE_ResourceManagementBar()
{
    upDelayTime = 0;
    downDelayTime = 0;
    leftDelayTime = 0;
    rightDelayTime = 0;

    guiListTypeName = "resourcemangementbar";
    resourcebarMoved = true;
    cameraBox.x = 0;
    cameraBox.y = 0;
    cameraBox.w = 128;
    cameraBox.h = 128;

    menuBox.x = 0;
    menuBox.y = 0;
    menuBox.w = 128;
    menuBox.h = 128;

    barBox.x = 0;
    barBox.y = 48;
    barBox.w = 192;
    barBox.h = 128;

    entireBox.x = 0;
    entireBox.y = 48;
    entireBox.w = 192;
    entireBox.h = 32;

    barXPadding = 8;
    barYPadding = 8;
    barBox.h = SCREEN_HEIGHT-barBox.y;
    subMenuIsOpen = true;
    selectedSubOption = -1;
    hasScrollControl = false;
    hasArrowkeyControl = false;
    beingResized = false;
    justResized = false;
    menuResized = true;
    xScroll = new GPE_ScrollBar_XAxis();
    yScroll = new GPE_ScrollBar_YAxis();
    barTitleWidth = 0;
    barTitleHeight = 24;
    DEFAULT_FONT->get_metrics("Project Resources",&barTitleWidth,&barTitleHeight);
    barTitleHeight= 24;
    //menuNameTexture->loadFromRenderedText(MAIN_RENDERER,"Project Resources",GPE_MAIN_TEMPLATE->Main_Box_Font_Color,FONT_CATEGORY_BAR);
    isVisible = true;
    lastWidth = barBox.w;
}

GPE_ResourceManagementBar::~GPE_ResourceManagementBar()
{
    if( xScroll!=NULL)
    {
        delete xScroll;
        xScroll = NULL;
    }

    if( yScroll!=NULL)
    {
        delete yScroll;
        yScroll = NULL;
    }

}

void GPE_ResourceManagementBar::set_height(int newHeight)
{
    if( newHeight!=barBox.h)
    {
        menuResized = true;
    }
    barBox.h = newHeight;
    if( barBox.y+barBox.h >SCREEN_HEIGHT)
    {
        barBox.h = SCREEN_HEIGHT - barBox.y;
    }
    menuBox.h = barBox.h - menuBox.y;//minus extra 32 for xscroll
}

GPE_ResourceContainer * GPE_ResourceManagementBar::add_resource_folder(int resourceType, std::string projFolderName, std::string resourceTypeName)
{
    GPE_ResourceContainer * newResourceFolder = new GPE_ResourceContainer(projFolderName,resourceTypeName,resourceType,-1,true,0,restype_superfolder);
    newResourceFolder->optionBox.x = barBox.x;
    subOptions.push_back(newResourceFolder);
    menuResized = true;
    return newResourceFolder;
}

GPE_ResourceContainer * GPE_ResourceManagementBar::add_project_folder(int resourceType, std::string projFolderName, std::string resourceTypeName)
{
    GPE_ResourceContainer * newResourceFolder = new GPE_ResourceContainer(projFolderName,resourceTypeName,resourceType,-1,true,0,restype_projfolder);
    newResourceFolder->optionBox.x = barBox.x;
    subOptions.push_back(newResourceFolder);
    menuResized = true;
    return newResourceFolder;
}

void GPE_ResourceManagementBar::delete_project_resources(std::string projectFileName)
{
    remove_project_resources( projectFileName);
}

bool GPE_ResourceManagementBar::is_visible()
{
    return isVisible;
}

void GPE_ResourceManagementBar::prerender_self(GPE_Renderer * cRender)
{
    GPE_ResourceContainer * tSubOption= NULL;
    for( int i = 0; i < (int)subOptions.size(); i++)
    {
        tSubOption = subOptions[i];
        if( tSubOption!=NULL)
        {
            tSubOption->prerender_self(cRender);
        }
    }
}

void GPE_ResourceManagementBar::process_managementbar()
{
    if( isVisible)
    {
        int sOpNumber = -1;
        justResized = false;

        bool mouseInRange = false;
        menuBox.x = barBox.x;
        menuBox.y = barBox.y+barTitleHeight;
        cameraBox.w = menuBox.w = barBox.w - yScroll->get_box_width();
        cameraBox.h = menuBox.h = barBox.y+barBox.h-menuBox.y;

        int xPos = 0;
        int yPos = 0;
        int y2Pos = yPos;
        if( barBox.w > SCREEN_WIDTH/2)
        {
            barBox.w = SCREEN_WIDTH/2;
            menuResized = justResized = true;
        }

        if( barBox.w < 32 && isVisible)
        {
            barBox.w = 32;
            menuResized = justResized = true;
        }
        if( point_between_rect(userInput->mouse_x,userInput->mouse_y, &menuBox) )
        {
            mouseInRange = true;
        }
        if( userInput->check_mouse_pressed(0) || userInput->check_mouse_pressed(1) || userInput->check_mouse_pressed(2) )
        {
            if( mouseInRange)
            {
                hasScrollControl = true;
                hasArrowkeyControl = true;
            }
            else
            {
                hasScrollControl = false;
                hasArrowkeyControl = false;
            }
        }
        //if( mouseInRange || menuResized || resourcebarMoved)
        {
            entireBox.x = 0;
            entireBox.y = 0;
            entireBox.w = 0;
            entireBox.h = RESOURCE_kb_AREA_HEIGHT*3;
            GPE_ResourceContainer * cContainer = NULL;
            for(int i=0; i<(int)subOptions.size();i++)
            {
                cContainer = subOptions[i];
                if(cContainer!=NULL)
                {
                    sOpNumber=cContainer->process_container(xPos,y2Pos,selectedSubOption,&menuBox,&cameraBox,mouseInRange);
                    if( sOpNumber>=0)
                    {
                        selectedSubOption = sOpNumber;
                    }
                    entireBox.h+=cContainer->optionBox.h;
                    y2Pos+=cContainer->optionBox.h;
                    if( cContainer->foundX2Pos > entireBox.w)
                    {
                        entireBox.w = cContainer->foundX2Pos;
                    }
                }
            }
        }
        showYScroll = true;
        //Xscroll code

        if( xScroll!=NULL && yScroll!=NULL)
        {
            xScroll->barBox.x = barBox.x;
            xScroll->barBox.y = barBox.y+barBox.h-16;
            if( RENDER_RESOURCEBAR_LEFT)
            {
                xScroll->barBox.w = barBox.w-20;
            }
            else
            {
                xScroll->barBox.w = barBox.w-16;
            }
            xScroll->barBox.h = 16;

            xScroll->fullRect.x = 0;
            xScroll->fullRect.y = 0;
            xScroll->fullRect.w = entireBox.w;
            xScroll->fullRect.h = entireBox.h;

            //if( hasScrollControl && userInput->check_keyboard_down(kb_ctrl) )
            if( mouseInRange && userInput->check_keyboard_down(kb_ctrl) )
            {
                if( userInput->mouseScrollingUp)
                {
                    cameraBox.x-=cameraBox.w/8;
                }
                else if( userInput->mouseScrollingDown)
                {
                    cameraBox.x+=cameraBox.w/8;
                }
            }

            xScroll->contextRect.x = cameraBox.x;
            xScroll->contextRect.y = cameraBox.y;
            xScroll->contextRect.w = cameraBox.w;
            xScroll->contextRect.h = cameraBox.h;

            if( hasScrollControl)
            {
                if( userInput->check_keyboard_down(kb_left) && !userInput->check_keyboard_pressed(kb_left) )
                {
                    leftDelayTime++;
                }
                else if( userInput->check_keyboard_down(kb_right)  && !userInput->check_keyboard_pressed(kb_right) )
                {
                    rightDelayTime++;
                }

                if( leftDelayTime > GPE_MAIN_GUI->textInputDelayTime || userInput->check_keyboard_pressed(kb_left) )
                {
                    xScroll->contextRect.x-=cameraBox.w/8;
                    leftDelayTime = 0;
                }
                else if( rightDelayTime > GPE_MAIN_GUI->textInputDelayTime || userInput->check_keyboard_pressed(kb_right) )
                {
                    xScroll->contextRect.x+=cameraBox.w/8;
                    rightDelayTime = 0;
                }
            }
            xScroll->process_self();
            if( xScroll->has_moved() || xScroll->is_scrolling() )
            {
                cameraBox.x = xScroll->contextRect.x;
                if( cameraBox.x +cameraBox.w > entireBox.w)
                {
                    cameraBox.x = entireBox.w - cameraBox.w;
                }
                if( cameraBox.x < 0)
                {
                    cameraBox.x = 0;
                }
                xScroll->process_self();
            }

            if( RENDER_RESOURCEBAR_LEFT)
            {
                yScroll->barBox.x = barBox.x+barBox.w-20;
            }
            else
            {
                yScroll->barBox.x = barBox.x+barBox.w-16;
            }
            yScroll->barBox.y = menuBox.y;
            yScroll->barBox.w = 16;
            yScroll->barBox.h = menuBox.h;

            yScroll->fullRect.x = 0;
            yScroll->fullRect.y = 0;
            yScroll->fullRect.w = entireBox.w,
            yScroll->fullRect.h = entireBox.h;
            yScroll->contextRect.x =camera.x;
            yScroll->contextRect.y = cameraBox.y;
            yScroll->contextRect.w = cameraBox.w,
            yScroll->contextRect.h = cameraBox.h;

            //if( hasScrollControl && userInput->check_keyboard_down(kb_ctrl)==false )
            if( mouseInRange && userInput->check_keyboard_down(kb_ctrl)==false )
            {
                if( userInput->mouseScrollingUp)
                {
                    yScroll->contextRect.y-=cameraBox.h/8;
                }
                else if( userInput->mouseScrollingDown)
                {
                    yScroll->contextRect.y+=cameraBox.h/8;
                }
            }

            if( hasScrollControl)
            {
                if( userInput->check_keyboard_down(kb_up) && !userInput->check_keyboard_pressed(kb_up) )
                {
                    upDelayTime++;
                }
                else if( userInput->check_keyboard_down(kb_down)  && !userInput->check_keyboard_pressed(kb_down) )
                {
                    downDelayTime++;
                }

                if( upDelayTime > GPE_MAIN_GUI->textInputDelayTime || userInput->check_keyboard_pressed(kb_up) )
                {
                    yScroll->contextRect.y-=cameraBox.h/8;
                    upDelayTime = 0;
                }
                else if( downDelayTime > GPE_MAIN_GUI->textInputDelayTime || userInput->check_keyboard_pressed(kb_down) )
                {
                    yScroll->contextRect.y+=cameraBox.h/8;
                    downDelayTime = 0;
                }
            }
            yScroll->process_self();
            //if( yScroll->has_moved() || yScroll->is_scrolling() || hasScrollControl)
            if( yScroll->has_moved() || yScroll->is_scrolling() || mouseInRange)
            {
                cameraBox.y = yScroll->contextRect.y;
                if( cameraBox.y +cameraBox.h> entireBox.h)
                {
                    cameraBox.y = entireBox.h - cameraBox.h;
                }
                if( cameraBox.y < 0)
                {
                    cameraBox.y = 0;
                }
                yScroll->process_self();
            }

            if( xScroll->is_scrolling()==false && xScroll->has_moved()==false  && yScroll->is_scrolling()==false && yScroll->has_moved()==false )
            {
                if( RENDER_RESOURCEBAR_LEFT)
                {
                    if( point_within(userInput->mouse_x,userInput->mouse_y,barBox.x+barBox.w-2,barBox.y,barBox.x+barBox.w+2,barBox.y+barBox.h) )
                    {
                        GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZEWE);
                        if(userInput->check_mouse_pressed(0) )
                        {
                            beingResized = true;
                        }
                    }
                }
                else if( point_within(userInput->mouse_x,userInput->mouse_y,barBox.x,barBox.y,barBox.x+4,barBox.y+barBox.h) )
                {
                    GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZEWE);
                    if(userInput->check_mouse_pressed(0) )
                    {
                        beingResized = true;
                    }
                }
            }
        }

        //resize_code
        if( beingResized)
        {
            if( point_between(userInput->mouse_x,userInput->mouse_y,0,barBox.y,SCREEN_WIDTH,barBox.y+barBox.h-8) )
            {
                seekedX2Pos = userInput->mouse_x;
                GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZEWE);
                if(userInput->check_mouse_released(0) )
                {
                    justResized = true;
                    beingResized = false;
                    if( RENDER_RESOURCEBAR_LEFT)
                    {
                        barBox.w = userInput->mouse_x;
                    }
                    else
                    {
                        barBox.w = SCREEN_WIDTH- userInput->mouse_x;
                    }
                    if( barBox.w > SCREEN_WIDTH/2)
                    {
                        barBox.w = SCREEN_WIDTH/2;
                    }

                    if( barBox.w < 32 && isVisible)
                    {
                        barBox.w = 32;
                    }
                    if( RENDER_RESOURCEBAR_LEFT)
                    {

                    }
                    else
                    {
                        GPE_Main_TabManager->set_width(SCREEN_WIDTH-barBox.w);
                    }
                    userInput->reset_all_input();
                    GPE_MAIN_GUI->save_settings();
                }
            }
            else
            {
                beingResized = false;
            }
        }
        menuResized = false;

        ///Processes if a previous right click was made and if so, make context menu
        if( RESOURCEMENU_WAS_RIGHTCLICKED && LAST_CLICKED_RESOURCE!=NULL)
        {
            RESOURCEMENU_WAS_RIGHTCLICKED = false;
            if( RENDER_RESOURCEBAR_LEFT)
            {
                GPE_open_context_menu();
            }
            else
            {
                GPE_open_context_menu(userInput->mouse_x-256,userInput->mouse_y);
            }
            MAIN_CONTEXT_MENU->set_width(256);
            if( !LAST_CLICKED_RESOURCE->is_folder() && !LAST_CLICKED_RESOURCE->is_super_project_folder() && !LAST_CLICKED_RESOURCE->is_super_project_folder() )
            {
                int tempResType= LAST_CLICKED_RESOURCE->get_resource_type() ;
                if( tempResType!=RESOURCE_TYPE_TEXTURE && tempResType!=RESOURCE_TYPE_TILESHEET && tempResType!=RESOURCE_TYPE_SPRITE && tempResType!=RESOURCE_TYPE_AUDIO && tempResType!=RESOURCE_TYPE_VIDEO && tempResType!=RESOURCE_TYPE_PROJECT_SETTINGS )
                {
                    MAIN_CONTEXT_MENU->add_menu_option("Duplicate Resource",-1,NULL,-1,NULL,false,true);
                }
                MAIN_CONTEXT_MENU->add_menu_option("Rename Resource",-1,NULL,-1,NULL,false,true);
                MAIN_CONTEXT_MENU->add_menu_option("Remove Resource",-1,NULL,-1,NULL,false,true);
                MAIN_CONTEXT_MENU->add_menu_option("Resource Properties",-1,NULL,-1,NULL,true,true);
            }
            else if(LAST_CLICKED_RESOURCE->is_super_project_folder() )
            {
                MAIN_CONTEXT_MENU->add_menu_option("Save Project",-1,NULL,-1,NULL,false,true);
                MAIN_CONTEXT_MENU->add_menu_option("Close Project",-1,NULL,-1,NULL,true,true);

                MAIN_CONTEXT_MENU->add_menu_option("Build Project",-1,NULL,-1,NULL,false,true);
                //MAIN_CONTEXT_MENU->add_menu_option("Debug Project",-1,NULL,-1,NULL,false,true);
                GPE_PopUpMenu_Option *cleanFolderOptions =  MAIN_CONTEXT_MENU->add_menu_option("Clean Project",-1,NULL,-1,NULL,true,false);
                cleanFolderOptions->add_menu_option("Clean [HTML5] Build Folder",-1);
                if( GPE_MAIN_GUI->includeNintendoWiiUExport )
                cleanFolderOptions->add_menu_option("Clean [WiiU] Build Folder",-1);
                cleanFolderOptions->add_menu_option("Clean [Windows] Build Folder",-1);
                cleanFolderOptions->add_menu_option("Clean [Linux] Build Folder",-1);
                cleanFolderOptions->add_menu_option("Clean [OSX] Build Folder",-1);
                cleanFolderOptions = MAIN_CONTEXT_MENU->add_menu_option("Open Project Directory");
                MAIN_CONTEXT_MENU->add_menu_option("Find Resource...");

                //MAIN_CONTEXT_MENU->add_menu_option("Browse Directory",-1,-1,NULL,false,true);
            }
            else if(LAST_CLICKED_RESOURCE->is_super_folder() || LAST_CLICKED_RESOURCE->is_folder() )
            {
                MAIN_CONTEXT_MENU->add_menu_option("Add Resource",-1,NULL,-1,NULL,false,true);
                MAIN_CONTEXT_MENU->add_menu_option("Add Folder",-1,NULL,-1,NULL,true,true);
                if( !LAST_CLICKED_RESOURCE->is_super_folder())
                {
                    MAIN_CONTEXT_MENU->add_menu_option("Rename Folder",-1,NULL,-1,NULL,true,true);
                }
                MAIN_CONTEXT_MENU->add_menu_option("Sort by Name",-1,NULL,-1,NULL,true,true);
                if( !LAST_CLICKED_RESOURCE->is_super_folder())
                {
                    MAIN_CONTEXT_MENU->add_menu_option("Remove Folder",-1,NULL,-1,NULL,false,true);
                }
                MAIN_CONTEXT_MENU->add_menu_option("Find Resource...");
            }
            else if( LAST_CLICKED_RESOURCE->is_folder()==false)
            {
                int tempResType= LAST_CLICKED_RESOURCE->get_resource_type() ;
                if( tempResType!=RESOURCE_TYPE_TEXTURE && tempResType!=RESOURCE_TYPE_TILESHEET && tempResType!=RESOURCE_TYPE_SPRITE && tempResType!=RESOURCE_TYPE_AUDIO && tempResType!=RESOURCE_TYPE_VIDEO && tempResType!=RESOURCE_TYPE_PROJECT_SETTINGS )
                {
                    MAIN_CONTEXT_MENU->add_menu_option("Duplicate Resource",-1,NULL,-1,NULL,false,true);
                }
                MAIN_CONTEXT_MENU->add_menu_option("Rename Resource",-1,NULL,-1,NULL,false,true);
                MAIN_CONTEXT_MENU->add_menu_option("Delete Resource",-1,NULL,-1,NULL,false,true);
                MAIN_CONTEXT_MENU->add_menu_option("Properties",-1,NULL,-1,NULL,false,true);
            }
            get_popupmenu_result();
        }
        else if( userInput->check_mouse_released(0) &&  RESOURCE_TO_DRAG!=NULL )
        {
            if( LAST_CLICKED_RESOURCE!=NULL)
            {
                if( LAST_CLICKED_RESOURCE->is_super_folder() || LAST_CLICKED_RESOURCE->is_folder() )
                {
                    if( RESOURCE_TO_DRAG->parentResource!=NULL && LAST_CLICKED_RESOURCE->can_obtain(RESOURCE_TO_DRAG) )
                    {
                        RESOURCE_TO_DRAG->parentResource->remove_resource(RESOURCE_TO_DRAG,false);
                        LAST_CLICKED_RESOURCE->add_resource_container(RESOURCE_TO_DRAG);
                        userInput->reset_all_input();
                        GPE_MAIN_GUI->mainResourceBar->selectedSubOption = RESOURCE_TO_DRAG->get_global_id();
                        RESOURCE_TO_DRAG = NULL;
                        LAST_CLICKED_RESOURCE = NULL;
                        process_managementbar();
                    }
                }
                else if( RESOURCE_TO_DRAG->parentResource!=NULL && LAST_CLICKED_RESOURCE->parentResource!=NULL && LAST_CLICKED_RESOURCE->parentResource->can_obtain(RESOURCE_TO_DRAG) )
                {
                    if( RESOURCE_TO_DRAG->matches(LAST_CLICKED_RESOURCE)!=1  &&  RESOURCE_TO_DRAG->matches(LAST_CLICKED_RESOURCE->parentResource)!=1  )
                    {
                        GPE_ResourceContainer * previousParentResource = RESOURCE_TO_DRAG->parentResource;
                        RESOURCE_TO_DRAG->parentResource->remove_resource(RESOURCE_TO_DRAG, false);
                        record_error("Trying to copy ["+RESOURCE_TO_DRAG->get_name()+"] resource.");
                        record_error("Trying to copy to ["+LAST_CLICKED_RESOURCE->get_name()+"]'s parent resource.");
                        record_error("Trying to copy to ["+LAST_CLICKED_RESOURCE->parentResource->get_name()+"]'s resource.");
                        LAST_CLICKED_RESOURCE->parentResource->add_resource_container(RESOURCE_TO_DRAG,false,LAST_CLICKED_RESOURCE);
                        GPE_MAIN_GUI->mainResourceBar->selectedSubOption = RESOURCE_TO_DRAG->get_global_id();
                        userInput->reset_all_input();
                        RESOURCE_TO_DRAG = NULL;
                        LAST_CLICKED_RESOURCE = NULL;
                        process_managementbar();
                    }
                }
                LAST_CLICKED_RESOURCE= NULL;
            }
        }
    }
}

void GPE_ResourceManagementBar::render_resourcebar(GPE_Renderer * cRender, SDL_Rect *cam,bool forceRedraw)
{
    if( resourcebarMoved)
    {
        forceRedraw = true;
    }
    if( isVisible && forceRedraw)
    {
        if( cRender==NULL)
        {
            cRender = MAIN_RENDERER;
        }
        SDL_RenderSetViewport( cRender->get_renderer(), &menuBox );
        render_rectangle(cRender,0,0,barBox.w,barBox.h,GPE_MAIN_TEMPLATE->Program_Color,false);
        GPE_ResourceContainer * cResource;
        int xDrawPos = 0;
        int yDrawPos = 0;
        for(int i=0; i<(int)subOptions.size();i+=1)
        {
            cResource = subOptions[i];
            if(cResource!=NULL)
            {
                cResource->render_option(cRender,xDrawPos,yDrawPos,selectedSubOption,&menuBox,&cameraBox);
                yDrawPos+=cResource->optionBox.h;
            }
        }
        SDL_RenderSetViewport( cRender->get_renderer(),NULL );
        SDL_RenderSetViewport( cRender->get_renderer(),&barBox );
        render_rectangle(cRender,0,0,barBox.w,barTitleHeight,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);
        render_new_text( MAIN_RENDERER,GENERAL_GPE_PADDING,barTitleHeight/2,"Project Resources",GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_MIDDLE);

        SDL_RenderSetViewport( cRender->get_renderer(),NULL );


        if( xScroll!=NULL)
        {
            xScroll->render_self(cRender);
        }
        if( yScroll!=NULL)
        {
            yScroll->render_self(cRender);
            //if( RENDER_RESOURCEBAR_LEFT)
            {
                //render_rectangle(cRender,yScroll->barBox.x+yScroll->barBox.w,yScroll->barBox.y,barBox.x+barBox.w,barBox.h,barColor,false);
            }
        }

        if( hasScrollControl)
        {
            render_rectangle(cRender,barBox.x,menuBox.y,barBox.x+barBox.w,barBox.y+barBox.h,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,true);
        }
        else
        {
            render_rect(cRender,&barBox,GPE_MAIN_TEMPLATE->Text_Box_Outline_Color,true);
        }

        if( beingResized)
        {
            if( RENDER_RESOURCEBAR_LEFT)
            {
                if( seekedX2Pos > SCREEN_WIDTH/2 )
                {
                    render_rectangle(cRender,seekedX2Pos-2,barBox.y,seekedX2Pos+2,barBox.y+barBox.h,GPE_MAIN_TEMPLATE->Input_Error_Box_Color,false);
                }
                else
                {
                    render_rectangle(cRender,seekedX2Pos-2,barBox.y,seekedX2Pos+2,barBox.y+barBox.h,GPE_MAIN_TEMPLATE->Input_Outline_Color,false);
                }
            }
            else if( seekedX2Pos < SCREEN_WIDTH/2 )
            {
                render_rectangle(cRender,seekedX2Pos-2,barBox.y,seekedX2Pos+2,barBox.y+barBox.h,GPE_MAIN_TEMPLATE->Input_Error_Box_Color,false);
            }
            else
            {
                render_rectangle(cRender,seekedX2Pos-2,barBox.y,seekedX2Pos+2,barBox.y+barBox.h,GPE_MAIN_TEMPLATE->Input_Outline_Color,false);
            }
        }
    }
}

void GPE_ResourceManagementBar::remove_project_resources(std::string projectFileName)
{
    if( (int)projectFileName.size()>0 )
    {
        GPE_ResourceContainer * tContainer = NULL;
        for( int i = (int)subOptions.size()-1; i>=0; i--)
        {
            tContainer = subOptions[i];
            if( tContainer!=NULL )
            {
                if( projectFileName.compare(tContainer->projectParentFileName )==0)
                {
                    subOptions.erase(subOptions.begin()+i);
                }
            }
        }
        menuResized = true;
    }
}

void GPE_ResourceManagementBar::toggle_self()
{
    if( isVisible)
    {
        isVisible = false;
        //lastWidth = barBox.w;
        //barBox.w = 0;
    }
    else
    {
        //barBox.w = lastWidth;
        isVisible = true;
        menuResized = true;
    }
    //MAIN_RENDERER->clear_renderer();
}

GPE_Compiler_Term::GPE_Compiler_Term()
{
    termString = "";
    //termParameters = "";
    termDescription = "";
    termFunctionReturnType = "";
    termType = -1;
    termParametersString = "";
    termScope = "";
}

GPE_Compiler_Term::GPE_Compiler_Term(std::string tName,std::string tParameters, std::string tFunctionReturnType, std::string tDescription,int tType, std::string tScope)
{
    termScope = tScope;
    termString = tName;
    //termParameters = tParameters;
    termDescription = tDescription;
    termType = tType;
    termFunctionReturnType = tFunctionReturnType;
    termParametersString = tParameters;
    if( (int)tParameters.size() > 0 )
    {
        int commaPos = tParameters.find_first_of(",");
        std::string valString = "";
        while( commaPos!=(int)std::string::npos )
        {
            commaPos=tParameters.find_first_of(",");
            valString = split_first_string(tParameters,',');
            termParameters.push_back(valString);
        }
        termParameters.push_back( tParameters );
    }
}

GPE_Compiler_Term::~GPE_Compiler_Term()
{

}

std::string GPE_Compiler_Term::get_parameters()
{
    return termParametersString;
}

GPE_Gui_Engine_Language::GPE_Gui_Engine_Language(std::string langName, std::string langShortName, bool projectCodeLanguage,bool useDefaultSymbols)
{
    languageName = langName;
    languageShortName = langShortName;
    isCodingLanguage = projectCodeLanguage;
    if( useDefaultSymbols )
    {
        symbolLibrary.push_back('`');
        symbolLibrary.push_back('~');
        symbolLibrary.push_back('!');
        symbolLibrary.push_back('@');
        symbolLibrary.push_back('#');
        symbolLibrary.push_back('$');
        symbolLibrary.push_back('%');
        symbolLibrary.push_back('^');
        symbolLibrary.push_back('&');
        symbolLibrary.push_back('*');
        symbolLibrary.push_back('(');
        symbolLibrary.push_back(')');
        symbolLibrary.push_back('-');
        symbolLibrary.push_back('_');
        symbolLibrary.push_back('=');
        symbolLibrary.push_back('+');
        symbolLibrary.push_back('\\');
        symbolLibrary.push_back('|');
        symbolLibrary.push_back(';');
        symbolLibrary.push_back(';');
        symbolLibrary.push_back(',');
        symbolLibrary.push_back('<');
        symbolLibrary.push_back('.');
        symbolLibrary.push_back('>');
        symbolLibrary.push_back('/');
        symbolLibrary.push_back('?');
    }
}

GPE_Gui_Engine_Language::~GPE_Gui_Engine_Language()
{

}


bool GPE_Gui_Engine_Language::add_language_variable(std::string nName, std::string nDescription,std::string  nScopre)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)languageVariables.size()-1; i>=0; i--)
    {
        tTerm = languageVariables[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==nName)
            {
                return false;
            }
        }
    }
    tTerm = new GPE_Compiler_Term(nName, "", "", nDescription, -1, nScopre);
    languageVariables.push_back( tTerm);
    return true;
}

bool GPE_Gui_Engine_Language::add_language_constant(std::string nName, std::string nDescription,std::string  nParameters)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)languageConstants.size()-1; i>=0; i--)
    {
        tTerm = languageConstants[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==nName)
            {
                return false;
            }
        }
    }
    tTerm = new GPE_Compiler_Term(nName, nParameters, "", nDescription, -1);
    languageConstants.push_back( tTerm);
    return true;
}

bool GPE_Gui_Engine_Language::add_language_function(std::string nName, std::string nDescription,std::string  nParameters, std::string tFunctionReturnType, std::string nScope)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)languageFunctions.size()-1; i>=0; i--)
    {
        tTerm = languageFunctions[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==nName)
            {
                return false;
            }
        }
    }
    if( (int)tFunctionReturnType.size()==0)
    {
        tFunctionReturnType = "void";
    }
    tTerm = new GPE_Compiler_Term(nName, nParameters, tFunctionReturnType,nDescription, CTERM_FUNCTION,nScope );
    languageFunctions.push_back( tTerm);
    return true;
}

bool GPE_Gui_Engine_Language::add_language_class(std::string nName, std::string nDescription,std::string  nParameters)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)languageClasses.size()-1; i>=0; i--)
    {
        tTerm = languageClasses[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==nName)
            {
                return false;
            }
        }
    }
    tTerm = new GPE_Compiler_Term(nName, nParameters, "", nDescription, -1);
    languageClasses.push_back( tTerm);
    return true;
}

bool GPE_Gui_Engine_Language::add_language_keyword(std::string nName, std::string nDescription,std::string  nScope)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)languageKeywords.size()-1; i>=0; i--)
    {
        tTerm = languageKeywords[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==nName)
            {
                return false;
            }
        }
    }
    tTerm = new GPE_Compiler_Term(nName, "", "",nDescription,-1,nScope);
    languageKeywords.push_back( tTerm);
    return true;
}

bool GPE_Gui_Engine_Language::charIsSymbol(char  charIn)
{
    for( int i = 0; i < (int)symbolLibrary.size(); i++)
    {
        if( charIn==symbolLibrary[i])
        {
            return true;
        }
    }
    return false;
}


int GPE_Gui_Engine_Language::firstSymbolInString(std::string inString, int pos)
{
    int returnVal = -1;

    int maxLoop = symbolLibrary.size();
    for(int i=0;i<maxLoop;i+=1)
    {
        int symPos = inString.find(symbolLibrary[i],pos);
        if(symPos!=-1)
        {
            if(returnVal==-1)
            {
                returnVal = symPos;
            }
            else if(symPos<returnVal)
            {
                returnVal = symPos;
            }
        }
    }

    return returnVal;
}

bool GPE_Gui_Engine_Language::is_compilable_word(std::string strIn)
{
    int i = 0;
    GPE_Compiler_Term * tTerm = NULL;
    for( i = (int)languageKeywords.size()-1; i>=0; i--)
    {
        tTerm = languageKeywords[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==strIn)
            {
                return false;
            }
        }
    }

    for( i = (int)languageVariables.size()-1; i>=0; i--)
    {
        tTerm = languageVariables[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==strIn)
            {
                return false;
            }
        }
    }

    for( i = (int)languageClasses.size()-1; i>=0; i--)
    {
        tTerm = languageClasses[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==strIn)
            {
                return false;
            }
        }
    }

    for( i = (int)languageDataTypes.size()-1; i>=0; i--)
    {
        tTerm = languageDataTypes[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==strIn)
            {
                return false;
            }
        }
    }
    return true;
}

bool GPE_Gui_Engine_Language::add_language_data_type(std::string nName, std::string nDescription,std::string  nParameters)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)languageDataTypes.size()-1; i>=0; i--)
    {
        tTerm = languageDataTypes[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString==nName)
            {
                return false;
            }
        }
    }
    tTerm = new GPE_Compiler_Term(nName, nParameters, "", nDescription, -1);
    languageDataTypes.push_back( tTerm);
    return true;
}

std::string GPE_Gui_Engine_Language::find_gpe_datatype(std::string strBeingChecked, int startPos)
{
    GPE_Compiler_Term * tTerm = NULL;
    int strSize = (int)strBeingChecked.size();
    if( strSize>0 && strSize > startPos)
    {
        std::string strToSearch = "";
        int tempStrSize = 0;
        int j = 0;
        bool allMatched = false;
        for( int i = (int)languageDataTypes.size()-1; i>0; i--)
        {
            tTerm= languageDataTypes[i];
            if( tTerm!=NULL)
            {
                strToSearch = tTerm->termString;
                tempStrSize = strToSearch.size();
                if(strSize >=  startPos+tempStrSize && tempStrSize>0)
                {
                    allMatched = true;
                    for( j = 0; j < tempStrSize; j++)
                    {
                        if(strBeingChecked[startPos+j]!=strToSearch[j])
                        {
                            allMatched = false;
                        }
                    }
                    if( allMatched ==true)
                    {
                        if( strSize > startPos+tempStrSize)
                        {
                            //if( char_is_alnum(strBeingChecked[startPos+tempStrSize],false,true)==false )
                            {
                                return strToSearch;
                            }
                        }
                        else
                        {
                            return strToSearch;
                        }
                    }
                }
            }
        }
    }
    return "";
}

std::string GPE_Gui_Engine_Language::find_gpe_function(std::string strBeingChecked, int startPos)
{
    GPE_Compiler_Term * tTerm = NULL;
    int strSize = (int)strBeingChecked.size();
    if( strSize>0 && strSize > startPos)
    {
        std::string strToSearch = "";
        int tempStrSize = 0;
        int j = 0;
        bool allMatched = false;
        for( int i = (int)languageFunctions.size()-1; i>=0; i--)
        {
            tTerm= languageFunctions[i];
            if( tTerm!=NULL)
            {
                strToSearch = tTerm->termString;
                tempStrSize = strToSearch.size();
                if(strSize >=  startPos+tempStrSize && tempStrSize>0)
                {
                    allMatched = true;
                    for( j = 0; j < tempStrSize; j++)
                    {
                        if(strBeingChecked[startPos+j]!=strToSearch[j])
                        {
                            allMatched = false;
                        }
                    }
                    if( allMatched ==true)
                    {
                        if( strSize > startPos+tempStrSize)
                        {
                            if( char_is_alnum(strBeingChecked[startPos+tempStrSize],false,true)==false )
                            {
                                return strToSearch;
                            }
                        }
                        else
                        {
                            return strToSearch;
                        }
                    }
                }
            }
        }
    }
    return "";
}

std::string GPE_Gui_Engine_Language::find_gpe_keyword(std::string strBeingChecked, int startPos)
{
    GPE_Compiler_Term * tTerm = NULL;
    int strSize = (int)strBeingChecked.size();
    if( strSize>0 && strSize > startPos)
    {
        std::string strToSearch = "";
        int tempStrSize = 0;
        int j = 0;
        bool allMatched = false;
        for( int i = (int)languageKeywords.size()-1; i>=0; i--)
        {
            tTerm= languageKeywords[i];
            if( tTerm!=NULL)
            {
                strToSearch = tTerm->termString;

                tempStrSize = strToSearch.size();
                if(strSize >=  startPos+tempStrSize && tempStrSize>0)
                {
                    allMatched = true;
                    for( j = 0; j < tempStrSize; j++)
                    {
                        if(strBeingChecked[startPos+j]!=strToSearch[j])
                        {
                            allMatched = false;
                        }
                    }
                    if( allMatched ==true)
                    {
                        if( strSize >= startPos+tempStrSize)
                        {
                            if( char_is_alnum(strBeingChecked[startPos+tempStrSize],false,true)==false )
                            {
                                return strToSearch;
                            }
                        }
                        else
                        {
                            return strToSearch;
                        }
                    }
                }
            }
        }
    }
    return "";
}

std::string GPE_Gui_Engine_Language::find_gpe_variable(std::string strBeingChecked, int startPos)
{
    GPE_Compiler_Term * tTerm = NULL;
    int strSize = (int)strBeingChecked.size();
    if( strSize>0 && strSize > startPos)
    {
        std::string strToSearch = "";
        int tempStrSize = 0;
        int j = 0;
        bool allMatched = false;
        for( int i = (int)languageVariables.size()-1; i>=0; i--)
        {
            tTerm= languageVariables[i];
            if( tTerm!=NULL)
            {
                strToSearch = tTerm->termString;

                tempStrSize = strToSearch.size();
                if(strSize >=  startPos+tempStrSize && tempStrSize>0)
                {
                    allMatched = true;
                    for( j = 0; j < tempStrSize; j++)
                    {
                        if(strBeingChecked[startPos+j]!=strToSearch[j])
                        {
                            allMatched = false;
                        }
                    }
                    if( allMatched ==true)
                    {
                        if( strSize >= startPos+tempStrSize)
                        {
                            if( char_is_alnum(strBeingChecked[startPos+tempStrSize],false,true)==false )
                            {
                                return strToSearch;
                            }
                        }
                        else
                        {
                            return strToSearch;
                        }
                    }
                }
            }
        }
    }
    return "";
}

GPE_Compiler_Term * GPE_Gui_Engine_Language::find_matching_variable(std::string nameIn)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)languageVariables.size()-1; i>=0; i--)
    {
        tTerm= languageVariables[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString == nameIn )
            {
                return tTerm;
            }
        }
    }
    return NULL;

}

GPE_Compiler_Term * GPE_Gui_Engine_Language::find_matching_function(std::string nameIn)
{
    GPE_Compiler_Term * tTerm = NULL;
    for( int i = (int)languageFunctions.size()-1; i>=0; i--)
    {
        tTerm= languageFunctions[i];
        if( tTerm!=NULL)
        {
            if( tTerm->termString == nameIn )
            {
                return tTerm;
            }
        }
    }
    return NULL;
}
GPE_Gui_Engine_MiniCompiler::GPE_Gui_Engine_MiniCompiler()
{
    newParametersString = "";
    parametersAreValid = false;

    GPE_Gui_Engine_Language * JSLang = defaultLanguage = add_programming_language("JavaScript","JS",true,true,true);
    //JS constants
    JSLang->add_language_constant("IS_NULL");
    JSLang->add_language_constant("GPE_SETTINGS_ENTRY_LEVEL_LOCATION");
    JSLang->add_language_constant("pi");
    JSLang->add_language_constant("PI");

    //JS classes
    JSLang->add_language_class("activeObject");
    JSLang->add_language_class("GPE_String");
    JSLang->add_language_class("SuperVector");
    JSLang->add_language_class("window");
    JSLang->add_language_class("GPE_JSFile");
    JSLang->add_language_class("GPE_FileReader");
    JSLang->add_language_class("GPE_InputManager_GameController");
    JSLang->add_language_class("GPE_InputManager");
    JSLang->add_language_class("GPE_LogoDisplay");
    JSLang->add_language_class("GPE_MainGame");
    JSLang->add_language_class("GPE_GameScene");
    JSLang->add_language_class("ResourceController");
    JSLang->add_language_class("GPE_ResourceLoader");
    JSLang->add_language_class("GPE_MainMenuOption");
    JSLang->add_language_class("GPE_MainMenu");
    JSLang->add_language_class("GPE_GameController");
    JSLang->add_language_class("GPE_Rect");
    JSLang->add_language_class("GPE_GameSprite");
    JSLang->add_language_class("GPE_Tilesheet");
    JSLang->add_language_class("GPE_Texture");
    JSLang->add_language_class("GPE_Background");
    JSLang->add_language_class("GPE_GameMapTile");
    JSLang->add_language_class("GPE_TileLayer");
    JSLang->add_language_class("GPE_LevelView");
    JSLang->add_language_class("GPE_GameScene");

    /* JS Functions */
    //Audio functions
    JSLang->add_language_function("audio_loop","Loops audio whose id is audioId","audioId","void","gpe");
    JSLang->add_language_function("audio_pause","Pauses audio whose id is audioId","audioId","void","gpe");
    JSLang->add_language_function("audio_pause_all","Pauses all audio from playing","","void","gpe");
    JSLang->add_language_function("audio_pause_group","Pauses all audio whose group-id is groupId","groupId","void","gpe");

    JSLang->add_language_function("audio_playing","Checks if audio whose id is audioId is playing","audioId","bool","gpe");
    JSLang->add_language_function("audio_play","Plays audio whose id is audioId","audioId","void","gpe");
    JSLang->add_language_function("audio_stop_all","Stops all audio from playing","","void","gpe");
    JSLang->add_language_function("audio_stop_group","Stops all audio whose group-id is groupId","groupId","void","gpe");
    JSLang->add_language_function("audio_stop","Stops audio whose id is audioId","audioId","void","gpe");
    //math / collision functions
    JSLang->add_language_function("abs","Returns 0 or a positive number","x","double","gpe");
    JSLang->add_language_function("add_object","Returns a new object on the same layer as the current object","objectType, x, y","gameObject","GameObject");
    JSLang->add_language_function("add_new_object","Returns a new object","objectType, x, y, objectLayerId","gameObject","gpe");
    JSLang->add_language_function("bound_number","Bounds x between min and max","minN, maxN","double","gpe");
    JSLang->add_language_function("camera_on","Returns true or false if the camera is on or -1 if the camera is invalid","camId","int","gpe");
    JSLang->add_language_function("center_camera","Centers camera at (x,y)","(camId, x,y","void","gpe");
    JSLang->add_language_function("check_collision_rect","Checks if two rectangles collide","rectA, rectB","bool","gpe");
    JSLang->add_language_function("check_collision_with_rect","Checks if a rectangle collides with a box","boxX, boxY, boxW, boxH, rectA","bool","gpe");
    JSLang->add_language_function("degree","Converts an angle in radians to degrees","x","float","gpe");
    JSLang->add_language_function("radian","Converts an angle in degrees to radians","x","float","gpe");
    JSLang->add_language_function("sign","Gets the sign of the variable","x","int","gpe");
    //input functions

    JSLang->add_language_function("gamepad_connected","Checks if the gamepad is conected","controllerPos","bool","gpe");
    JSLang->add_language_function("gamepad_name","Returns the gamepad's name","controllerPos,","string","gpe");
    JSLang->add_language_function("gamepad_object","Returns the gamepad object","controllerPos,","GPE_GamePad","gpe");
    JSLang->add_language_function("gamepad_mapping","Returns the gamepad's mapping","controllerPos","string","gpe");
    JSLang->add_language_function("check_gamepad","Checks if the gamepad's button is down","controllerPos, buttonId","int","gpe");
    JSLang->add_language_function("check_gamepad_down","Checks if the gamepad's buttonId is down","controllerPos, buttonId","int","gpe");
    JSLang->add_language_function("check_gamepad_pressed","Checks if the gamepad's buttonId was pressed","controllerPos, buttonId","int","gpe");
    JSLang->add_language_function("check_gamepad_released","Checks if the gamepad's buttonId was released","controllerPos, buttonId","int","gpe");

    JSLang->add_language_function("check_keyboard_down","Checks if the keyboard button is down","keyId","bool","gpe");
    JSLang->add_language_function("check_keyboard_pressed","Checks if the keyboard button was pressed","keyId","bool","gpe");
    JSLang->add_language_function("check_keyboard_released","Checks if the keyboard button was released","keyId","bool","gpe");
    JSLang->add_language_function("check_keyboard","Checks if the keyboard button is down","keyId","bool","gpe");

    JSLang->add_language_function("check_mouse_down","Checks if the mouse button is down","buttonId","bool","gpe");
    JSLang->add_language_function("check_mouse_pressed","Checks if the mouse button is down","buttonId","bool","gpe");
    JSLang->add_language_function("check_mouse_released","Checks if the mouse button is down","buttonId","bool","gpe");
    JSLang->add_language_function("check_mouse","Checks if the keyboard mouse is down","buttonId","bool","gpe");
    // JS processing functions
    JSLang->add_language_function("disable_camera","Disables a camera","cameraId","void","gpe");
    JSLang->add_language_function("disable_canvas","Disables a canvas","canvasId","void","gpe");
    JSLang->add_language_function("disable_outofsightmode","Disables optimized sight mode","","void","gpe");
    JSLang->add_language_function("enable_outofsightmode","Enables optimized sight mode","","void","gpe");
    JSLang->add_language_function("enable_camera","Enables a camera","cameraId","void","gpe");
    JSLang->add_language_function("enable_canvas","Disables a canvas","canvasId","void","gpe");
    JSLang->add_language_function("equals","Checks if this object equals otherObject","otherObject","bool","gpe");
    JSLang->add_language_function("erase_data","Erases data pack","dataIdentifier, dataTitle","void","gpe");
    JSLang->add_language_function("exit_video_view_mode","Ends current video playing","","void","gpe");

    JSLang->add_language_function("find_tile","Checks for the tileset of tile at (x,y)","layerToCheck, xPos, yPosk","int","gpe");
    JSLang->add_language_function("find_tile_in_box","Checks if tile is located in box","layerToCheck, x1,  y1,  x2, y2, layerIdToCheck","int","gpe");
    JSLang->add_language_function("find_matching_tile","Checks if tile with MATCHING tileset exists at (x,y)","layerToCheck,  xPos,  yPos,  tileTypeToSearchFor","bool","gpe");
    JSLang->add_language_function("find_matching_tile_in_box","Checks if tile with MATCHING tileset exist in box","layerToCheck,  x1,  y1,  x2, y2,  tileTypeToSearchFor","bool","gpe");

    JSLang->add_language_function("find_furthest_object","Finds the furthest object away from (x,y)","theObjectType, xIn, yIn, avoidObjId, layerIdToCheck","GameObject","gpe");
    JSLang->add_language_function("find_nearest_object","Finds the nearest object away from (x,y)","theObjectType, xIn, yIn, avoidObjId, layerIdToCheck","GameObject","gpe");
    JSLang->add_language_function("get_camera_height","Get the height of the camera","cameraId","int","gpe");
    JSLang->add_language_function("get_camera_info","Get the height of the camera","cameraId","CameraData","gpe");
    JSLang->add_language_function("get_camera_width","Get the height of the camera","cameraId","int","gpe");
    JSLang->add_language_function("get_camera_x","Get the height of the camera","cameraId","int","gpe");
    JSLang->add_language_function("get_camera_y","Get the height of the camera","cameraId","int","gpe");
    JSLang->add_language_function("get_camera_screen_height","Get the height of the camera on screen","cameraId","int","gpe");
    JSLang->add_language_function("get_camera_screen_width","Get the height of the camera on screen","cameraId","int","gpe");
    JSLang->add_language_function("get_camera_screen_x","Get the height of the camera on screen","cameraId","int","gpe");
    JSLang->add_language_function("get_camera_screen_y","Get the height of the camera on screen","cameraId","int","gpe");
    JSLang->add_language_function("get_current_camera","Gets the id of the current camera being shown","","int","gpe");
    JSLang->add_language_function("get_current_camera_info","Get an object containing information of the camera","","CameraData","gpe");
    JSLang->add_language_function("get_background","Gets the background texture id","bgId","int","gpe");
    JSLang->add_language_function("get_direction","Returns the direction from (x1,y1) and (x2,y2)","x1, y1, x2, y2","int","gpe");
    JSLang->add_language_function("get_distance","Returns the distance between (x1,y1) and (x2,y2)","x1, y1, x2, y2","int","gpe");
    JSLang->add_language_function("get_mouse_x","Gets the global mouse x-position","","double","gpe");
    JSLang->add_language_function("get_mouse_y","Gets the global mouse y-position","","double","gpe");
    JSLang->add_language_function("load_data","Loads data pack","dataIdentifier, dataTitle","string","gpe");
    JSLang->add_language_function("move_camera","Moves camera to (x,y)","(camId, x,y","void","gpe");
    JSLang->add_language_function("setup_camera","Moves camera to (x,y) with sizing (w,h)","camId, x,y, w, h","void","gpe");
    JSLang->add_language_function("split_screen","Splits the scren up to 8 cameras","screenTotal, verticallySplit, useBlanks","bool","gpe");

    JSLang->add_language_function("font_is_monospaced","Checks if the font assigned to fontId is monospaced. Returns a blank string if out of bounds.","fontId","String","gpe");
    JSLang->add_language_function("get_font_family","Get the FamilyName of the font assigned to fontId. Returns a blank string if out of bounds.","fontId","String","gpe");
    JSLang->add_language_function("get_font_height","Get the estimated height of the font assigned to fontId. Returns a blank string if out of bounds.","fontId,words","String","gpe");
    JSLang->add_language_function("get_font_size","Get the size(pt) of the font assigned to fontId. Returns a blank string if out of bounds.","fontId","String","gpe");
    JSLang->add_language_function("get_font_width","Get the estimated width of the font assigned to fontId. Returns a blank string if out of bounds.","fontId,words","String","gpe");

    JSLang->add_language_function("get_sprite_width","Get the width of the sprite assigned to spriteId. Returns 0 if out of bounds.","spriteId","int","gpe");
    JSLang->add_language_function("get_sprite_height","Get the height of the sprite assigned to spriteId. Returns 0 if out of bounds","spriteId","int","gpe");
    JSLang->add_language_function("get_sprite_length","Get the length of the sprite assigned to spriteId. Returns 0 if out of bounds","spriteId","int","gpe");
    JSLang->add_language_function("get_sprite_object","Gets the actual sprite object attached to spriteId. Returns IS_NULL if out of bounds","spriteId","GameSprite","gpe");

    JSLang->add_language_function("get_texture_width","Get the width of the texture assigned to textureId. Returns 0 if out of bounds.","textureId","int","gpe");
    JSLang->add_language_function("get_texture_height","Get the height of the texture assigned to textureId. Returns 0 if out of bounds","textureId","int","gpe");
    JSLang->add_language_function("get_texture_object","Get the HTML5 Image of the texture assigned to textureId. Returns 0 if out of bounds","textureId","Image","gpe");

    JSLang->add_language_function("disable_camera","Disables a camera","cameraId","void","gpe");

    JSLang->add_language_function("game_reset","Resets the game game","","void","gpe");
    JSLang->add_language_function("get_camera_mouse_x","Gets the camera relative mouse x-position","cameraId","int","gpe");
    JSLang->add_language_function("get_camera_mouse_y","Gets the camera relative mouse y-position","cameraId","int","gpe");
    JSLang->add_language_function("get_fps","Returns frame rate","","int","gpe");
    JSLang->add_language_function("get_object_count","Returns the amount of objects within the scene","objectType","int","gpe");
    JSLang->add_language_function("get_object_count_all","Returns the amount of objects belonging to the family in the scene","familyId","int","gpe");
    JSLang->add_language_function("set_background","Changes the background texture","bgToChange, newBgId","void","gpe");
    //JS Object processing functions
    JSLang->add_language_function("get_component","Gets component value","componentName","ANYTYPE","GameObject");
    JSLang->add_language_function("get_collision_height","Returns object collision height","","int","GameObject");
    JSLang->add_language_function("get_collision_width","Returns object collision width","","int","GameObject");
    JSLang->add_language_function("get_depth","Returns object depth","","int","GameObject");
    JSLang->add_language_function("get_my_direction","Returns the direction between object and (x2,y2)","x2, y2","int","GameObject");
    JSLang->add_language_function("get_my_distance","Returns the distance between object and (x2,y2)","x2, y2","int","GameObject");
    JSLang->add_language_function("get_sprite","Returns sprite-id of game object","","int","GameObject");
    JSLang->add_language_function("getx","Returns x-position of game object","","double","GameObject");
    JSLang->add_language_function("getx2","Returns x2-position of game object","","double","GameObject");
    JSLang->add_language_function("gety","Returns y-position of game object","","double","GameObject");
    JSLang->add_language_function("gety2","Returns y2-position of game object","","double","GameObject");
    JSLang->add_language_function("gravity_use","Activates built in gravity","","void", "GameObject");
    JSLang->add_language_function("init_sprite","Initiates the game object's sprite on creation","nextSprite","void","GameObject");
    JSLang->add_language_function("make_view_dependent","Makes this game object camera dependent","","void","GameObject");
    JSLang->add_language_function("make_view_independent","Makes this game object camera independent","","void","GameObject");
    JSLang->add_language_function("move_left","Moves this object left by m pixels","m","void","GameObject");
    JSLang->add_language_function("move_right","Moves this object right by m pixels","m","void","GameObject");
    JSLang->add_language_function("move_up","Moves this object up by m pixels","m","void","GameObject");
    JSLang->add_language_function("move_down","Moves this object down by m pixels","m","void","GameObject");
    JSLang->add_language_function("move_towards","Moves this towards the point (x,y) at speed","x,y,speed","void","GameObject");
    JSLang->add_language_function("under_mouse","Checks if this object is under the mouse via the cameraId(defaults to 0).","cameraId","void","GameObject");
    JSLang->add_language_function("set_depth","Sets the depth of this object","newDepth","void","GameObject");
    JSLang->add_language_function("set_sprite","Sets the sprite of this object","newSprite","void","GameObject");

    //Added as of Version 1.12 [ BEGIN ]
    JSLang->add_language_function("path_begin","Makes the object begin a path","path, pathSpeed, continueOnEnd, relativePath","void","GameObject");
    JSLang->add_language_function("path_start","Makes the object start a path","path, pathSpeed, continueOnEnd, relativePath","void","GameObject");
    JSLang->add_language_function("path_end","Ends the path the object is on","","void","GameObject");
    JSLang->add_language_function("path_stop","Stops the path the object is on","","void","GameObject");
    //Added as of Version 1.12 [ END ]
    JSLang->add_language_function("set_countdown","Sets a countdown of this object's timer","timerId, countDownStart","void","GameObject");
    JSLang->add_language_function("set_timer","Sets a countdown of this object's timer in seconds","timerId, secondsInTimer","void","GameObject");

    JSLang->add_language_function("set_velocity","Moves at direction at the speed rate","direction,speed","void","GameObject");

    JSLang->add_language_function("setx","Sets the x-position of this object","x","void","GameObject");
    JSLang->add_language_function("sety","Sets the y-position of this object","y","void","GameObject");
    JSLang->add_language_function("start_countdown","Sets a countdown of this object's timer","timerId, countDownStart","void","GameObject");
    JSLang->add_language_function("start_timer","Sets a countdown of this object's timer in seconds","timerId, countDownStart","void","GameObject");
    JSLang->add_language_function("update_cords","Sets the (x,y) position of this object","x,y","void","GameObject");

    //More GPE Functions
    JSLang->add_language_function("get_past_scene","Returns the past scene id visited. Returns -1 if there is no past scene.","","int","gpe");
    JSLang->add_language_function("get_past_scene_name","Returns the past scene's name visited. Returns an empty string if there is no past scene.","","int","gpe");
    JSLang->add_language_function("get_random","Returns a random number between min and max","min,max","int","gpe");
    JSLang->add_language_function("get_scene_width","Returns scene width","sceneIdNumberIn","int","gpe");
    JSLang->add_language_function("get_scene_height","Returns scene height","sceneIdNumberIn","int","gpe");
    JSLang->add_language_function("get_scene_name","Returns scene name","sceneIdNumberIn","string","gpe");
    JSLang->add_language_function("get_current_scene_id","Returns the id of the current scene","","int","gpe");
    JSLang->add_language_function("get_current_scene_name","Returns the name of current scene","","string","gpe");
    JSLang->add_language_function("getfps","Returns frame rate","","int","gpe");
    JSLang->add_language_function("get_fps","Returns frame rate","","int","gpe");
    JSLang->add_language_function("is_audio_playing","Returns true or false if audio is playing","audioIdIn","bool","gpe");
    JSLang->add_language_function("is_video_playing","Returns true or false if video is playing","videoIdIn","bool","gpe");

    JSLang->add_language_function("loop_audio","Loops audio whose id is audioId","audioId","void","gpe");
    JSLang->add_language_function("pause_audio","Pauses audio whose id is audioId","audioId","void","gpe");
    JSLang->add_language_function("play_audio","Play audio whose id is audioId","audioId","void","gpe");
    JSLang->add_language_function("position_collides","Returns true or false if objectOne collides at (x,y)","objOne,  xIn,  yIn,  otherObjectType, layerId ","bool","gpe");
    JSLang->add_language_function("stop_all_audio","Stops all audio","","void","gpe");
    JSLang->add_language_function("stop_audio_group","Stops all audio whose groupId is groupName","groupName","void","gpe");
    JSLang->add_language_function("stop_audio","Stops audio whose id is audioId","audioId","void","gpe");

    JSLang->add_language_function("loop_video","Loops video whose id is videoId","videoId","void","gpe");
    JSLang->add_language_function("pause_video","Pauses video whose id is videoId","videoId","void","gpe");
    JSLang->add_language_function("play_video","Play video whose id is videoId","videoId","void","gpe");
    JSLang->add_language_function("stop_all_video","Stops all video","","void","gpe");
    JSLang->add_language_function("stop_video_group","Stops all video whose groupId is groupName","groupName","void","gpe");
    JSLang->add_language_function("stop_video","Stops video whose id is videoId","videoId","void","gpe");

    //rendering functions
    JSLang->add_language_function("render_circle","Renders a circle","x, y, radius, circleColor, isOutline, oulineWidth, renderImmediately","void","gpe");
    JSLang->add_language_function("render_line","Renders a line","x1, y1, x2, y2, lineColor, lineWidth, renderImmediately","void","gpe");
    JSLang->add_language_function("render_rectangle","Renders a rectangle","x1, y1, x2, y2,rectColor, outline,rectLineWidth,renderImmediately","void","gpe");
    JSLang->add_language_function("render_self","Renders this object onto scene","","void","gpe");
    JSLang->add_language_function("render_sprite_rotated","Renders a rotated sprite","spriteIdIn, frameNumb, xOn, yOn, rotationAngle,scaleX, scaleY","void","gpe");

    JSLang->add_language_function("render_sprite","Renders a sprite","spriteIdIn, frameNumb, xOn, yOn, scaleX, scaleY","void","gpe");
    JSLang->add_language_function("render_square","Renders a square","xOn, yOn, squareSize,squareColor, outline,squareLineWidth,renderImmediately","void","gpe");
    JSLang->add_language_function("render_text","Renders text","fontIdIn, xOn, yOn, textToRender, fontRenderColor, fontHalign, fontValign","void","gpe");
    JSLang->add_language_function("render_texture_rotated","Renders a rotated texture","texureIdIn, xDraw, yDraw, width, height, angle","void","gpe");
    JSLang->add_language_function("render_texture_scaled","Renders a scaled texture","texureIdIn, xDraw, yDraw, width, height","void","gpe");
    JSLang->add_language_function("render_texture","Renders a texture","texureIdIn,  xDraw, yDraw","void","gpe");
    JSLang->add_language_function("render_triangle","Renders a triangle","x1, y1, x2, y2, x3, y3, triangleColor, outline, outlineSize, renderImmediately","void","gpe");
    JSLang->add_language_function("render_wrapped_text","Renders a wrapped text","fontIdIn, xOn, yOn, textToRender,fontRenderColor, maxWidth, lineHeight","void","gpe");
    JSLang->add_language_function("scene_enter_previous","Goes to the previous scene","","void","gpe");
    JSLang->add_language_function("scene_enter_named","Goes to the scene named sceneId","sceneId","void","gpe");
    JSLang->add_language_function("scene_enter_next","Goes to the next scene","","void","gpe");
    JSLang->add_language_function("scene_enter","Goes to the scene named sceneId","sceneId","void","gpe");
    JSLang->add_language_function("scene_reset","Resets the current game scene","","void","gpe");
    JSLang->add_language_function("self_destruct","Destroys this object","","void","gpe");
    JSLang->add_language_function("set_render_alpha","Sets the canvas alpha level from 0-255","alphaValue","void","gpe");

    //Collision / Touching Functionality
    JSLang->add_language_function("touches_object","Returns first object that collides at (x,y)","objOne,  xIn,  yIn,  otherObjectType","bool","gpe");
    JSLang->add_language_function("touches_family","Returns first object that collides at (x,y) with a member of the otherObjectType family","objOne,  xIn,  yIn,  otherObjectType","bool","gpe");
    JSLang->add_language_function("touches_tile","Returns first tile id touching object","layerToCheck","int","GameObject");
    JSLang->add_language_function("touches_certain_tile","Returns if object is touching a specific tile type","layerToCheck, needleTile","bool","GameObject");

    //GPE Video Functions
    JSLang->add_language_function("video_loop","Loops video whose id is videoId","videoId","void","gpe");
    JSLang->add_language_function("video_pause","Pauses video whose id is videoId","videoId","void","gpe");
    JSLang->add_language_function("video_play","Play video whose id is videoId","videoId","void","gpe");
    JSLang->add_language_function("video_stop_all","Stops all video","","void","gpe");
    JSLang->add_language_function("video_stop","Stops video whose id is videoId","videoId","void","gpe");

     //Console functions
    JSLang->add_language_function("clear","Clears the console window.","text","void","console");
    JSLang->add_language_function("error","Writes an error message into the console window.","message","void","console");
    JSLang->add_language_function("log","Writes text into the console window.","text","void","console");
    JSLang->add_language_function("warn","Writes a warning message into the console window.","text","void","console");

     //Math functions
    JSLang->add_language_function("acos","Returns the arccosine of x.","radians x","double","Math");
    JSLang->add_language_function("asin","Returns the arcsine  of x.","radians x","double","Math");
    JSLang->add_language_function("atan","Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians","x","double","Math");
    JSLang->add_language_function("atan2","Returns the arctangent of the quotient of its arguments","y,x","double","Math");

    JSLang->add_language_function("exp","Returns E ^X","x","double","Math");
    JSLang->add_language_function("pow","Returns X ^Y","x,y","double","Math");
    JSLang->add_language_function("log","Returns the natural logarithm (base E) of x","x","int","Math");
    JSLang->add_language_function("cos","Returns cos( (radians)x )","(radians)x","double","Math");
    JSLang->add_language_function("sin","Returns sin( (radians)x )","(radians)x","double","Math");
    JSLang->add_language_function("tan","Returns tan( (angle)x )","x,y","double","Math");
    JSLang->add_language_function("min","Returns the smallest NUMBER found","x,y,z...N","double","Math");
    JSLang->add_language_function("max","Returns the highest NUMBER found","x,y,z...N","double","Math");
    JSLang->add_language_function("sqrt","Returns the square root of x","x","double","Math");
    JSLang->add_language_function("random","Returns a random number from 0 to 1","","double","Math");
    JSLang->add_language_function("round","Rounds the number","","int","Math");
    JSLang->add_language_function("floor","Rounds the number downward","","int","Math");
    JSLang->add_language_function("ceil","Rounds the number upward","","int","Math");

    //JS keywords
    JSLang->add_language_keyword("break");
    JSLang->add_language_keyword("case");
    JSLang->add_language_keyword("const");
    JSLang->add_language_keyword("continue");
    JSLang->add_language_keyword("default");
    JSLang->add_language_keyword("delete");
    JSLang->add_language_keyword("do");
    JSLang->add_language_keyword("else");
    JSLang->add_language_keyword("FALSE");
    JSLang->add_language_keyword("false");
    JSLang->add_language_keyword("fa_left");
    JSLang->add_language_keyword("fa_center");
    JSLang->add_language_keyword("fa_right");
    JSLang->add_language_keyword("fa_top");
    JSLang->add_language_keyword("fa_middle");
    JSLang->add_language_keyword("fa_bottom");
    JSLang->add_language_keyword("for");
    JSLang->add_language_keyword("gpe");
    JSLang->add_language_keyword("GPE");
    JSLang->add_language_keyword("gpr");
    JSLang->add_language_keyword("GPR");
    JSLang->add_language_keyword("if");
    JSLang->add_language_keyword("Infinity");
    JSLang->add_language_keyword("isnull");
    JSLang->add_language_keyword("is_null");
    JSLang->add_language_keyword("IS_NULL");
    JSLang->add_language_keyword("NaN");
    JSLang->add_language_keyword("new");
    JSLang->add_language_keyword("null");
    JSLang->add_language_keyword("NULL");
    JSLang->add_language_keyword("other");
    JSLang->add_language_keyword("pencil");
    JSLang->add_language_keyword("return");
    JSLang->add_language_keyword("switch");
    JSLang->add_language_keyword("this");
    JSLang->add_language_keyword("true");
    JSLang->add_language_keyword("TRUE");
    JSLang->add_language_keyword("undefined");
    JSLang->add_language_keyword("UNDEFINED");
    JSLang->add_language_keyword("while");

    //JS Keyboard (kb_ ) constants
    JSLang->add_language_keyword("kb_0");
    JSLang->add_language_keyword("kb_1");
    JSLang->add_language_keyword("kb_2");
    JSLang->add_language_keyword("kb_3");
    JSLang->add_language_keyword("kb_4");
    JSLang->add_language_keyword("kb_5");
    JSLang->add_language_keyword("kb_6");
    JSLang->add_language_keyword("kb_7");
    JSLang->add_language_keyword("kb_8");
    JSLang->add_language_keyword("kb_9");

    JSLang->add_language_keyword("kb_a");
    JSLang->add_language_keyword("kb_b");
    JSLang->add_language_keyword("kb_c");
    JSLang->add_language_keyword("kb_d");
    JSLang->add_language_keyword("kb_e");
    JSLang->add_language_keyword("kb_f");
    JSLang->add_language_keyword("kb_g");
    JSLang->add_language_keyword("kb_h");
    JSLang->add_language_keyword("kb_i");
    JSLang->add_language_keyword("kb_j");
    JSLang->add_language_keyword("kb_k");
    JSLang->add_language_keyword("kb_l");
    JSLang->add_language_keyword("kb_m");
    JSLang->add_language_keyword("kb_n");
    JSLang->add_language_keyword("kb_o");
    JSLang->add_language_keyword("kb_p");
    JSLang->add_language_keyword("kb_q");
    JSLang->add_language_keyword("kb_r");
    JSLang->add_language_keyword("kb_s");
    JSLang->add_language_keyword("kb_t");
    JSLang->add_language_keyword("kb_u");
    JSLang->add_language_keyword("kb_v");
    JSLang->add_language_keyword("kb_w");
    JSLang->add_language_keyword("kb_x");
    JSLang->add_language_keyword("kb_y");
    JSLang->add_language_keyword("kb_z");

    JSLang->add_language_keyword("kb_np0");
    JSLang->add_language_keyword("kb_np1");
    JSLang->add_language_keyword("kb_np2");
    JSLang->add_language_keyword("kb_np3");
    JSLang->add_language_keyword("kb_np4");
    JSLang->add_language_keyword("kb_np5");
    JSLang->add_language_keyword("kb_np6");
    JSLang->add_language_keyword("kb_np7");
    JSLang->add_language_keyword("kb_np8");
    JSLang->add_language_keyword("kb_np9");

    JSLang->add_language_keyword("kb_f1");
    JSLang->add_language_keyword("kb_f2");
    JSLang->add_language_keyword("kb_f3");
    JSLang->add_language_keyword("kb_f4");
    JSLang->add_language_keyword("kb_f5");
    JSLang->add_language_keyword("kb_f6");
    JSLang->add_language_keyword("kb_f7");
    JSLang->add_language_keyword("kb_f8");
    JSLang->add_language_keyword("kb_f9");
    JSLang->add_language_keyword("kb_f10");
    JSLang->add_language_keyword("kb_f11");
    JSLang->add_language_keyword("kb_f12");

    JSLang->add_language_keyword("kb_backspace");
    JSLang->add_language_keyword("kb_tab");
    JSLang->add_language_keyword("kb_enter");
    JSLang->add_language_keyword("kb_pause");
    JSLang->add_language_keyword("kb_caps");
    JSLang->add_language_keyword("kb_esc");
    JSLang->add_language_keyword("kb_space");
    JSLang->add_language_keyword("kb_page_up");
    JSLang->add_language_keyword("kb_page_down");
    JSLang->add_language_keyword("kb_end");
    JSLang->add_language_keyword("kb_home");
    JSLang->add_language_keyword("kb_left");
    JSLang->add_language_keyword("kb_up");
    JSLang->add_language_keyword("kb_right");
    JSLang->add_language_keyword("kb_down");
    JSLang->add_language_keyword("kb_insert");
    JSLang->add_language_keyword("kb_delete");
    JSLang->add_language_keyword("kb_shift");
    JSLang->add_language_keyword("kb_ctrl");
    JSLang->add_language_keyword("kb_alt");
    JSLang->add_language_keyword("kb_plus");
    JSLang->add_language_keyword("kb_period");
    JSLang->add_language_keyword("kb_minus");
    JSLang->add_language_keyword("kb_period");

    JSLang->add_language_keyword("kb_multiply");
    JSLang->add_language_keyword("kb_add");
    JSLang->add_language_keyword("kb_substract");
    JSLang->add_language_keyword("kb_decimal");
    JSLang->add_language_keyword("kb_divide");
    JSLang->add_language_keyword("kb_fslash");
    JSLang->add_language_keyword("kb_gaccent");
    JSLang->add_language_keyword("kb_obracket");
    JSLang->add_language_keyword("kb_bslash");
    JSLang->add_language_keyword("kb_cbracket");
    JSLang->add_language_keyword("kb_squote");

    //JS Keyboard (gp_ ) constants
    JSLang->add_language_keyword("gp_0");
    JSLang->add_language_keyword("gp_1");
    JSLang->add_language_keyword("gp_2");
    JSLang->add_language_keyword("gp_3");
    JSLang->add_language_keyword("gp_4");
    JSLang->add_language_keyword("gp_5");
    JSLang->add_language_keyword("gp_6");
    JSLang->add_language_keyword("gp_7");
    JSLang->add_language_keyword("gp_8");
    JSLang->add_language_keyword("gp_9");

    JSLang->add_language_keyword("gp_np0");
    JSLang->add_language_keyword("gp_np1");
    JSLang->add_language_keyword("gp_np2");
    JSLang->add_language_keyword("gp_np3");
    JSLang->add_language_keyword("gp_np4");
    JSLang->add_language_keyword("gp_np5");
    JSLang->add_language_keyword("gp_np6");
    JSLang->add_language_keyword("gp_np7");
    JSLang->add_language_keyword("gp_np8");
    JSLang->add_language_keyword("gp_np9");

    JSLang->add_language_keyword("gp_f1");
    JSLang->add_language_keyword("gp_f2");
    JSLang->add_language_keyword("gp_f3");
    JSLang->add_language_keyword("gp_f4");
    JSLang->add_language_keyword("gp_f5");
    JSLang->add_language_keyword("gp_f6");
    JSLang->add_language_keyword("gp_f7");
    JSLang->add_language_keyword("gp_f8");
    JSLang->add_language_keyword("gp_f9");
    JSLang->add_language_keyword("gp_f10");
    JSLang->add_language_keyword("gp_f11");
    JSLang->add_language_keyword("gp_f12");

    JSLang->add_language_keyword("gp_backspace");
    JSLang->add_language_keyword("gp_tab");
    JSLang->add_language_keyword("gp_enter");
    JSLang->add_language_keyword("gp_pause");
    JSLang->add_language_keyword("gp_caps");
    JSLang->add_language_keyword("gp_esc");
    JSLang->add_language_keyword("gp_space");
    JSLang->add_language_keyword("gp_page_up");
    JSLang->add_language_keyword("gp_page_down");
    JSLang->add_language_keyword("gp_end");
    JSLang->add_language_keyword("gp_home");
    JSLang->add_language_keyword("gp_left");
    JSLang->add_language_keyword("gp_up");
    JSLang->add_language_keyword("gp_right");
    JSLang->add_language_keyword("gp_down");
    JSLang->add_language_keyword("gp_insert");
    JSLang->add_language_keyword("gp_delete");
    JSLang->add_language_keyword("gp_shift");
    JSLang->add_language_keyword("gp_ctrl");
    JSLang->add_language_keyword("gp_alt");
    JSLang->add_language_keyword("gp_plus");
    JSLang->add_language_keyword("gp_comma");
    JSLang->add_language_keyword("gp_minus");
    JSLang->add_language_keyword("gp_period");

    JSLang->add_language_keyword("gp_multiply");
    JSLang->add_language_keyword("gp_add");
    JSLang->add_language_keyword("gp_substract");
    JSLang->add_language_keyword("gp_decimal");
    JSLang->add_language_keyword("gp_divide");
    JSLang->add_language_keyword("gp_fslash");
    JSLang->add_language_keyword("gp_gaccent");
    JSLang->add_language_keyword("gp_obracket");
    JSLang->add_language_keyword("gp_bslash");
    JSLang->add_language_keyword("gp_cbracket");
    JSLang->add_language_keyword("gp_squote");

    //JS Mouse Contants
    JSLang->add_language_keyword("mb_center");
    JSLang->add_language_keyword("mb_left");
    JSLang->add_language_keyword("mb_middle");
    JSLang->add_language_keyword("mb_right");

    //JS GameController constants(gc_) [ BEGIN ]
    JSLang->add_language_keyword("gc_anycontroller");
    JSLang->add_language_keyword("gc_nocontroller");
    JSLang->add_language_keyword("gc_anybutton");
    JSLang->add_language_keyword("gc_nobutton");

    JSLang->add_language_keyword("gc_joystick_left_x");
    JSLang->add_language_keyword("gc_joystick_left_y");
    JSLang->add_language_keyword("gc_joystick_right_x");
    JSLang->add_language_keyword("gc_joystick_right_y");
    JSLang->add_language_keyword("gc_joystick_dpad_x");
    JSLang->add_language_keyword("gc_joystick_dpad_y");

    JSLang->add_language_keyword("gc_left");
    JSLang->add_language_keyword("gc_right");
    JSLang->add_language_keyword("gc_up");
    JSLang->add_language_keyword("gc_down");
    JSLang->add_language_keyword("gkb_c0");
    JSLang->add_language_keyword("gkb_c1");
    JSLang->add_language_keyword("gkb_c2");
    JSLang->add_language_keyword("gkb_c3");
    JSLang->add_language_keyword("gc_l1");
    JSLang->add_language_keyword("gc_l2");
    JSLang->add_language_keyword("gc_l3");
    JSLang->add_language_keyword("gc_r1");
    JSLang->add_language_keyword("gc_r2");
    JSLang->add_language_keyword("gc_r3");

    JSLang->add_language_keyword("gc_home");
    JSLang->add_language_keyword("gc_select");
    JSLang->add_language_keyword("gc_share");
    JSLang->add_language_keyword("gc_start");
    //GameController constants(gc_) [ END ]

    //Legacy Keyboard constants(gp_) [ BEGIN ]
    JSLang->add_language_keyword("gp_a");
    JSLang->add_language_keyword("gp_b");
    JSLang->add_language_keyword("gp_c");
    JSLang->add_language_keyword("gp_d");
    JSLang->add_language_keyword("gp_e");
    JSLang->add_language_keyword("gp_f");
    JSLang->add_language_keyword("gp_g");
    JSLang->add_language_keyword("gp_h");
    JSLang->add_language_keyword("gp_i");
    JSLang->add_language_keyword("gp_j");
    JSLang->add_language_keyword("gp_k");
    JSLang->add_language_keyword("gp_l");
    JSLang->add_language_keyword("gp_m");
    JSLang->add_language_keyword("gp_n");
    JSLang->add_language_keyword("gp_o");
    JSLang->add_language_keyword("gp_p");
    JSLang->add_language_keyword("gp_q");
    JSLang->add_language_keyword("gp_r");
    JSLang->add_language_keyword("gp_s");
    JSLang->add_language_keyword("gp_t");
    JSLang->add_language_keyword("gp_u");
    JSLang->add_language_keyword("gp_v");
    JSLang->add_language_keyword("gp_w");
    JSLang->add_language_keyword("gp_x");
    JSLang->add_language_keyword("gp_y");
    JSLang->add_language_keyword("gp_z");

    //Legacy Keyboard constants(gp_) [ END ]

    //javascript only words(allowed on html5 building)
    JSLang->add_language_keyword("console","The console window used to display errors in important information","JavaScript Global");
    JSLang->add_language_keyword("Date","Used to get the time/date of the user","JavaScript Global");
    JSLang->add_language_keyword("Math","The built in Math class","JavaScript Global");
    JSLang->add_language_keyword("debuger","The debugger console window used to display errors","JavaScript Global");
    JSLang->add_language_keyword("extends","","JavaScript Global");
    JSLang->add_language_keyword("export","","JavaScript Global");
    JSLang->add_language_keyword("finally","","JavaScript Global");
    JSLang->add_language_keyword("function","","JavaScript Global");
    JSLang->add_language_keyword("import","","JavaScript Global");

    JSLang->add_language_keyword("Math","","JavaScript Global");
    JSLang->add_language_keyword("super","","JavaScript Global");
    JSLang->add_language_keyword("throw","","JavaScript Global");
    JSLang->add_language_keyword("try","","JavaScript Global");
    JSLang->add_language_keyword("typeof","","JavaScript Global");
    JSLang->add_language_keyword("var","","JavaScript Global");
    JSLang->add_language_keyword("yield","","JavaScript Global");

    //Object key variables
    JSLang->add_language_variable("customComponents","An object's array of custom components created in editor", "GameObject" );
    JSLang->add_language_variable("direction","An objects direction in radians", "GameObject" );
    JSLang->add_language_variable("speed","An objects speed in pixels", "GameObject" );
    JSLang->add_language_variable("imageSpeed","An object's imageSpeed per game frame", "GameObject" );
    JSLang->add_language_variable("isVisible","A boolean if the object is visible", "GameObject" );
    JSLang->add_language_variable("spriteFrame","The current frame of the object's current sprite", "GameObject" );
    JSLang->add_language_variable("xPast","The object's x-coordinate from last frame", "GameObject" );
    JSLang->add_language_variable("yPast","The object's y-coordinate from last frame", "GameObject" );

    JSLang->add_language_variable("GPE_SETTINGS_APP_LOGO_LOCATION");
    JSLang->add_language_variable("GPE_SETTINGS_SCREEN_WIDTH");
    JSLang->add_language_variable("GPE_SETTINGS_SCREEN_HEIGHT");
    JSLang->add_language_variable("GPE_SETTINGS_PROG_NAME");
    JSLang->add_language_variable("GPE_MAX_OBJECT_TYPES");
    JSLang->add_language_variable("GPE_SETTINGS_SYSTEM_OS");
    JSLang->add_language_variable("GPE_GAME_PUBLISHER");
    JSLang->add_language_variable("GPE_GAME_DEVELOPER");
    JSLang->add_language_variable("GPE_GAME_OBJECTS_COUNT");
    JSLang->add_language_variable("GPE_SETTINGS_IS_DEBUGGING");
    JSLang->add_language_variable("GPE_SETTINGS_SHOW_FPS");
    JSLang->add_language_variable("GPE_SETTINGS_ENTRY_LEVEL_LOCATION");

    JSLang->add_language_variable("programStates");
    JSLang->add_language_variable("canvas");
    JSLang->add_language_variable("context");
    JSLang->add_language_variable("inputController");
    JSLang->add_language_variable("maxViews");
    JSLang->add_language_variable("EXTRA_CANVASES");
    JSLang->add_language_variable("preGuiCamvas");
    JSLang->add_language_variable("fileReader");
    JSLang->add_language_variable("programStateId");
    JSLang->add_language_variable("currentState");

	//actual datatypes used/allowed
    JSLang->add_language_data_type("char");
    JSLang->add_language_data_type("double");
    JSLang->add_language_data_type("float");
    JSLang->add_language_data_type("grid");
    JSLang->add_language_data_type("int");
    JSLang->add_language_data_type("string");
    JSLang->add_language_data_type("vector");

    //Adds CSS language synthax and such
    GPE_Gui_Engine_Language * CSSLang = add_programming_language("CSS","CSS", true, false,false);
    CSSLang->add_language_keyword("a:active");
    CSSLang->add_language_keyword("a:hover");
    CSSLang->add_language_keyword("a:link");
    CSSLang->add_language_keyword("a:visited");
    CSSLang->add_language_keyword("a");
    CSSLang->add_language_keyword("body");
    CSSLang->add_language_keyword("button");
    CSSLang->add_language_keyword("canvas");
    CSSLang->add_language_keyword("div");
    CSSLang->add_language_keyword("p");
    CSSLang->add_language_keyword("h1");
    CSSLang->add_language_keyword("h2");
    CSSLang->add_language_keyword("h3");
    CSSLang->add_language_keyword("h4");
    CSSLang->add_language_keyword("h5");
    CSSLang->add_language_keyword("h6");
    CSSLang->add_language_keyword("h7");
    CSSLang->add_language_keyword("h8");
    CSSLang->add_language_keyword("h9");
    CSSLang->add_language_keyword("html");
    CSSLang->add_language_keyword("hr");
    CSSLang->add_language_keyword("input");
    CSSLang->add_language_keyword("li");
    CSSLang->add_language_keyword("ol");
    CSSLang->add_language_keyword("table");
    CSSLang->add_language_keyword("th");
    CSSLang->add_language_keyword("th");
    CSSLang->add_language_keyword("tr");
    CSSLang->add_language_keyword("ul");

    CSSLang->add_language_keyword("align");
    CSSLang->add_language_keyword("background");
    CSSLang->add_language_keyword("backface");
    CSSLang->add_language_keyword("bottom");
    CSSLang->add_language_keyword("border");
    CSSLang->add_language_keyword("box");
    CSSLang->add_language_keyword("clear");
    CSSLang->add_language_keyword("collapse");
    CSSLang->add_language_keyword("color");
    CSSLang->add_language_keyword("cursor");
    CSSLang->add_language_keyword("display");
    CSSLang->add_language_keyword("family");
    CSSLang->add_language_keyword("filter");
    CSSLang->add_language_keyword("float");
    CSSLang->add_language_keyword("font");
    CSSLang->add_language_keyword("height");
    CSSLang->add_language_keyword("horizontal");
    CSSLang->add_language_keyword("image");
    CSSLang->add_language_keyword("left");
    CSSLang->add_language_keyword("line-height");
    CSSLang->add_language_keyword("line-width");
    CSSLang->add_language_keyword("list-style-type");
    CSSLang->add_language_keyword("list-style-position");
    CSSLang->add_language_keyword("list-style-type");

    CSSLang->add_language_keyword("margin-left");
    CSSLang->add_language_keyword("margin-top");
    CSSLang->add_language_keyword("margin-bottom");
    CSSLang->add_language_keyword("margin-right");
    CSSLang->add_language_keyword("margin");
    CSSLang->add_language_keyword("max-width");
    CSSLang->add_language_keyword("max-height");
    CSSLang->add_language_keyword("ms-transform");

    CSSLang->add_language_keyword("min-height");
    CSSLang->add_language_keyword("min-width");
    CSSLang->add_language_keyword("opacity");
    CSSLang->add_language_keyword("outline-color");
    CSSLang->add_language_keyword("outline-style");
    CSSLang->add_language_keyword("outline-width");
    CSSLang->add_language_keyword("outline");
    CSSLang->add_language_keyword("overflow-x");
    CSSLang->add_language_keyword("overflow-y");
    CSSLang->add_language_keyword("overflow");

    CSSLang->add_language_keyword("padding");
    CSSLang->add_language_keyword("position");
    CSSLang->add_language_keyword("right");
    CSSLang->add_language_keyword("shadow");
    CSSLang->add_language_keyword("size");
    CSSLang->add_language_keyword("text");
    CSSLang->add_language_keyword("text");
    CSSLang->add_language_keyword("top");
    CSSLang->add_language_keyword("transition");
    CSSLang->add_language_keyword("vertical");
    CSSLang->add_language_keyword("visibility");
    CSSLang->add_language_keyword("webkit");
    CSSLang->add_language_keyword("width");
}

GPE_Gui_Engine_MiniCompiler::~GPE_Gui_Engine_MiniCompiler()
{

}

GPE_Gui_Engine_Language * GPE_Gui_Engine_MiniCompiler::add_programming_language(std::string langName, std::string langShortName, bool useDefaultSymbols, bool isCodingLanguage,bool isDefaultCodeLanguage)
{
    GPE_Gui_Engine_Language * newLangauge = new GPE_Gui_Engine_Language(langName, langShortName,isCodingLanguage, useDefaultSymbols);
    editorLanguages.push_back(newLangauge);
    return newLangauge;
}

bool GPE_Gui_Engine_MiniCompiler::is_reserved_word(std::string strIn)
{
    return true;
}

bool GPE_Gui_Engine_MiniCompiler::is_compilable_word(std::string strIn)
{
    GPE_Compiler_Term * tTerm = NULL;
    int i = 0;
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->is_compilable_word(strIn);
    }
    return true;
}


bool GPE_Gui_Engine_MiniCompiler::charIsSymbol(char  charIn)
{
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->charIsSymbol(charIn);
    }
    return false;
}

int GPE_Gui_Engine_MiniCompiler::firstSymbolInString(std::string inString, int pos)
{
    int returnVal = -1;
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->firstSymbolInString(inString, pos);

    }
    return returnVal;
}

std::string GPE_Gui_Engine_MiniCompiler::find_gpe_datatype(std::string strBeingChecked, int startPos)
{
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->find_gpe_datatype( strBeingChecked, startPos);
    }
    return "";
}


std::string GPE_Gui_Engine_MiniCompiler::find_gpe_function(std::string strBeingChecked, int startPos)
{
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->find_gpe_function( strBeingChecked, startPos);
    }
    return "";
}


std::string GPE_Gui_Engine_MiniCompiler::find_gpe_keyword(std::string strBeingChecked, int startPos)
{
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->find_gpe_keyword( strBeingChecked, startPos);
    }
    return "";
}


std::string GPE_Gui_Engine_MiniCompiler::find_gpe_variable(std::string strBeingChecked, int startPos)
{
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->find_gpe_variable( strBeingChecked, startPos);
    }
    return "";
}

GPE_Compiler_Term * GPE_Gui_Engine_MiniCompiler::find_matching_variable(std::string nameIn)
{
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->find_matching_variable( nameIn );
    }
    return NULL;
}

GPE_Compiler_Term * GPE_Gui_Engine_MiniCompiler::find_matching_function(std::string nameIn)
{
    if( defaultLanguage!=NULL )
    {
        return defaultLanguage->find_matching_function( nameIn );
    }
    return NULL;
}

bool GPE_Gui_Engine_MiniCompiler::process_parameters_string( std::string paramToProcess)
{
    foundParameters.clear();
    defaultParameterLines.clear();
    functionParameterErrors.clear();
    newParametersString = "";
    parametersAreValid = true;
    std::string paramToCompile = "";
    int paramStrSize = (int)paramToProcess.size();
    if( paramStrSize > 0)
    {
        bool isinSingleQuote = false;
        bool isInDoubleQuote = false;
        int i = 0;
        int lastParamPos = 0;
        int foundEqualPos = -1;
        int lastParamThatHAsDefaultValue = -1;
        std::string foundParameterStr= "";
        for(  i = 0; i < paramStrSize; i++)
        {
            if( !isinSingleQuote && paramToProcess[i]=='"' )
            {
                isInDoubleQuote = !isInDoubleQuote;
            }
            else if(!isInDoubleQuote && paramToProcess[i]=='\'')
            {
                isinSingleQuote = !isinSingleQuote;
            }
            else if( !isInDoubleQuote && !isinSingleQuote)
            {
                if( paramToProcess[i]==',')
                {
                    if( i!=lastParamPos)
                    {
                        foundParameterStr = get_substring(paramToProcess,lastParamPos,i-lastParamPos );
                        foundParameters.push_back(foundParameterStr);
                        lastParamPos = i+1;
                    }
                    else
                    {
                        parametersAreValid = false;
                        functionParameterErrors.push_back( "Invalid Comma found at position 0 of parameters string");
                    }
                }
            }
        }
        if( lastParamPos < (int)paramToProcess.size() )
        {
            foundParameterStr = get_substring(paramToProcess,lastParamPos );
            foundParameters.push_back(foundParameterStr);
        }

        if( parametersAreValid)
        {
            std::string parameterKey = "";
            std::string parameterValue = "";
            std::string newParameterLine = "";
            lastParamThatHAsDefaultValue = (int)foundParameters.size();
            for( i = (int)foundParameters.size()-1; i >=0; i--)
            {
                paramToCompile = foundParameters[i];
                foundEqualPos = paramToCompile.find("=",0);
                if( foundEqualPos > 0)
                {
                    if( lastParamThatHAsDefaultValue==i+1)
                    {
                        parameterKey = get_substring(paramToCompile,0,foundEqualPos );
                        parameterKey = trim_left_inplace(parameterKey);
                        parameterKey = trim_right_inplace(parameterKey);

                        parameterValue = get_substring(paramToCompile,foundEqualPos+1 );
                        parameterValue = trim_left_inplace(parameterValue);
                        parameterValue = trim_right_inplace(parameterValue);

                       if( is_alnum(parameterKey,false,true) && (int)parameterKey.size() >0 )
                       {
                            if( (int)parameterValue.size() >0 )
                            {
                                if( is_compilable_word(parameterKey) )
                                {
                                    if( i==0)
                                    {
                                        newParametersString = parameterKey+newParametersString;
                                    }
                                    else
                                    {
                                        newParametersString = ","+parameterKey+newParametersString;
                                    }
                                    newParameterLine = "if("+parameterKey+"==undefined) "+parameterKey+" = "+parameterValue+";\n";
                                    defaultParameterLines.insert(defaultParameterLines.begin()+0,newParameterLine);
                                    lastParamThatHAsDefaultValue = i;
                                }
                                else
                                {
                                    functionParameterErrors.push_back(  "Illegal parameter entered is a GPE engine variable ["+parameterKey+"]");
                                    parametersAreValid = false;
                                    break;
                                }
                            }
                            else
                            {
                                functionParameterErrors.push_back(  "Illegal parameter value ["+parameterValue+"] listed");
                                parametersAreValid = false;
                                break;
                            }
                        }
                        else
                        {
                            functionParameterErrors.push_back(  "Illegal parameter ["+parameterKey+"] listed");
                            parametersAreValid = false;
                            break;
                        }
                    }
                    else
                    {
                        parametersAreValid = false;
                        functionParameterErrors.push_back(  "Default Parameter value not allowed at position ["+int_to_string(i)+"] for ["+paramToCompile+"]" );
                        break;
                    }
                }
                else if(lastParamThatHAsDefaultValue!=-1 && lastParamThatHAsDefaultValue!=i+1)
                {
                    parametersAreValid = false;
                    functionParameterErrors.push_back(  "Default Parameter value NEEDED @ position ["+int_to_string(i)+"] for ["+paramToCompile+"]" );
                    break;
                }
                else
                {
                    if( is_compilable_word(paramToCompile) )
                    {
                        newParametersString = parameterKey+","+paramToCompile;
                        lastParamThatHAsDefaultValue = i;
                    }
                    else
                    {
                        functionParameterErrors.push_back( "Illegal parameter entered is a GPE engine variable ["+paramToCompile+"]" );
                        parametersAreValid = false;
                        break;
                    }
                }
            }
        }
        else
        {
            newParametersString = "";
        }
    }
    if( !parametersAreValid)
    {
        foundParameters.clear();
        defaultParameterLines.clear();
        newParametersString = "";
    }
    return parametersAreValid;
}

void GPE_Gui_Engine_MiniCompiler::begin_compiling()
{
    compilerErrors.clear();
    compilerWarnings.clear();
    defaultParameterLines.clear();
    newParametersString = "";
    parametersAreValid = true;
}


GPE_Gui_Engine::GPE_Gui_Engine()
{
    textAreaFindBox.x = 0;
    textAreaFindBox.y = 0;
    textAreaFindBox.w = 32;
    textAreaFindBox.h = 32;
    tempTopLeftMessage = false;
    textAreaDelayTime = 4;
    textInputDelayTime = 4;
    normalInputDelayTime = 0;

    includeNintendoWiiUExport = false;
    includeNintendoSwitchExport = false;
    includePlaystation4Export = false;
    includeXboxOneExport = false;
    editorReleaseType = RELEASE_TYPE_BETA;
    if( MAIN_RENDERER!=NULL)
    {
        MAIN_RENDERER->set_window_title("Game Pencil Engine");
        record_error("Main renderer is not null...");
    }
    else
    {
        record_error("Main renderer is null...");
    }
    load_tips();
    fileOpenProjectDir = "";
    fileOpenProjectIconDir = "";
    fileSaveProjectDir = "";
    fileOpenAudioDir = "";
    fileOpenSpriteDir = "";
    fileOpenTextureDir = "";
    fileOpenTilesheetDir = "";
    fileOpenFontDir = "";
    fileOpenFunctionDir = "";
    fileOpenTextFileDir = "";
    fileOpenImportFileDir = "";
    fileSaveExportFileDir = "";
    fileSaveTextFileDir = "";
    fileOpenDefaultDir = "";
    fileSaveDefaultDir = "";

    defaultLineCountWidth = 48;
    showTextEditorLineCount = true;
    showTextEditorSynthaxHightlight = true;
    previousScreenshot = NULL;
    mainToolBar = NULL;
    toolTipString = "";
    toolTipTexture = NULL;
    toolTipX = 0;
    toolTipY = 0;
    mainResourceBar = NULL;
    GPE_CUSTOM_TEMPLATE = new GPE_Template();
    GPE_DEFAULT_TEMPLATE = new GPE_Template();

    GPE_MAIN_TEMPLATE = GPE_DEFAULT_TEMPLATE;

    GPE_DARK_TEMPLATE = new GPE_Template();
    GPE_DARK_TEMPLATE->load_theme("dark_theme.gpf");

    GPE_LIGHT_TEMPLATE = new GPE_Template();
    GPE_LIGHT_TEMPLATE->load_theme("light_theme.gpf");

    GPE_RED_TEMPLATE = new GPE_Template();
    GPE_RED_TEMPLATE->load_theme("red_theme.gpf");

    GPE_GREEN_TEMPLATE = new GPE_Template();
    GPE_GREEN_TEMPLATE->load_theme("green_theme.gpf");

    GPE_BLUE_TEMPLATE = new GPE_Template();
    GPE_BLUE_TEMPLATE->load_theme("blue_theme.gpf");

    MAIN_CONTEXT_MENU = new GPE_PopUpMenu_Option("  ",-1,true,false,true);
    //MAIN_CONTEXT_MENU->isTopOfMenu = true;

    GPE_TEXTURE_COLOR_PICKER_GRADIENT = new GPE_Texture();
    if( GPE_TEXTURE_COLOR_PICKER_GRADIENT!=NULL)
    {
        GPE_TEXTURE_COLOR_PICKER_GRADIENT->load_new_texture(MAIN_RENDERER,APP_DIRECTORY_NAME+"resources/gfx/textures/color_picker_gradient.png",-1,false);
    }

    GPE_SURFACE_COLOR_PICKER_GRADIENT =load_surface_image(APP_DIRECTORY_NAME+"resources/gfx/textures/color_picker_gradient.png");
    if( SDL_MUSTLOCK( GPE_SURFACE_COLOR_PICKER_GRADIENT) )
    {
        SDL_LockSurface(GPE_SURFACE_COLOR_PICKER_GRADIENT);
    }
    GPE_LOGO = new GPE_Texture();
    if( GPE_LOGO!=NULL)
    {
        GPE_LOGO->load_new_texture(MAIN_RENDERER,APP_DIRECTORY_NAME+"resources/gfx/textures/game_penciil_logo.png",-1,false);
    }

    GPE_TEXTURE_TRANSPARENT_BG = new GPE_Texture();
    if( GPE_TEXTURE_TRANSPARENT_BG!=NULL)
    {
        GPE_TEXTURE_TRANSPARENT_BG->load_new_texture(MAIN_RENDERER,APP_DIRECTORY_NAME+"resources/gfx/textures/transparent_bg.png",-1,false);
    }

    GPE_CHECKMARK_IMAGE = new GPE_Texture();
    if( GPE_CHECKMARK_IMAGE!=NULL)
    {
        GPE_CHECKMARK_IMAGE->load_new_texture(MAIN_RENDERER,APP_DIRECTORY_NAME+"resources/gfx/icons/checkmark_200px.png",-1,false);
    }
    GPE_TRIANGLE = rsm->sprite_add(APP_DIRECTORY_NAME+"resources/gfx/sprites/spr_triangle_64px.png",4,true,0,0,false);

    GPE_Cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW);
    GPE_HoverCursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND);
    GPE_LoadingCursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_WAIT);

    findTextStringBox = new GPE_TextInputBasic("");
    findTextStringBox->resubmissionAllowed = true;
    findTextStringBox->set_width(128);
    replaceTextStringBox = new GPE_TextInputBasic("");
    replaceTextStringBox->set_width(128);
    goToLineStringBox = new GPE_TextInputNumber("");
    findButton = new GPE_ToolLabelButton(0,0,"Find","Find String");
    goToButton = new GPE_ToolLabelButton(0,0,"Go To","Go To This Line in Text Area");

    findAllButton = new GPE_ToolLabelButton(0,0,"Find All","Find All Copies of String in Text Area");
    replaceButton = new GPE_ToolLabelButton(0,0,"Replace","Replace Next String in Text Area");
    replaceAllButton = new GPE_ToolLabelButton(0,0,"Replace All","Replace All Copries of Strings in Text Area");

    findMatchCase = new GPE_CheckBoxBasic("Match case","Search is case-sensitive",0,0,true);
    scopeLabel = new GPE_Label_Text("Scope:     ","Scope of your search");
    findScope = new GPE_DropDown_Menu(0,0,"Scope");
    findScope->add_menu_option("Open Tabs","Open Tabs",0,false);
    findScope->add_menu_option("Project Resources","Project Resources",1,true);
    findScope->add_menu_option("Workspace Resources","Workspace Resources",2);
    //findTextStringBox->set_label("Find:");
    //goToLineStringBox->set_label("Go To Line:");
    //replaceTextStringBox->set_label("Replace:");
    previousSearchMode = SEARCH_MODE_FINDALL;
    textSearchMode = 0;
    searchResultProjectName = "";
    searchResultResourceName = "";
    searchResultResourceId = 0;
    showFindAllResults = false;
    showTipsAtStartUp = true;
    showStartPageAtStartUp = true;
    tempUserMessageTitle = "";
    tempUserMessageSubtitle = "";
    tempUserMessageText = "";
    temporayMessageDisplayTimer = 0;
    temporayMessageDisplayStartTimer = 0;

    //For code highlights and suggested text
    highlightedTerm = NULL;
    highlightXPos = 0;
    highlightYPos = 0;
    documentationIsBeingShown = false;
    codeBeingSuggested = false;
    iSuggestedStartPos = 0;
    iSuggestionPos = 0;
    suggestedTextMaxInViewCount = 0;
    maxSuggestedTextWidth = 0;
    //End of suggested text/code highlights related variables

    //loads the recent file list
    std::string recentFileListFileName = get_user_settings_folder()+"recent_projects.txt";
    std::ifstream recentFileListFile( recentFileListFileName.c_str() );
    if( !recentFileListFile.fail() )
    {
        std::string currLine = "";
        //makes sure the file is open
        if (recentFileListFile.is_open())
        {
            while ( recentFileListFile.good() )
            {
                getline (recentFileListFile,currLine); //gets the next line of the file
                currLine = trim_left_inplace(currLine);
                currLine = trim_right_inplace(currLine);
                add_to_recent_project_list(currLine,false);
            }
            recentFileListFile.close();
        }
    }
}

GPE_Gui_Engine::~GPE_Gui_Engine()
{
    GPE_ProjectFolder * tempProject = NULL;
    for( int i = (int)gpeProjects.size()-1; i >=0; i--)
    {
        tempProject = gpeProjects[i];
        if( tempProject!=NULL)
        {
            delete tempProject;
            tempProject= NULL;
        }
    }
    gpeProjects.clear();

    if( previousScreenshot!=NULL)
    {
        delete previousScreenshot;
        previousScreenshot = NULL;
    }

    if( mainToolBar!=NULL)
    {
        delete mainToolBar;
        mainToolBar = NULL;
    }

    if( mainResourceBar!=NULL)
    {
        delete mainResourceBar;
        mainResourceBar = NULL;
    }

    if( GPE_MAIN_TEMPLATE!=NULL)
    {
        delete GPE_MAIN_TEMPLATE;
        GPE_MAIN_TEMPLATE = NULL;
    }

    if( MAIN_CONTEXT_MENU!=NULL)
    {
        delete MAIN_CONTEXT_MENU;
        MAIN_CONTEXT_MENU = NULL;
    }
    if(GPE_Main_TabManager!=NULL)
    {
        delete GPE_Main_TabManager;
        GPE_Main_TabManager = NULL;
    }
    if(GPE_Main_Logs!=NULL)
    {
        delete GPE_Main_Logs;
        GPE_Main_Logs = NULL;
    }
    if(GPE_Cursor!=NULL)
    {
        SDL_FreeCursor(GPE_Cursor);
        GPE_Cursor = NULL;
    }
    if(GPE_LoadingCursor!=NULL)
    {
        SDL_FreeCursor(GPE_LoadingCursor);
        GPE_LoadingCursor = NULL;
    }
    if(GPE_HoverCursor!=NULL)
    {
        SDL_FreeCursor(GPE_HoverCursor);
        GPE_HoverCursor = NULL;
    }
    if( toolTipTexture!=NULL)
    {
        delete toolTipTexture;
        toolTipTexture = NULL;
    }
    if( GPE_TEXTURE_COLOR_PICKER_GRADIENT!=NULL)
    {
        delete GPE_TEXTURE_COLOR_PICKER_GRADIENT;
        GPE_TEXTURE_COLOR_PICKER_GRADIENT = NULL;
    }
    if( GPE_SURFACE_COLOR_PICKER_GRADIENT!=NULL)
    {
        SDL_FreeSurface(GPE_SURFACE_COLOR_PICKER_GRADIENT);
        GPE_SURFACE_COLOR_PICKER_GRADIENT = NULL;
    }
    if( GPE_LOGO!=NULL)
    {
        delete GPE_LOGO;
        GPE_LOGO = NULL;
    }

    if( findTextStringBox!=NULL)
    {
        delete findTextStringBox;
        findTextStringBox = NULL;
    }
    if( goToLineStringBox!=NULL)
    {
        delete findTextStringBox;
        goToLineStringBox = NULL;
    }
    if( replaceTextStringBox!=NULL)
    {
        delete replaceTextStringBox;
        replaceTextStringBox = NULL;
    }
    if( findButton!=NULL)
    {
        delete findButton;
        findButton = NULL;
    }
    if( scopeLabel!=NULL)
    {
        delete scopeLabel;
        scopeLabel = NULL;
    }
    if( findScope!=NULL)
    {
        delete findScope;
        findScope = NULL;
    }

    if( findAllButton!=NULL)
    {
        delete findAllButton;
        findAllButton = NULL;
    }
    if( goToButton!=NULL)
    {
        delete goToButton;
        goToButton = NULL;
    }
    if( replaceButton!=NULL)
    {
        delete replaceButton;
        replaceButton = NULL;
    }
    if( replaceAllButton!=NULL)
    {
        delete replaceAllButton;
        replaceAllButton = NULL;
    }
    if( findMatchCase!=NULL)
    {
        delete findMatchCase;
        findMatchCase = NULL;
    }
}

void GPE_Gui_Engine::add_to_recent_project_list(std::string newProjectFileName, bool saveData)
{
    int cSize = (int)gpeRecentProjects.size();
    int i = 0;
    if( (int)newProjectFileName.size() > 0 )
    {
        cSize = (int)gpeRecentProjects.size();
        for(  i = cSize-1; i >=0; i--)
        {
            if( gpeRecentProjects[i]==newProjectFileName)
            {
                gpeRecentProjects.erase( gpeRecentProjects.begin()+i);
            }
        }
        cSize = (int)gpeRecentProjects.size();
        if( cSize >= 15)
        {
            int cDiff = cSize - 14;
            for(  i = cSize-1; i >=cDiff; i--)
            {
                gpeRecentProjects.erase( gpeRecentProjects.begin()+i);
            }
        }
        gpeRecentProjects.insert(gpeRecentProjects.begin(),newProjectFileName);
        record_error("Added ["+newProjectFileName+"] to Recent Project List");
    }
    if( saveData)
    {
        cSize = (int)gpeRecentProjects.size();
        std::string recentFileListFileName = get_user_settings_folder()+"recent_projects.txt";
        std::ofstream recentFileListFile( recentFileListFileName.c_str() );
        if( !recentFileListFile.fail() )
        {
            //makes sure the file is open
            if (recentFileListFile.is_open())
            {
                for( i = cSize-1; i>=0; i--)
                {
                    recentFileListFile << gpeRecentProjects[i] <<  "\n";
                }
                if( CURRENT_PROJECT!=NULL)
                {
                    recentFileListFile << CURRENT_PROJECT->get_project_file_name() <<  "\n";
                }
                recentFileListFile.close();
            }
        }
    }
    update_recent_project_list(false);
}

void GPE_Gui_Engine::apply_logic()
{
    highlightedTerm = NULL;
    suggestedCompilerTerms.clear();
    //always resetting the tooltip
    if( userInput->input_received() )
    {
        update_tooltip("");
        update_popup_info();
    }
    process_window_title();

    if( mainToolBar!=NULL && MAIN_CONTEXT_MENU!=NULL)
    {
        //all other gui elements are dependent on the toolbar and popup menus being closed
        if( !MAIN_CONTEXT_MENU->is_open() )
        {
            //prevents the toolbar isnt activated when popup menu is open
            mainToolBar->process_toolbar();
        }
        mainResourceBar->resourcebarMoved = false;

        if( !mainToolBar->is_open() )
        {
            //prevents the popup menu from being processed while toolbar is open
            if( MAIN_CONTEXT_MENU->is_open() )
            {
                //POPUP_MENU_VALUE = MAIN_CONTEXT_MENU->process_menu_option();
                //if( userInput->check_mouse_released(kb_anykey) || WINDOW_WAS_JUST_RESIZED || userInput->released[ESC] || userInput->released[kb_enter])
                {
                    GPE_close_context_menu();
                }
            }
        }
        if( !mainToolBar->is_open() && !MAIN_CONTEXT_MENU->is_open() )
        {
            if( GPE_Main_Logs!=NULL)
            {
                GPE_Main_Logs->process_self();
                if( GPE_Main_Logs->justResized)
                {
                    userInput->reset_all_input();
                    currentState->process_input();
                    GPE_Main_Logs->justResized = false;
                    apply_logic();
                    return;
                }
            }
            if( GPE_Main_Statusbar!=NULL)
            {
                GPE_Main_Statusbar->process_self();
            }
            if( GPE_Main_Logs->isVisible && GPE_Main_Logs->beingResized==false)
            {
                if( mainResourceBar!=NULL)
                {
                    mainResourceBar->process_managementbar();

                    if( mainResourceBar->justResized)
                    {
                        userInput->reset_all_input();
                        currentState->process_input();
                        mainResourceBar->justResized = false;
                        apply_logic();
                        return;
                    }
                }
                if( GPE_Main_TabManager!=NULL)
                {
                    GPE_Main_TabManager->process_tabbar();
                }
            }
        }
    }
    process_overlay_message();

    if( userInput->check_keyboard_down(kb_ctrl) )
    {
        if( userInput->check_keyboard_released(kb_b) )
        {
            GPE_Main_TabManager->add_new_tab(MAIN_ABOUT_PAGE);
        }
        else if( userInput->pressed[kb_f])
        {
            if( userInput->down[kb_shift] )
            {
                GPE_MAIN_GUI->textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_FINDALL;

            }
            else
            {
                GPE_MAIN_GUI->textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_FIND;
            }
            GPE_MAIN_GUI->findTextStringBox->switch_inuse( true);
            if( GPE_Main_Logs!=NULL)
            {
                GPE_Main_Logs->open_search_mode();
            }
        }
        else if( userInput->pressed[kb_g])
        {
            GPE_MAIN_GUI->textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_GOTO;
            GPE_MAIN_GUI->goToLineStringBox->set_string("1");
            GPE_MAIN_GUI->goToLineStringBox->switch_inuse(true);
            if( GPE_Main_Logs!=NULL)
            {
                GPE_Main_Logs->open_search_mode();
            }
        }
        else if( userInput->pressed[kb_h])
        {
            GPE_MAIN_GUI->textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_REPLACE;
            GPE_MAIN_GUI->findTextStringBox->switch_inuse( true );
            if( GPE_Main_Logs!=NULL)
            {
                GPE_Main_Logs->open_replace_mode();
            }
        }
        else if( userInput->check_keyboard_released(kb_n) )
        {
            launch_new_project();
        }
        else if( userInput->check_keyboard_released(kb_o) )
        {
            open_new_project();
        }
        else if( userInput->check_keyboard_released(kb_q) )
        {
            GPE_Action_Message=="Quit Editor";
            userInput->done = true;
        }
        else if( userInput->pressed[kb_r])
        {
            if( userInput->down[kb_shift] )
            {
                GPE_MAIN_GUI->textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_REPLACEALL;

            }
            else
            {
                GPE_MAIN_GUI->textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_REPLACE;

            }
            GPE_MAIN_GUI->findTextStringBox->switch_inuse( true);
            if( GPE_Main_Logs!=NULL)
            {
                GPE_Main_Logs->open_replace_mode();
            }
        }
        else if( userInput->check_keyboard_released(kb_s) )
        {
            if( userInput->check_keyboard_down(kb_shift) )
            {
                save_all_projects();
            }
            else
            {
                save_current_project();
            }
        }
        else if( userInput->check_keyboard_released(kb_u) )
        {
            GPE_Main_TabManager->add_new_tab(MAIN_EDITOR_SETTINGS);
        }
    }
    else if( userInput->check_keyboard_released(kb_ctrl) ||
            userInput->check_keyboard_released(kb_f) )
    {
        GPE_Main_TabManager->add_new_tab(MAIN_HELP_PAGE);
    }
    else if( userInput->check_keyboard_released(kb_application) ||
            userInput->check_keyboard_released(kb_comma) )
    {
        GPE_Main_TabManager->add_new_tab(MAIN_EDITOR_SETTINGS);
    }
    else if( userInput->check_keyboard_released(kb_application) ||
            userInput->check_keyboard_released(kb_r) )
    {
        GPE_MAIN_GUI->export_current_project_html5( userInput->check_keyboard_down(kb_ctrl)==false );
    }
    if( userInput->check_keyboard_released(kb_application) ||
        userInput->check_keyboard_released(kb_ctrl) ||
        userInput->check_keyboard_released(kb_p) )
    {
        GPE_Main_TabManager->add_new_tab(MAIN_START_PAGE);
    }
    else if( userInput->check_keyboard_released(kb_f8) && CURRENT_PROJECT!=NULL )
    {
        GPE_MAIN_GUI->rum_current_project("",GPE_BUILD_HTML5);
    }
    else if( userInput->check_keyboard_released(kb_ctrl) ||
            userInput->check_keyboard_released(kb_application) || 
            userInput->check_keyboard_released(kb_f) )
    {
        if( !MAIN_RENDERER->is_fullscreen() )
        {
            update_temporary_message("Entering Full-Screen","Press [CTRL - CMD - F] to exit","",1);
        }
        else
        {
            update_temporary_message("Exiting Full-Screen","Press [CTRL - CMD - F] to toggle","",1);
        }
        MAIN_RENDERER->toggle_fullscreen();
    }
    if( userInput->check_keyboard_released(kb_f12) )
    {
        GPE_MAIN_GUI->take_live_screenshor(MAIN_RENDERER);
    }
    else if( userInput->check_keyboard_released(kb_esc) )
    {
        close_finder();
    }

    int uInS = userInput->fileDroppedList.size();
    std::string tempInputtedFile = "";
    if( uInS > 0)
    {
        for( int iRFile = 0; iRFile < uInS; iRFile++)
        {
            tempInputtedFile = userInput->fileDroppedList.at( iRFile);
            if( file_exists(tempInputtedFile) )
            {
                if( get_file_ext(tempInputtedFile)=="gppf" )
                {
                    open_project(tempInputtedFile);
                }
                else
                {
                    display_user_alert("Error","Content dropped in window:"+tempInputtedFile+".");
                }
            }
            else
            {
                display_user_alert("Error","Content dropped in window:"+tempInputtedFile+" file not found.");
            }
        }
    }
    if( userInput->check_mouse_released(-1) )
    {
        RESOURCE_TO_DRAG = NULL;
        LAST_CLICKED_RESOURCE = NULL;
    }
    //If the user has Xed out the window
    if( MAIN_RENDERER->windowClosed || userInput->done || GPE_Action_Message=="Quit Editor" || GPE_Action_Message=="Quit")
    {
        if( (int)gpeProjects.size() > 0)
        {
            int returnedAction = -1;
            int projectAction = -1;
            GPE_ProjectFolder * tempProjFolder;
            for( int i= (int)gpeProjects.size()-1; i>=0; i--)
            {
                tempProjFolder = gpeProjects[i];
                if( tempProjFolder!=NULL)
                {
                    projectAction = display_get_prompt("[Warning!] "+tempProjFolder->get_project_name()+" project not saved","Will you like to save and close before exiting?",true);
                    if( projectAction==DISPLAY_QUERY_YES)
                    {
                        tempProjFolder->save_project();
                    }
                    else if( projectAction==DISPLAY_QUERY_CANCEL)
                    {
                        returnedAction = 2;
                        userInput->done = true;
                        MAIN_RENDERER->windowClosed = false;
                    }
                }
            }
            if( returnedAction!=2)
            {
                //Quit the programs
                set_next_state( STATE_EXIT );
            }
        }
        else
        {
            //Quit the programs
            set_next_state( STATE_EXIT );
        }
    }
}


GPE_Toolbar * GPE_Gui_Engine::init_toolbar()
{
    if( mainToolBar!=NULL)
    {
        delete mainToolBar;
    }
    mainToolBar = new GPE_Toolbar();
    return mainToolBar;
}

int GPE_Gui_Engine::get_recent_project_list_size()
{
    return (int)gpeRecentProjects.size();
}

int GPE_Gui_Engine::get_tip_count()
{
    return (int)gpeTips.size();
}

int GPE_Gui_Engine::get_random_tip()
{
    return random(0, (int)gpeTips.size()-1);
}

int GPE_Gui_Engine::get_previous_tip(int tipId)
{
    if( tipId >0 && tipId < (int)gpeTips.size() )
    {
        return tipId-1;
    }
    else
    {
        return (int)gpeTips.size()-1;
    }
}

int GPE_Gui_Engine::get_next_tip(int tipId)
{
    if( tipId >=0 && tipId < (int)gpeTips.size()-1 )
    {
        return tipId+1;
    }
    else
    {
        return 0;
    }
}

std::string GPE_Gui_Engine::get_tip(int tipId)
{
    if( tipId >=0 && tipId < (int)gpeTips.size() )
    {
        return gpeTips.at(tipId);
    }
    else
    {
        tipId = 0;
        if( (int)gpeTips.size() > 0)
        {
            return gpeTips.at(tipId);
        }
    }
    return "";
}

std::string GPE_Gui_Engine::get_recent_project_name( int pId )
{
    if( pId >=0 && pId < (int)gpeRecentProjects.size() )
    {
        return gpeRecentProjects.at(pId);
    }
    return "";
}

GPE_ResourceManagementBar * GPE_Gui_Engine::init_resourcebar()
{
    if( mainResourceBar!=NULL)
    {
        delete mainResourceBar;
        mainResourceBar = NULL;
    }
    mainResourceBar = new GPE_ResourceManagementBar();

    //update the tabbar and resourcemenu
    if( GPE_Main_TabManager!=NULL)
    {
        GPE_Main_TabManager->set_width(SCREEN_WIDTH-mainResourceBar->get_width());
        if( RENDER_RESOURCEBAR_LEFT)
        {
            mainResourceBar->set_coords(0,32+16);
            GPE_Main_TabManager->set_coords( mainResourceBar->get_x2pos(),32+16);
        }
        else
        {
            GPE_Main_TabManager->set_coords( 0,32+16);
            mainResourceBar->set_coords(GPE_Main_TabManager->get_x2pos(),32+16);
        }
    }
    return mainResourceBar;

}

GPE_Toolbar * GPE_Gui_Engine::init_toolbar(std::string bName,SDL_Rect bRect)
{
    if( mainToolBar!=NULL)
    {
        delete mainToolBar;
    }
    mainToolBar = new GPE_Toolbar(bName,bRect);
    return mainToolBar;
}

GPE_ProjectFolder * GPE_Gui_Engine::find_project_from_name(std::string projectName)
{
    if( (int)projectName.size()> 0)
    {
        GPE_ProjectFolder * tPFolder = NULL;
        GPE_ProjectFolder * foundProject = NULL;
        int i = 0;
        for( i = 0; i < (int)gpeProjects.size(); i++ )
        {
            tPFolder = gpeProjects[i];
            if( tPFolder!=NULL)
            {
                if( tPFolder->get_project_name().compare(projectName)==0 )
                {
                    foundProject = tPFolder;
                    break;
                }
            }
        }
        if( foundProject==NULL)
        {
            for( i = 0; i < (int)gpeProjects.size(); i++ )
            {
                tPFolder = gpeProjects[i];
                if( tPFolder!=NULL)
                {
                    if( tPFolder->get_project_file_name().compare(projectName)==0 )
                    {
                        foundProject = tPFolder;
                        break;
                    }
                }
            }
        }
        return foundProject;
    }
    return NULL;
}

GPE_ProjectFolder *  GPE_Gui_Engine::find_project_from_filename(std::string projectFileName)
{
    if( (int)projectFileName.size()> 0)
    {
        GPE_ProjectFolder * tPFolder = NULL;
        GPE_ProjectFolder * foundProject = NULL;
        for( int i = 0; i < (int)gpeProjects.size(); i++ )
        {
            tPFolder = gpeProjects[i];
            if( tPFolder!=NULL)
            {
                if( tPFolder->get_project_file_name().compare(projectFileName)==0 )
                {
                    foundProject = tPFolder;
                }
            }
        }
        return foundProject;
    }
    return NULL;
}

void GPE_Gui_Engine::clean_current_project_build_folder(int buildMetaTemplate)
{
    GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
    if( fFolder!=NULL)
    {
        fFolder->clean_build_folder(buildMetaTemplate);
    }
}

void GPE_Gui_Engine::clear_recent_project_list()
{
    gpeRecentProjects.clear();
    std::string recentFileListFileName = get_user_settings_folder()+"recent_projects.txt";
    std::ofstream recentFileListFile( recentFileListFileName.c_str() );
    recentFileListFile.close();
    update_recent_project_list(false);
}

void GPE_Gui_Engine::close_finder()
{
    if( textSearchMode >= SEARCH_MODE_FIND)
    {
        previousSearchMode = textSearchMode;
    }
    textSearchMode = -1;
    showFindAllResults = false;
}

void GPE_Gui_Engine::close_project(std::string projectFileName )
{
    remove_project( projectFileName);
}

int GPE_Gui_Engine::find_project_id_from_name(std::string projectName, int ignoreId)
{
    if( (int)projectName.size()> 0)
    {
        GPE_ProjectFolder * tPFolder = NULL;
        int foundProject = -1;
        for( int i = 0; i < (int)gpeProjects.size(); i++ )
        {
            if( i!=ignoreId)
            {
                tPFolder = gpeProjects[i];
                if( tPFolder!=NULL)
                {
                    if( tPFolder->get_project_name().compare(projectName)==0 )
                    {
                        foundProject = i;
                        break;
                    }
                }
            }
        }
        return foundProject;
    }
    return -1;
}

int GPE_Gui_Engine::find_project_id_from_filename(std::string projectFileName, int ignoreId)
{
    if( (int)projectFileName.size()> 0)
    {
        GPE_ProjectFolder * tPFolder = NULL;
        int foundProject = -1;
        for( int i = 0; i < (int)gpeProjects.size(); i++ )
        {
            if( i!=ignoreId)
            {
                tPFolder = gpeProjects[i];
                if( tPFolder!=NULL)
                {
                    if( tPFolder->get_project_file_name().compare(projectFileName)==0 )
                    {
                        foundProject = i;
                    }
                }
            }
        }
        return foundProject;
    }
    return -1;
}

GPE_Toolbar * GPE_Gui_Engine::get_main_toolbar()
{
    return mainToolBar;
}

void GPE_Gui_Engine::launch_new_project()
{
    bool exitOperation = false;
    bool manualCancel = false;

    std::string newProjectFileName = "";
    std::string newProjectName = "";
    std::string foundFileName = "";
    RESOURCE_TO_DRAG = NULL;
    if( GPE_MAIN_GUI!=NULL && MAIN_RENDERER!=NULL)
    {
        record_error("Launching New Project");
        std::string popUpCaption = "Launch New Project";
        GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
        GPE_MAIN_GUI->process_cursor();
        GPE_MAIN_GUI->reset_gui_info();
        GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);

        int promptBoxWidth = 544;
        int promptBoxHeight = 480;
        SDL_Rect barBox;


        userInput->reset_all_input();
        int currentTipId = GPE_MAIN_GUI->get_random_tip();
        if( currentTipId < 0 || currentTipId > GPE_MAIN_GUI->get_tip_count() )
        {
            currentTipId = 0;
        }
        std::string currentTipString = GPE_MAIN_GUI->get_tip(currentTipId);

        GPE_Label_Title * mainMenuLabel = new GPE_Label_Title("Create A Project?","Create A Project");
        GPE_Label_Text * projectLocationLabel = new GPE_Label_Text("Project Location:","Project Location:");
        GPE_Label_Text * projectNameLabel = new GPE_Label_Text("Project Name:","Project Name:");

        GPE_Label_Text * projectMainExportLabel = new GPE_Label_Text("Primary Export Target:","Primary Export Target:");
        GPE_Label_Text * projectMainLanguageLabel = new GPE_Label_Text("Programming Language:","Programming Language:");
        int biggerLabelSize = std::max( projectMainExportLabel->get_width(), projectMainLanguageLabel->get_width() );
        biggerLabelSize = std::max( biggerLabelSize, projectNameLabel->get_width() );
        projectMainExportLabel->set_width(biggerLabelSize);
        projectNameLabel->set_width(biggerLabelSize);
        projectMainLanguageLabel->set_width(biggerLabelSize);

        //Adds all available languages to drop down menu
        GPE_DropDown_Menu * newprojectLanguage = new GPE_DropDown_Menu(0,0,"Project Language",true);
        int addedLanguages = 0;
        if( GPE_MINI_COMPILER!=NULL && (int)GPE_MINI_COMPILER->editorLanguages.size() >=0 )
        {
            //short opertion so not "optimized"
            GPE_Gui_Engine_Language * tLanguage  = NULL;
            for( int cLanguage = 0; cLanguage < (int)GPE_MINI_COMPILER->editorLanguages.size(); cLanguage++ )
            {
                tLanguage = GPE_MINI_COMPILER->editorLanguages.at(cLanguage);
                if( tLanguage!=NULL && tLanguage->isCodingLanguage)
                {
                    newprojectLanguage->add_menu_option(tLanguage->languageName+" ("+tLanguage->languageShortName+")",tLanguage->languageShortName,cLanguage,true);
                    addedLanguages++;
                }
            }
        }
        //In the event something went wrong and we somehow didn't add JS and any other new coding language...
        if( addedLanguages == 0)
        {
            newprojectLanguage->add_menu_option("JavaScript(more coming soon)","JavaScript(more coming soon)",0,true);
        }


        GPE_DropDown_Menu * newprojectMainExport= new GPE_DropDown_Menu(0,0,"Main Export Target",true);
        newprojectMainExport->add_menu_option("HTML5","HTML5",GPE_BUILD_HTML5,true);
        newprojectMainExport->add_menu_option("WINDOWS","WINDOWS", GPE_BUILD_WINDOWS);
        newprojectMainExport->add_menu_option("MAC","MAC",GPE_BUILD_MAC);
        newprojectMainExport->add_menu_option("LINUX","LINUX",GPE_BUILD_LINUX);


        GPE_GuiElementList * showTipList = new GPE_GuiElementList();
        GPE_TextInputBasic * projectNameField = new GPE_TextInputBasic("","New Project");
        GPE_TextInputBasic * fileToCreateField = NULL;
        if( path_exists(GPE_MAIN_GUI->fileOpenProjectDir) )
        {
            fileToCreateField = new GPE_TextInputBasic("",GPE_MAIN_GUI->fileOpenProjectDir+"/example.gppf");
        }
        else if( GPE_FOUND_OS==GPE_IDE_WINDOWS)
        {
            fileToCreateField = new GPE_TextInputBasic("",APP_DIRECTORY_NAME+"/examples/example.gppf");
        }
        else
        {
            fileToCreateField = new GPE_TextInputBasic("","filename");
        }
        GPE_ToolLabelButton * closeButton = new GPE_ToolLabelButton(0,16,"Cancel","Cancel");
        GPE_ToolLabelButton * createButton = new GPE_ToolLabelButton(0,16,"Create","Create");
        GPE_Label_Error * projectCreateErrorLabel = new GPE_Label_Error("","");
        GPE_ToolLabelButton * fileFindButton = new GPE_ToolLabelButton(0,16,"Browse...","Browse...");
        GPE_ToolLabelButton * previousTipButton = new GPE_ToolLabelButton(0,16,"Previous Tip","");
        GPE_CheckBoxBasic * showAtStartUpButton = new GPE_CheckBoxBasic("Show tips at startup","Unclick to not see this popup automatically on start");
        showAtStartUpButton->set_clicked( GPE_MAIN_GUI->showTipsAtStartUp);
        GPE_ToolLabelButton * randomTipButton = new GPE_ToolLabelButton(0,16,"Random Tip","");
        GPE_WrappedTextArea * tipParagraph = new GPE_WrappedTextArea();
        tipParagraph->set_string(currentTipString);
        tipParagraph->set_width(512-GENERAL_GPE_PADDING*2);
        tipParagraph->set_height(96);
        SDL_RenderSetViewport(MAIN_RENDERER->get_renderer() ,NULL);
        //GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
        while(exitOperation==false)
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
            //record_error("Processing tip of the day");
            //Start the frame timer
            capTimer->start();
            //gets user input
            userInput->handle(true,true);

            barBox.x = (SCREEN_WIDTH-promptBoxWidth)/2;
            barBox.y = (SCREEN_HEIGHT-promptBoxHeight)/2;
            barBox.w = promptBoxWidth;
            barBox.h = promptBoxHeight;
            showTipList->set_coords(barBox.x, barBox.y+32);
            showTipList->set_width(barBox.w);
            showTipList->set_height(barBox.h-32);
            showTipList->barXMargin = GENERAL_GPE_PADDING;
            showTipList->barYMargin = GENERAL_GPE_PADDING;
            showTipList->barXPadding = GENERAL_GPE_PADDING*2;
            showTipList->barYPadding = GENERAL_GPE_PADDING*2;

            GPE_MAIN_GUI->reset_gui_info();
            showTipList->clear_list();
            showTipList->add_gui_element(mainMenuLabel,true);

            showTipList->add_gui_element(projectLocationLabel,true);
            showTipList->add_gui_element(fileToCreateField,false);
            showTipList->add_gui_element(fileFindButton, true);

            showTipList->add_gui_element(projectNameLabel,false);
            showTipList->add_gui_element(projectNameField,true);

            showTipList->add_gui_element(projectMainExportLabel, false);
            showTipList->add_gui_element(newprojectMainExport, true);

            showTipList->add_gui_element(projectMainLanguageLabel, false);
            showTipList->add_gui_element(newprojectLanguage, true);

            showTipList->add_gui_element(projectCreateErrorLabel, true);
            showTipList->add_gui_element(createButton,false);
            showTipList->add_gui_element(closeButton,false);
            showTipList->process_self(&camera,&camera);
            if( userInput->check_keyboard_released(kb_esc) || closeButton->is_clicked() )
            {
                exitOperation = true;
                manualCancel = true;
            }
            else if( createButton->is_clicked() )
            {
                newProjectName = projectNameField->get_string();
                if( (int)newProjectName.size() > 0 )
                {
                    if( is_alnum(newProjectName,true, true) )
                    {
                        if( path_exists( get_path_from_file(newProjectFileName)  ) )
                        {
                            manualCancel = false;
                            exitOperation = true;
                        }
                        else if( (int)newProjectFileName.size() > 0 )
                        {
                            projectCreateErrorLabel->set_name("Empty path given...");
                        }
                        else
                        {
                            projectCreateErrorLabel->set_name("Path does not exist...");
                        }
                    }
                    else
                    {
                        projectCreateErrorLabel->set_name("Project Name must be alphanumeric...");
                    }
                }
                else
                {
                    projectCreateErrorLabel->set_name("Empty project name given...");
                }
            }
            else if( fileFindButton->is_clicked() )
            {
                foundFileName = GPE_GetSaveFileName("Create a New Project File","Game Pencil Projects",GPE_MAIN_GUI->fileOpenProjectDir);
                if( (int)foundFileName.size() > 0 )
                {
                    newProjectFileName = foundFileName;
                    fileToCreateField->set_string(foundFileName);
                }
            }


            calculate_avg_fps();
            //record_error("Rendering tip of the day");
            SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
            if( !WINDOW_WAS_JUST_RESIZED)
            {
                //if( userInput->windowEventHappendInFrame )
                {
                    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
                }
                //Update screen
                render_rectangle(MAIN_RENDERER,barBox.x-4,barBox.y-4,barBox.x+barBox.w+8,barBox.y+barBox.h+8,c_blgray,false,64);
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);

                render_rectangle(MAIN_RENDERER,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+32,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,true);
                render_new_text(MAIN_RENDERER,barBox.x+barBox.w/2,barBox.y+GENERAL_GPE_PADDING,popUpCaption,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,DEFAULT_FONT,FA_CENTER,FA_TOP);
                showTipList->render_self(MAIN_RENDERER,&camera, &camera);
                //GPE_MAIN_GUI-render_gui_info(MAIN_RENDERER, true);

                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
                GPE_MAIN_GUI->process_cursor();
                GPE_MAIN_GUI->render_gui_info(MAIN_RENDERER, true);
                MAIN_RENDERER->update_renderer();
            }
            cap_fps();
        }
        if( showTipList!=NULL)
        {
            delete showTipList;
            showTipList = NULL;
        }

        if( mainMenuLabel!=NULL)
        {
            delete mainMenuLabel;
            mainMenuLabel = NULL;
        }
        if( newprojectMainExport!=NULL)
        {
            delete newprojectMainExport;
            newprojectMainExport = NULL;
        }
        if( projectMainExportLabel!=NULL)
        {
            delete projectMainExportLabel;
            projectMainExportLabel = NULL;
        }
        if( newprojectLanguage!=NULL)
        {
            delete newprojectLanguage;
            newprojectLanguage = NULL;
        }
        if( projectMainLanguageLabel!=NULL)
        {
            delete projectMainLanguageLabel;
            projectMainLanguageLabel = NULL;
        }
        if( projectLocationLabel!=NULL)
        {
            delete projectLocationLabel;
            projectLocationLabel = NULL;
        }
        if( fileToCreateField!=NULL)
        {
            delete fileToCreateField;
            fileToCreateField = NULL;
        }
        if( closeButton!=NULL)
        {
            delete closeButton;
            closeButton = NULL;
        }
        if( fileFindButton!=NULL)
        {
            delete fileFindButton;
            fileFindButton = NULL;
        }
        if( previousTipButton!=NULL)
        {
            delete previousTipButton;
            previousTipButton = NULL;
        }
        if( randomTipButton!=NULL)
        {
            delete randomTipButton;
            randomTipButton = NULL;
        }
        if( showAtStartUpButton!=NULL)
        {
            GPE_MAIN_GUI->showTipsAtStartUp = showAtStartUpButton->is_clicked();
            GPE_MAIN_GUI->save_settings();
            delete showAtStartUpButton;
            showAtStartUpButton = NULL;
        }
        if( tipParagraph!=NULL)
        {
            delete tipParagraph;
            tipParagraph = NULL;
        }
    }
    userInput->reset_all_input();
    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
    MAIN_RENDERER->update_renderer();

    if( (int)newProjectFileName.size()> 0 )
    {
        GPE_ProjectFolder * tPFolder = find_project_from_filename(newProjectFileName);
        if(tPFolder==NULL)
        {
            std::string newProjectDir= get_path_from_file(newProjectFileName);
            std::string newProjectLocalFileName = get_local_from_global_file(newProjectFileName);
            if( (int)newProjectLocalFileName.size()>0 )
            {
                std::string newProjectTitle = get_file_noext(newProjectLocalFileName);
                if( (int)newProjectTitle.size() > 0)
                {
                    newProjectFileName = newProjectDir+"/"+newProjectTitle+".gppf";
                    newProjectDir = newProjectDir+"/"+newProjectTitle;
                    setup_project_directory(newProjectDir);
                    GPE_Main_Logs->log_general_line("Creating new Project["+newProjectName+"] at ["+newProjectFileName+"] location.");
                    GPE_ProjectFolder * newProject = new GPE_ProjectFolder(newProjectName,newProjectDir,newProjectFileName);
                    display_user_alert("Project Opened",newProjectFileName.c_str() );
                    gpeProjects.push_back(newProject);
                    newProject->save_project();
                }
            }
        }
    }
}

void GPE_Gui_Engine::load_tips()
{
    gpeTips.clear();
    gpeTips.push_back("Save your projects often to avoid lost work or memory in the event of a malfunction or crash!");
    gpeTips.push_back("In the Scene Editor, by holding 'M' you are you able to place multiple-objects at once.");
    gpeTips.push_back("Use the [kb_ctrl] KEY plus mouse wheel to horizontally scroll areas.");
    gpeTips.push_back("Be sure to take a look at the documentation for learning to make the most of Game Pencil.");
    gpeTips.push_back("You can have multiple projects open at once.");
    gpeTips.push_back("You can indent / unindent blocks of text/code using the [TAB] and [kb_shift-TAB] keys respectively");
    gpeTips.push_back("Objects inherit variables and functions from their parents. Very helpful for larger projects.");
    gpeTips.push_back("Use the arrow keys in input fields to traverse through previous entries.");
    gpeTips.push_back("Use the shortcut [kb_ctrl]+[O] to open a project to edit.");

    gpeTips.push_back("You are able to remove the background color, grayscale and invert an image using the transform button in the Sprite, Texture and Tilesheet editors.");
    gpeTips.push_back("Use the project settings editor to edit vital meta-data for your projects.");
    gpeTips.push_back("Need help or resources for your game? Check out the new Asset Store at http://store.pawbyte.com .");
    gpeTips.push_back("You can create a duplicate of your selected text, by pressing [kb_ctrl]+[D] keys.");
    gpeTips.push_back("You are able to give your objects custom functions in the object editor.");
    gpeTips.push_back("Save your current project folder using [kb_ctrl]+[S] keys together.");
    gpeTips.push_back("Assets are copied from their source directory to their project folder.");
    gpeTips.push_back("You can close a tab by clicking it with the middle mouse button or simply clicking on the X-icon.");
    gpeTips.push_back("The Game Pencil Editor is made via the SDL Library and some keyboard shortcuts may not behave 'normally to you'. If you experience any inconveniences please email debug@pawbyte.com .");
    gpeTips.push_back("Save your projects often! There may be a few un-found errors in the  Game Pencil Engine and we will hate for a bug to be the cause of the loss of hours of work!");
    gpeTips.push_back("You can create a duplicate of the line the caret is on, by pressing [kb_ctrl]+[D] keys.");
    gpeTips.push_back("Version 1.1 of the GPE allows you to code in pure JavaScript.");
    gpeTips.push_back("You can add macros in your project's settings code editor.");
    gpeTips.push_back("You can debug your program using your web browser's console log.");
    gpeTips.push_back("You can save all open projects at once using the toolbar or buttonbar.");
    gpeTips.push_back("Project source code is provided free of obfuscation.");
    gpeTips.push_back("Use the shortcut [kb_ctrl]+[S] to save the current project you're editing.");
    gpeTips.push_back("You can get the most up to date documentation via http://docs.pawbyte.com");
}

void GPE_Gui_Engine::load_settings()
{
    displayMessageTitle = "Loading Gui Settings";
    displayMessageSubtitle = "Please Wait...";
    displayMessageString = "...";
    display_user_messaage();

    std::string otherColContainerName = "";

    std::string newFileIn = get_user_settings_folder()+"gpe_ide_settings.txt";
    std::ifstream gameResourceFileIn( newFileIn.c_str() );

    record_error("Loading settings - "+newFileIn);
    //If the level file could be loaded
    if( !gameResourceFileIn.fail() )
    {
        //makes sure the file is open
        if (gameResourceFileIn.is_open())
        {
            int equalPos = 0;
            std::string firstChar="";
            std::string section="";
            std::string cur_layer="";
            std::string data_format="";
            std::string keyString="";
            std::string valString="";
            std::string subValString="";
            std::string currLine="";
            std::string currLineToBeProcessed;
            std::string colorThemeName;
            float foundFileVersion = 0;
            while ( gameResourceFileIn.good() )
            {
                getline (gameResourceFileIn,currLine); //gets the next line of the file
                currLineToBeProcessed = trim_left_inplace(currLine);
                currLineToBeProcessed = trim_right_inplace(currLineToBeProcessed);

                if( foundFileVersion <=0)
                {
                    //Empty Line skipping is only allowed at the top of the file
                    if(!currLineToBeProcessed.empty() )
                    {
                        //Comment skipping is only allowed at the top of the file
                        if( currLineToBeProcessed[0]!= '#' && currLineToBeProcessed[0]!='/'  )
                        {
                            //searches for an equal character and parses through the variable
                            equalPos=currLineToBeProcessed.find_first_of("=");
                            if(equalPos!=(int)std::string::npos)
                            {
                                //if the equalPos is present, then parse on through and carryon
                                keyString = currLineToBeProcessed.substr(0,equalPos);
                                valString = currLineToBeProcessed.substr(equalPos+1,currLineToBeProcessed.length());
                                if( keyString=="Version")
                                {
                                    foundFileVersion = string_to_double(valString);
                                }
                            }
                        }
                    }
                }
                else if( foundFileVersion < 2)
                {
                    //Begin processing the file.
                    if(!currLineToBeProcessed.empty() )
                    {
                        equalPos=currLineToBeProcessed.find_first_of("=");
                        if(equalPos!=(int)std::string::npos)
                        {
                            //if the equalPos is present, then parse on through and carryon
                            keyString = currLineToBeProcessed.substr(0,equalPos);
                            valString = currLineToBeProcessed.substr(equalPos+1,currLineToBeProcessed.length());

                            if( keyString=="ResourceBarPosition")
                            {
                                if( is_bool(valString)==1)
                                {
                                    RENDER_RESOURCEBAR_LEFT = 1;
                                }
                                else
                                {
                                    RENDER_RESOURCEBAR_LEFT = 0;
                                }
                            }
                            else if( keyString=="ResourceBarVisible")
                            {
                                if( is_bool(valString)==0)
                                {
                                    if( mainResourceBar->is_visible()==true)
                                    {
                                        mainResourceBar->toggle_self();
                                    }
                                }
                                else if( mainResourceBar->is_visible()==false)
                                {
                                    mainResourceBar->toggle_self();
                                }
                            }
                            else if( keyString=="ReourceBarWidth")
                            {
                                mainResourceBar->set_width( string_to_int(valString,192) );
                            }
                            else if( keyString=="TextAreaViewLineCount")
                            {
                                showTextEditorLineCount = is_bool(valString);
                            }
                            else if( keyString=="TextAreaViewSynthaxHighlighting")
                            {
                                showTextEditorSynthaxHightlight =is_bool(valString);
                            }

                            else if(keyString=="ShowStartPageAtStart")
                            {
                                showStartPageAtStartUp =is_bool(valString);
                            }
                            else if(keyString=="ShowTipOfDayAtStart")
                            {
                                showTipsAtStartUp =is_bool(valString);
                                MAIN_EDITOR_SETTINGS->showStatupTipsBox->set_clicked(showTipsAtStartUp);
                            }
                            else if(keyString=="ColorTheme")
                            {
                                colorThemeName = valString;
                                if( file_exists(APP_DIRECTORY_NAME+"themes/"+colorThemeName) )
                                {
                                    if( colorThemeName=="light_theme.gpf")
                                    {
                                        GPE_MAIN_TEMPLATE = GPE_LIGHT_TEMPLATE;
                                        prerender_gui(MAIN_RENDERER);
                                    }
                                    else if( colorThemeName=="dark_theme.gpf")
                                    {
                                        GPE_MAIN_TEMPLATE = GPE_DARK_TEMPLATE;
                                        prerender_gui(MAIN_RENDERER);
                                    }
                                    else if( colorThemeName=="red_theme.gpf")
                                    {
                                        GPE_MAIN_TEMPLATE = GPE_RED_TEMPLATE;
                                        prerender_gui(MAIN_RENDERER);
                                    }
                                    else if( colorThemeName=="green_theme.gpf")
                                    {
                                        GPE_MAIN_TEMPLATE = GPE_GREEN_TEMPLATE;
                                        prerender_gui(MAIN_RENDERER);
                                    }
                                    else if( colorThemeName=="blue_theme.gpf")
                                    {
                                        GPE_MAIN_TEMPLATE = GPE_BLUE_TEMPLATE;
                                        prerender_gui(MAIN_RENDERER);
                                    }
                                    else
                                    {
                                        GPE_MAIN_TEMPLATE = GPE_CUSTOM_TEMPLATE;
                                        GPE_CUSTOM_TEMPLATE->load_theme(colorThemeName);
                                        prerender_gui(MAIN_RENDERER);
                                    }
                                }
                                else
                                {
                                    GPE_MAIN_TEMPLATE = GPE_DEFAULT_TEMPLATE;
                                    prerender_gui(MAIN_RENDERER);
                                }
                            }
                        }
                    }
                }
                else
                {
                    record_error("Invalid FoundFileVersion ="+double_to_string(foundFileVersion)+".");
                }
            }
        }
    }
}

void GPE_Gui_Engine::open_new_project()
{
    std::string newProjectFileName = GPE_GetOpenFileName("Load Your Project","Game Pencil Projects",fileOpenProjectDir);
    open_project( newProjectFileName);
}

void GPE_Gui_Engine::open_project(std::string newProjectFileName)
{
    if( (int)newProjectFileName.size()> 5 )
    {
        newProjectFileName = string_replace_all(newProjectFileName,"\\","/");
        std::string newProjectDir = get_file_noext(newProjectFileName);
        GPE_ProjectFolder * fFolder = find_project_from_filename( newProjectFileName );
        if( fFolder==NULL)
        {
            if( get_file_ext(newProjectFileName)=="gppf" )
            {
                if( file_exists(newProjectFileName) )
                {
                    GPE_Main_Logs->log_general_line("Opening Project ("+newProjectFileName+")...");
                    std::string previousProjectInView = CURRENT_PROJECT_NAME;
                    std::string newProjectTitle = "Loaded Project";
                    GPE_ProjectFolder * newProject = new GPE_ProjectFolder(newProjectTitle,newProjectDir,newProjectFileName);
                    CURRENT_PROJECT_NAME = newProjectFileName;
                    gpeProjects.push_back(newProject);
                    bool projectLoadedSuccessfuly = newProject->load_project_file(newProjectFileName);
                    if( projectLoadedSuccessfuly)
                    {
                        CURRENT_PROJECT_NAME = newProjectFileName;
                        CURRENT_PROJECT = newProject;
                        newProject->integrate_synthax();
                        record_error("Checking with project list: ["+newProject->get_project_name()+"].");;
                        add_to_recent_project_list(newProjectFileName,true );
                        record_error("Project added to GPE ["+newProject->get_project_name()+"]");
                        GPE_Main_Logs->log_general_line("Done.");
                    }
                    else
                    {
                        CURRENT_PROJECT_NAME = previousProjectInView;
                        CURRENT_PROJECT = newProject;
                        remove_project(newProjectFileName);
                    }
                }
                else
                {
                    display_user_alert("Project Open Error","File does not exist.");
                    GPE_Main_Logs->log_debug_line("Project Open Error - File does not exist ("+newProjectFileName+")...");
                }
            }
            else
            {
                display_user_alert("Project Open Error","Invalid Project File Type given.");
            }
        }
        else
        {
            //display_user_alert("Project Open Error","This project is already open!");
            display_user_alert("Project Open Error","This project is already open!");
        }
    }
}

bool GPE_Gui_Engine::overhead_used()
{
    if( tipTipJustUpdated)
    {
        return true;
    }
    return false;
}

void GPE_Gui_Engine::prerender_gui(GPE_Renderer * cRender)
{
    mainResourceBar->prerender_self(cRender);
    mainToolBar->prerender_self(cRender);
    MAIN_CONTEXT_MENU->prerender_self(cRender);
}

void GPE_Gui_Engine::process_cursor()
{
    if(GPE_CurrentCursor!=GPE_PreviousCursor)
    {
        if( GPE_Cursor!=NULL)
        {
            SDL_FreeCursor(GPE_Cursor);
            GPE_Cursor = NULL;
        }
        if(GPE_CurrentCursor<0)
        {
            GPE_Cursor = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_NO);
        }
        else
        {
            GPE_Cursor = SDL_CreateSystemCursor(GPE_CurrentCursor);
        }
        SDL_SetCursor(GPE_Cursor);
    }
    GPE_PreviousCursor = GPE_CurrentCursor;
}

void GPE_Gui_Engine::process_overlay_message()
{
    if( GPE_Action_Message=="Add Folder")
    {
        GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
        if( fFolder!=NULL)
        {
            std::string nFolderName = get_string_from_popup("Name Your Folder","Please enter the new name","newFolder" );
            if( (int)nFolderName.size()>0)
            {
                fFolder->create_blank_folder(LAST_CLICKED_RESOURCE, nFolderName);
            }
        }
    }
    else if( GPE_Action_Message=="Rename Folder" && LAST_CLICKED_RESOURCE!=NULL)
    {
        std::string nFolderName = get_string_from_popup("Rename Your Folder","Please enter the new name",LAST_CLICKED_RESOURCE->get_name() );
        if( (int)nFolderName.size()>0)
        {
            LAST_CLICKED_RESOURCE->set_name( nFolderName);
        }
    }
    else if( GPE_Action_Message=="Rename Resource" && LAST_CLICKED_RESOURCE!=NULL )
    {
        if( LAST_CLICKED_RESOURCE->get_resource_type()!=RESOURCE_TYPE_PROJECT_SETTINGS)
        {
            std::string nResName = get_string_from_popup("Name Your Resource","Please enter the new name",LAST_CLICKED_RESOURCE->get_name() );
            if( (int)nResName.size()>0)
            {
                LAST_CLICKED_RESOURCE->set_name(nResName);
            }
        }
    }
    else if( GPE_Action_Message=="Delete Folder" || GPE_Action_Message=="Remove Folder")
    {
        if( LAST_CLICKED_RESOURCE!=NULL && LAST_CLICKED_RESOURCE->parentResource!=NULL)
        {
            if( display_get_prompt("Warning","Are you sure you will like to delete this folder?")==DISPLAY_QUERY_YES)
            {
                GPE_ResourceContainer * parRes = LAST_CLICKED_RESOURCE->parentResource;
                parRes->delete_resource(LAST_CLICKED_RESOURCE);
                LAST_CLICKED_RESOURCE = NULL;
                RESOURCE_TO_DRAG = NULL;
            }
        }
    }
    else if( GPE_Action_Message=="Delete Resource" || GPE_Action_Message=="Remove Resource")
    {
        if( LAST_CLICKED_RESOURCE!=NULL && LAST_CLICKED_RESOURCE->parentResource!=NULL)
        {
            if( LAST_CLICKED_RESOURCE->get_resource_type()!=RESOURCE_TYPE_PROJECT_SETTINGS)
            {
                if( display_get_prompt("Warning","Are you sure you will like to delete this resource?")==DISPLAY_QUERY_YES)
                {
                    GPE_ResourceContainer * parRes = LAST_CLICKED_RESOURCE->parentResource;
                    if( parRes!=NULL)
                    {
                        parRes->delete_resource(LAST_CLICKED_RESOURCE);
                        LAST_CLICKED_RESOURCE = NULL;
                        RESOURCE_TO_DRAG = NULL;
                    }
                }
            }
        }
    }
    else if( GPE_Action_Message=="Find Resource..." || GPE_Action_Message=="Find Local Resource..." )
    {
        if( LAST_CLICKED_RESOURCE!=NULL && LAST_CLICKED_RESOURCE->get_resource_type()!=RESOURCE_TYPE_PROJECT_SETTINGS )
        {
            std::string resourceNeedle = get_string_from_popup("Project Resource Search","Resource name:","");
            if( (int)resourceNeedle.size() > 0 )
            {
                GPE_ResourceContainer * foundRes = LAST_CLICKED_RESOURCE->find_resource_from_name(resourceNeedle);
                if( foundRes!=NULL)
                {
                    generalGameResource * foundHeldRes = foundRes->get_held_resource();
                    if( GPE_Main_TabManager!=NULL && foundHeldRes!=NULL )
                    {
                        GPE_Main_TabManager->add_new_tab(foundHeldRes);
                    }
                }
            }
        }
    }
    else if( GPE_Action_Message=="Add Resource")
    {
        GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
        if( fFolder!=NULL)
        {
            int tempResType = LAST_CLICKED_RESOURCE->get_resource_type();
            GPE_ResourceContainer * newResource = fFolder->create_blank_resource(tempResType,LAST_CLICKED_RESOURCE);
            if( newResource!=NULL)
            {
                GPE_Main_TabManager->add_new_tab(newResource->get_held_resource() );
                GPE_MAIN_GUI->mainResourceBar->selectedSubOption = newResource->get_global_id();
            }
        }
    }
    else if( GPE_Action_Message=="Duplicate Resource" || GPE_Action_Message=="Clone Resource")
    {
        if( LAST_CLICKED_RESOURCE!=NULL && LAST_CLICKED_RESOURCE->parentResource!=NULL)
        {
            if( !LAST_CLICKED_RESOURCE->is_folder() && !LAST_CLICKED_RESOURCE->is_super_project_folder() && !LAST_CLICKED_RESOURCE->is_super_project_folder() )
            {
                int tempResType = LAST_CLICKED_RESOURCE->get_resource_type();

                if( tempResType!=RESOURCE_TYPE_TEXTURE && tempResType!=RESOURCE_TYPE_TILESHEET && tempResType!=RESOURCE_TYPE_SPRITE && tempResType!=RESOURCE_TYPE_AUDIO && tempResType!=RESOURCE_TYPE_VIDEO && tempResType!=RESOURCE_TYPE_PROJECT_SETTINGS )
                {
                    GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
                    if( fFolder!=NULL)
                    {
                        GPE_ResourceContainer * newResource = fFolder->create_blank_resource(LAST_CLICKED_RESOURCE->get_resource_type(),LAST_CLICKED_RESOURCE->parentResource,"copy_of_"+LAST_CLICKED_RESOURCE->get_name() );
                        if( newResource!=NULL)
                        {
                            LAST_CLICKED_RESOURCE->save_container(get_user_temp_folder()+"temp_duplicated_resource.gpf");
                            newResource->preprocess_container(get_user_temp_folder()+"temp_duplicated_resource.gpf");
                            newResource->detect_name_change(true);
                            GPE_Main_TabManager->add_new_tab(newResource->get_held_resource() );
                            GPE_MAIN_GUI->mainResourceBar->selectedSubOption = newResource->get_global_id();
                         }
                         else
                         {
                             record_error("Unable to duplicate resource - new resource is NULL...");
                         }
                    }
                    else
                    {
                        record_error("Unable to duplicate resource - Unable to find project for resource ");
                    }
                }
            }
            else
            {
                record_error("Unable to duplicate resource - Last clicked resource is a folder...");
            }
        }
        else
        {
            record_error("Unable to duplicate resource - Last Clicked Resource or is parent equals NULL.");
        }
    }
    else if( GPE_Action_Message=="Close Project")
    {
        GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
        if( fFolder!=NULL)
        {
            int projectSaveState = display_get_prompt("Project Warning(Recommended)","Will you like to save this project before closing(Recommended)?",true);

            if( projectSaveState==DISPLAY_QUERY_YES)
            {
                save_current_project();
            }
            if( projectSaveState!=DISPLAY_QUERY_CANCEL)
            {
                //Close the project
                std::string projectNameToDelete = fFolder->get_project_file_name();
                displayMessageTitle = "Closing Game Project";
                displayMessageSubtitle = projectNameToDelete;
                displayMessageString = "...";
                display_user_messaage();

                displayMessageTitle = "Closing Game Project";
                displayMessageSubtitle = projectNameToDelete;
                displayMessageString = "Closing Tabs";
                display_user_messaage();
                GPE_Main_TabManager->close_tabs_from_project( projectNameToDelete );

                displayMessageTitle = "Closing Game Project";
                displayMessageSubtitle = projectNameToDelete;
                displayMessageString = "Removing from Internal Data";
                display_user_messaage();
                remove_project(projectNameToDelete);
            }
        }
    }
    else if( GPE_Action_Message=="New Project")
    {
        launch_new_project();
    }
    else if( GPE_Action_Message=="Open Project")
    {
        open_new_project();
    }
    else if( GPE_Action_Message== "Open Project Directory" )
    {
        if( CURRENT_PROJECT!=NULL)
        {
            GPE_OpenProgram(CURRENT_PROJECT->get_project_directory() );
        }
    }
    else if( GPE_Action_Message=="Save Project")
    {
        save_current_project();
    }
    else if( GPE_Action_Message=="Save All Projects")
    {
        save_all_projects();
    }
    else if( GPE_Action_Message=="Build Project" || GPE_Action_Message=="Build GAME")
    {
        if( CURRENT_PROJECT!=NULL)
        {
            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
        }
    }
    else if( GPE_Action_Message=="Clean [HTML5] Build Folder")
    {
        if( CURRENT_PROJECT!=NULL)
        {
            CURRENT_PROJECT->clean_build_folder(GPE_BUILD_HTML5);
        }
    }
    else if( GPE_Action_Message=="Clean [WiiU] Build Folder")
    {
        if( CURRENT_PROJECT!=NULL)
        {
            CURRENT_PROJECT->clean_build_folder(GPE_BUILD_WIIU);
        }
    }
    else if( GPE_Action_Message=="Clean [Linux] Build Folder")
    {
        if( CURRENT_PROJECT!=NULL)
        {
            CURRENT_PROJECT->clean_build_folder(GPE_BUILD_LINUX);
        }
    }
    else if( GPE_Action_Message=="Clean [OSX] Build Folder")
    {
        if( CURRENT_PROJECT!=NULL)
        {
            CURRENT_PROJECT->clean_build_folder(GPE_BUILD_MAC);
        }
    }
    else if( GPE_Action_Message=="Build HTML5 APP" || GPE_Action_Message=="Build HTML5 GAME")
    {
        if( CURRENT_PROJECT!=NULL)
        {
            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
            tProjectProps->exportSettingsBar->set_selected_option("HTML5");
        }
    }
    else if( GPE_Action_Message=="Build HTML5 APP & RUN" || GPE_Action_Message=="Build HTML5 GAME & RUN")
    {
        if( CURRENT_PROJECT!=NULL)
        {
            /*
            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
            tProjectProps->exportSettingsBar->set_selected_option("HTML5");
            */
            GPE_MAIN_GUI->export_current_project_html5(true);
        }
    }
    else if(GPE_Action_Message=="RUN HTML5 GAME")
    {
        if( CURRENT_PROJECT!=NULL)
        {
            rum_current_project("",GPE_BUILD_HTML5);
        }
    }
    else if( GPE_Action_Message=="Build Nintendo Wii U GAME" || GPE_Action_Message=="Build NINTENDO Wii U" || GPE_Action_Message=="Build Wii U" || GPE_Action_Message=="Build WiiU")
    {
        if( CURRENT_PROJECT!=NULL && CURRENT_PROJECT->RESC_PROJECT_SETTINGS!=NULL )
        {
            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
            tProjectProps->exportSettingsBar->set_selected_option("WiiU");
        }
    }
    else if( GPE_Action_Message=="Build Nintendo Switch GAME")
    {
        if( CURRENT_PROJECT!=NULL && CURRENT_PROJECT->RESC_PROJECT_SETTINGS!=NULL )
        {
            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
            tProjectProps->exportSettingsBar->set_selected_option("Switch");
        }
    }
    else if( GPE_Action_Message=="Build WINDOWS GAME")
    {
        if( CURRENT_PROJECT!=NULL && CURRENT_PROJECT->RESC_PROJECT_SETTINGS!=NULL )
        {
            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
            tProjectProps->exportSettingsBar->set_selected_option("Windows");
        }
    }
    else if( GPE_Action_Message=="Build OSX GAME")
    {
        if( CURRENT_PROJECT!=NULL && CURRENT_PROJECT->RESC_PROJECT_SETTINGS!=NULL )
        {
            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
            tProjectProps->exportSettingsBar->set_selected_option("OSX");
        }
    }
    else if( GPE_Action_Message=="Build LINUX GAME")
    {
        if( CURRENT_PROJECT!=NULL && CURRENT_PROJECT->RESC_PROJECT_SETTINGS!=NULL )
        {
            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
            tProjectProps->exportSettingsBar->set_selected_option("Linux");
        }
    }
    else if( GPE_Action_Message=="Clean [HTML5] Build Folder")
    {
        clean_current_project_build_folder(GPE_BUILD_HTML5);
    }
    else if( GPE_Action_Message=="Clean [WiiU] Build Folder")
    {
        clean_current_project_build_folder(GPE_BUILD_WIIU);
    }
    else if( GPE_Action_Message=="Clean [Windows] Build Folder")
    {
        clean_current_project_build_folder( GPE_BUILD_WINDOWS );
    }
    else if( GPE_Action_Message=="Clean [OSX] Build Folder")
    {
        clean_current_project_build_folder( GPE_BUILD_MAC );
    }
    else if( GPE_Action_Message=="Clean [Linux] Build Folder")
    {
        clean_current_project_build_folder( GPE_BUILD_LINUX );
    }
    else if( GPE_Action_Message=="Online Documentation"|| GPE_Action_Message=="Documentation")
    {
        GPE_OpenURL("http://docs.pawbyte.com/");
    }
    else if( GPE_Action_Message=="EULA" || GPE_Action_Message=="License")
    {
        GPE_OpenURL("http://gamepencil.pawbyte.com/eula/");
    }
    else if( GPE_Action_Message=="Check Updates"|| GPE_Action_Message=="Check Version")
    {
        GPE_OpenURL("http://gamepencil.pawbyte.com/get-game-pencil-engine/");
    }

    else if( GPE_Action_Message=="Community" || GPE_Action_Message=="Online Forums" || GPE_Action_Message=="Community" || GPE_Action_Message=="Forums")
    {
        GPE_OpenURL("http://community.pawbyte.com/");
    }
    else if( GPE_Action_Message=="Community Chat")
    {
        GPE_OpenURL("https://discord.gg/aNX3Fcx");
    }
    else if( GPE_Action_Message=="Toggle Fullscreen Mode")
    {
        if( !MAIN_RENDERER->is_fullscreen() )
        {
            update_temporary_message("Entering Full-Screen","Press [F11] to exit","",1);
        }
        MAIN_RENDERER->toggle_fullscreen();
    }
    else if( GPE_Action_Message=="Clear Recent Projects List")
    {
        GPE_MAIN_GUI->clear_recent_project_list();
    }
    else if( GPE_Action_Message=="Toggle Resource Bar On/Off")
    {
        mainResourceBar->toggle_self();
        save_settings();
    }
    else if( GPE_Action_Message=="Left Align Resource Bar")
    {
        if( !RENDER_RESOURCEBAR_LEFT)
        {
            mainResourceBar->resourcebarMoved = true;
        }
        RENDER_RESOURCEBAR_LEFT = true;
        if( mainResourceBar->is_visible()==false)
        {
            mainResourceBar->toggle_self();
        }
        save_settings();
    }
    else if( GPE_Action_Message=="Right Align Resource Bar")
    {
        if( RENDER_RESOURCEBAR_LEFT)
        {
            mainResourceBar->resourcebarMoved = true;
        }
        RENDER_RESOURCEBAR_LEFT = false;
        if( mainResourceBar->is_visible()==false)
        {
            mainResourceBar->toggle_self();
        }
        save_settings();
    }
    else if( GPE_Action_Message=="Toggle Line Count")
    {
        showTextEditorLineCount = !showTextEditorLineCount;
        save_settings();
    }
    else if(GPE_Action_Message=="Toggle Synthax Highlighting")
    {
        showTextEditorSynthaxHightlight = !showTextEditorSynthaxHightlight;
        save_settings();
    }
    else if( GPE_Action_Message=="Use Light Color Theme")
    {
        GPE_MAIN_TEMPLATE = GPE_LIGHT_TEMPLATE;
        prerender_gui(MAIN_RENDERER);
        save_settings();
    }
    else if( GPE_Action_Message =="Find Themes on itch.io")
    {
        GPE_OpenURL("https://itch.io/game-assets/tag-gamepencil/tag-theme");
    }
    /*
    else if( GPE_Action_Message=="Use Dark Color Theme")
    {
        GPE_MAIN_TEMPLATE = GPE_DARK_TEMPLATE;
        prerender_gui(MAIN_RENDERER);
        save_settings();
    }
    else if( GPE_Action_Message=="Use Red Color Theme")
    {
        GPE_MAIN_TEMPLATE = GPE_RED_TEMPLATE;
        prerender_gui(MAIN_RENDERER);
        save_settings();
    }
    else if( GPE_Action_Message=="Use Green Color Theme")
    {
        GPE_MAIN_TEMPLATE = GPE_GREEN_TEMPLATE;
        prerender_gui(MAIN_RENDERER);
        save_settings();
    }
    else if( GPE_Action_Message=="Use Blue Color Theme")
    {
        GPE_MAIN_TEMPLATE = GPE_BLUE_TEMPLATE;
        prerender_gui(MAIN_RENDERER);
        save_settings();
    }*/
    else if( GPE_Action_Message=="Find...")
    {
        if( GPE_Main_Logs!=NULL)
        {
            GPE_Main_Logs->open_search_mode();
        }
        textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_FIND;
        findTextStringBox->switch_inuse( true);
    }
    else if( GPE_Action_Message=="Find in files...")
    {
        if( GPE_Main_Logs!=NULL)
        {
            GPE_Main_Logs->open_search_mode();
        }
        textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_FINDALL;
        findTextStringBox->switch_inuse( true);
    }
    else if( GPE_Action_Message=="Goto Line...")
    {
        textSearchMode = SEARCH_MODE_GOTO;
        goToLineStringBox->set_string("1");
        goToLineStringBox->switch_inuse(true);
        if( GPE_Main_Logs!=NULL)
        {
            GPE_Main_Logs->open_search_mode();
        }
    }
    else if( GPE_Action_Message=="Find Project Resource...")
    {
        if( CURRENT_PROJECT!=NULL&& CURRENT_PROJECT->RESC_PROJECT_FOLDER!=NULL)
        {
            std::string resourceNeedle = get_string_from_popup("Project Resource Search","Resource name:","");
            if( (int)resourceNeedle.size() > 0 )
            {
                GPE_ResourceContainer * foundRes = CURRENT_PROJECT->RESC_PROJECT_FOLDER->find_resource_from_name(resourceNeedle);
                if( foundRes!=NULL)
                {
                    generalGameResource * foundHeldRes = foundRes->get_held_resource();
                    if( GPE_Main_TabManager!=NULL && foundHeldRes!=NULL)
                    {
                        GPE_Main_TabManager->add_new_tab(foundHeldRes);
                    }
                }
            }
        }
    }
    else if( GPE_Action_Message=="Replace...")
    {
        GPE_MAIN_GUI->textSearchMode = GPE_MAIN_GUI->previousSearchMode = SEARCH_MODE_REPLACE;
        GPE_MAIN_GUI->findTextStringBox->switch_inuse( true );
        if( GPE_Main_Logs!=NULL)
        {
            GPE_Main_Logs->open_replace_mode();
        }
    }
    else if( GPE_Action_Message=="Use Default Color Theme")
    {
        GPE_MAIN_TEMPLATE = GPE_DEFAULT_TEMPLATE;
        prerender_gui(MAIN_RENDERER);
        save_settings();
    }
    else if( GPE_Action_Message=="Start Page")
    {
        GPE_Main_TabManager->add_new_tab(MAIN_START_PAGE);
    }
    else if( GPE_Action_Message=="Browse Projects" || GPE_Action_Message=="Project Browser" || GPE_Action_Message=="Use Project Browser" )
    {
        GPE_Main_TabManager->add_new_tab(PROJECT_BROWSER_PAGE);
    }
    else if( GPE_Action_Message=="Tip of the Day")
    {
        GPE_Show_Tip_Of_Day();
    }
    else if( GPE_Action_Message=="Report Issue")
    {
        GPE_Open_Support_Center();
        //GPE_OpenURL("https://gitlab.com/pawbyte/Game-Pencil-Engine");
    }
    else if( GPE_Action_Message=="About" || GPE_Action_Message=="About..." || GPE_Action_Message=="About Game Pencil Engine" )
    {
        GPE_Main_TabManager->add_new_tab(MAIN_ABOUT_PAGE);
    }
    else if( GPE_Action_Message=="Help" || GPE_Action_Message=="Help..." || GPE_Action_Message=="General Help"  )
    {
        GPE_Main_TabManager->add_new_tab(MAIN_HELP_PAGE);
    }
    else if( GPE_Action_Message=="User Settings" || GPE_Action_Message=="User Settings..." || GPE_Action_Message=="Game Pencil User Settings" )
    {
        GPE_Main_TabManager->add_new_tab(MAIN_EDITOR_SETTINGS);
    }
    else if( file_exists(GPE_Action_Message) )
    {
        if( get_file_ext(GPE_Action_Message)=="gppf")
        {
            open_project(GPE_Action_Message);
        }
    }
    else if( get_file_ext(GPE_Action_Message)=="gpf")
    {
        GPE_CUSTOM_TEMPLATE->load_theme("custom/"+GPE_Action_Message);
        GPE_MAIN_TEMPLATE = GPE_CUSTOM_TEMPLATE;
        prerender_gui(MAIN_RENDERER);
        save_settings();
    }
    else if( string_starts(GPE_Action_Message, "Import ") )
    {
        //Import Resources ImportResources
        if( CURRENT_PROJECT!=NULL)
        {
            std::string remainingType = get_substring(GPE_Action_Message, 7);
            int tempResType = 0;
            bool foundResType = false;
            for( int iResType = 0; iResType < res_type_count; iResType++ )
            {
                if( remainingType == RESOURCE_TYPE_NAMES[iResType] )
                {
                    foundResType = true;
                    tempResType = iResType;
                    break;
                }
            }

            if( foundResType )
            {
                std::string fileToImportName = GPE_GetOpenFileName( GPE_Action_Message,".gpf", GPE_MAIN_GUI->fileOpenImportFileDir );
                if( file_exists(fileToImportName) && get_file_ext(fileToImportName) =="gpf" )
                {
                    GPE_ResourceContainer * newResource = CURRENT_PROJECT->create_blank_resource(tempResType,NULL, get_file_noext(get_local_from_global_file( fileToImportName) ) );
                    if( newResource!=NULL)
                    {
                        GPE_Main_TabManager->add_new_tab(newResource->get_held_resource() );
                        newResource->preprocess_container(fileToImportName);
                        GPE_MAIN_GUI->mainResourceBar->selectedSubOption = newResource->get_global_id();
                        newResource->detect_name_change(true);
                    }
                    else
                    {
                        display_user_alert("Import file error","Unable to create new "+RESOURCE_TYPE_NAMES[tempResType]+" resource.");
                    }
                }
                else
                {
                    display_user_alert("Import file error","Unable to import file named ["+get_local_from_global_file(fileToImportName)+"]");
                }
            }
        }
    }
}

void GPE_Gui_Engine::process_window_title()
{
    if( MAIN_RENDERER!=NULL )
    {
        std::string windowCurrentTitle = "";
        if( CURRENT_PROJECT!=NULL)
        {
            windowCurrentTitle = CURRENT_PROJECT->get_project_name();
        }
        if( GPE_VERSION_UPDATE_NUMBER==0)
        {
            windowCurrentTitle+= "[Game Pencil Engine   "+double_to_string(GPE_VERSION_DOUBLE_NUMBER)+".0 -";
        }
        else
        {
            windowCurrentTitle+= "[Game Pencil Engine   "+double_to_string(GPE_VERSION_DOUBLE_NUMBER)+" -";
        }

        windowCurrentTitle+=" Deluxe Edition]";

        if( editorReleaseType==RELEASE_TYPE_ALPHA)
        {
            windowCurrentTitle+=" [Alpha]";
        }
        else if( editorReleaseType== RELEASE_TYPE_BETA)
        {
            windowCurrentTitle+=" [Beta]";
        }

        if( !MAIN_RENDERER->windowHasFocus)
        {
            windowCurrentTitle += " Out of Focus |";
        }
        if( !MAIN_RENDERER->windowHasMouse)
        {
            windowCurrentTitle += " Mouse Outside |";
        }
        MAIN_RENDERER->set_window_title(windowCurrentTitle);
    }
}

void GPE_Gui_Engine::render_code_highlights(GPE_Renderer * renderTarget,bool forceRedraw)
{
    if( highlightedTerm!=NULL)
    {
        if( renderTarget==NULL)
        {
            renderTarget = MAIN_RENDERER;
        }
        if( renderTarget==NULL)
        {
            return;
        }
        SDL_RenderSetViewport(renderTarget->get_renderer(),NULL);
        std::string fullPhraseToRender;
        std::string fullTermScope = highlightedTerm->termScope;
        if( (int)fullTermScope.size()>1 )
        {
            fullTermScope = "Scope: "+fullTermScope;
        }
        if( highlightedTerm->termType==CTERM_FUNCTION)
        {
            fullPhraseToRender = highlightedTerm->termFunctionReturnType+" "+highlightedTerm->termString+"("+highlightedTerm->get_parameters()+")";
        }
        else
        {
            fullPhraseToRender = highlightedTerm->termString;
        }

        int highlightedTermWidth  = 0, highlightedTermHeight =0;
        int widestStringSize = std::max( (int)fullPhraseToRender.size(), (int)highlightedTerm->termDescription.size() );
        widestStringSize = std::max( (int)fullTermScope.size(), widestStringSize);

        FONT_TEXTINPUT->get_metrics("A",&highlightedTermWidth, &highlightedTermHeight);
        highlightedTermWidth*=widestStringSize;

        if( highlightXPos+32+highlightedTermWidth > SCREEN_WIDTH)
        {
            highlightXPos = SCREEN_WIDTH - 64-highlightedTermWidth;
        }
        if( highlightXPos< 0)
        {
            highlightXPos = 0;
        }

        render_rectangle(renderTarget, highlightXPos, highlightYPos,
                         highlightXPos+highlightedTermWidth+64, highlightYPos+(GPE_AVERAGE_LINE_HEIGHT*3),GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);

        render_new_text(renderTarget,highlightXPos+32, highlightYPos,fullPhraseToRender,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TERM_NAME,FA_LEFT,FA_TOP,255 );
        render_new_text(renderTarget,highlightXPos+32, highlightYPos+GPE_AVERAGE_LINE_HEIGHT,highlightedTerm->termDescription,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TERM_DESCRIPTION,FA_LEFT,FA_TOP,255 );

        if( (int)fullTermScope.size()>1 )
        {
            render_new_text(renderTarget,highlightXPos+32, highlightYPos+GPE_AVERAGE_LINE_HEIGHT*2,fullTermScope,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TERM_SCOPE,FA_LEFT,FA_TOP,255 );
        }

        render_rectangle(renderTarget, highlightXPos, highlightYPos,
                         highlightXPos+highlightedTermWidth+64, highlightYPos+GPE_AVERAGE_LINE_HEIGHT*3,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
    }
}

void GPE_Gui_Engine::render_foreground_engine(GPE_Renderer * renderTarget,bool forceRedraw)
{
    if( mainResourceBar->resourcebarMoved)
    {
        forceRedraw = true;
    }
    if(GPE_IS_LOADING)
    {
        SDL_SetCursor(GPE_LoadingCursor);
    }
    else
    {
        //SDL_SetCursor(GPE_Cursor);
    }
    if( renderTarget==NULL)
    {
        renderTarget = MAIN_RENDERER;
    }
    SDL_RenderSetViewport(renderTarget->get_renderer(),NULL);
    if( mainToolBar!=NULL && MAIN_CONTEXT_MENU!=NULL )
    {
        mainToolBar->render_toolbar(renderTarget,NULL,true);
        MAIN_CONTEXT_MENU->render_self(renderTarget,&camera);
        if( !mainToolBar->is_open() && !MAIN_CONTEXT_MENU->is_open() )
        {
            if( GPE_Main_TabManager!=NULL)
            {
                GPE_Main_TabManager->render_tabbar(renderTarget,NULL,forceRedraw );
            }
            if( mainResourceBar!=NULL )
            {
                mainResourceBar->render_resourcebar(renderTarget,NULL,forceRedraw);
            }
            if( GPE_Main_Logs!=NULL)
            {
                GPE_Main_Logs->render_self(renderTarget,NULL,NULL,forceRedraw);
            }
            render_gui_info(renderTarget, true);
            render_temporary_message(renderTarget);
            render_code_highlights(renderTarget, true);
            if( RESOURCE_TO_DRAG!=NULL)
            {
                RESOURCE_TO_DRAG->render_option(renderTarget, userInput->mouse_x+32, userInput->mouse_y, -1,NULL, NULL,false, true);
                //render_new_boxed(renderTarget,userInput->mouse_x+32,userInput->mouse_y,RESOURCE_TO_DRAG->get_name(),GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,GPE_MAIN_TEMPLATE->PopUp_Box_Color,FONT_CATEGORY_BAR,FA_LEFT,FA_TOP );
            }
        }
    }
}

void GPE_Gui_Engine::render_gui_info(GPE_Renderer * renderTarget,bool forceRedraw)
{
    if(renderTarget!=NULL && forceRedraw)
    {
        if( GPE_Main_Statusbar!=NULL)
        {
            GPE_Main_Statusbar->render_self(renderTarget,NULL,NULL,true);
        }
        render_tooltip(renderTarget, userInput->mouse_x,userInput->mouse_y+32);
    }
}


void GPE_Gui_Engine::render_frozen_screenshot(GPE_Renderer * renderTarget)
{
    if( renderTarget==NULL)
    {
        renderTarget = MAIN_RENDERER;
    }
    if( renderTarget!=NULL &&  previousScreenshot!=NULL)
    {
        previousScreenshot->render_tex_resized(renderTarget,0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
    }
}

void GPE_Gui_Engine::render_temporary_message(GPE_Renderer * renderTarget)
{
    if( renderTarget==NULL)
    {
        renderTarget = MAIN_RENDERER;
    }
    if( renderTarget!=NULL && temporayMessageDisplayTimer > 0 && temporayMessageDisplayStartTimer > 0 )
    {

        int noticeAlphaValue = (temporayMessageDisplayTimer/temporayMessageDisplayStartTimer)*255;
        if( tempTopLeftMessage)
        {
            render_rectangle(renderTarget,0,0,256,96,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false, noticeAlphaValue);
            render_rectangle(renderTarget,0,0,256,96,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true,noticeAlphaValue);
            render_new_text(renderTarget,0,GENERAL_GPE_PADDING,tempUserMessageTitle,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP,noticeAlphaValue);
            render_new_text(renderTarget,0,GENERAL_GPE_PADDING*2+GPE_AVERAGE_LINE_HEIGHT,tempUserMessageSubtitle,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP,noticeAlphaValue);
            render_new_text(renderTarget,0,GENERAL_GPE_PADDING*3+GPE_AVERAGE_LINE_HEIGHT*2,tempUserMessageText,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP,noticeAlphaValue);

        }
        else
        {
            render_rectangle(renderTarget,SCREEN_WIDTH/2-256,SCREEN_HEIGHT-128,SCREEN_WIDTH/2+256,SCREEN_HEIGHT-32,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false, noticeAlphaValue);
            render_rectangle(renderTarget,SCREEN_WIDTH/2-256,SCREEN_HEIGHT-128,SCREEN_WIDTH/2+256,SCREEN_HEIGHT-32,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true,noticeAlphaValue);
            render_new_text(renderTarget,SCREEN_WIDTH/2,SCREEN_HEIGHT-128+GENERAL_GPE_PADDING,tempUserMessageTitle,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_CENTER,FA_TOP,noticeAlphaValue);
            render_new_text(renderTarget,SCREEN_WIDTH/2,SCREEN_HEIGHT-128+GENERAL_GPE_PADDING*2+GPE_AVERAGE_LINE_HEIGHT,tempUserMessageSubtitle,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_CENTER,FA_TOP,noticeAlphaValue);
            render_new_text(renderTarget,SCREEN_WIDTH/2,SCREEN_HEIGHT-128+GENERAL_GPE_PADDING*3+GPE_AVERAGE_LINE_HEIGHT*2,tempUserMessageText,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_CENTER,FA_TOP,noticeAlphaValue);
        }
        temporayMessageDisplayTimer--;
    }
}

void GPE_Gui_Engine::render_tooltip(GPE_Renderer * cRender,int xPos, int yPos)
{
    if( (int)toolTipString.size()>0)
    {
        if( xPos < 0)
        {
            xPos = userInput->mouse_x;
        }
        if( yPos < 0 || yPos > SCREEN_HEIGHT-GENERAL_GPE_PADDING-toolTipTexture->get_height() )
        {
            yPos = userInput->mouse_y+32;
        }

        int TEXTBOX_FONT_SIZE_WIDTH = 12;
        int TEXTBOX_FONT_SIZE_HEIGHT = 12;
        if( FONT_TOOLTIP!=NULL)
        {
             FONT_TOOLTIP->get_metrics("A",&TEXTBOX_FONT_SIZE_WIDTH,&TEXTBOX_FONT_SIZE_HEIGHT);
        }

        int xPos2 = 0;
        int yPos2 = yPos+TEXTBOX_FONT_SIZE_HEIGHT+GENERAL_GPE_PADDING/2;

        int maxLength = (SCREEN_WIDTH - GENERAL_GPE_PADDING*4)/TEXTBOX_FONT_SIZE_WIDTH;
        int lineCountForTip = 1;
        std::vector< std::string > toolTipLines;
        std::string tempToolTipString = toolTipString;
        if( (int)tempToolTipString.size() >= maxLength)
        {
            xPos = 0;
            xPos2 = SCREEN_WIDTH;
            while ( (int)tempToolTipString.size() > 0 )
            {
                toolTipLines.push_back( get_substring(tempToolTipString,0,maxLength) );
                tempToolTipString = get_substring(tempToolTipString,maxLength);
            }
            yPos2= yPos+TEXTBOX_FONT_SIZE_HEIGHT*( (int)toolTipLines.size() )+GENERAL_GPE_PADDING/2;
        }
        else
        {
            toolTipLines.push_back(toolTipString);
            if(xPos+TEXTBOX_FONT_SIZE_WIDTH*(int)toolTipString.size()+GENERAL_GPE_PADDING*2 > SCREEN_WIDTH)
            {
                xPos = SCREEN_WIDTH-( TEXTBOX_FONT_SIZE_WIDTH*(int)toolTipString.size() )-GENERAL_GPE_PADDING*2;
                if( xPos < 0)
                {
                    xPos = 0;
                }
            }
            xPos2 = xPos+ TEXTBOX_FONT_SIZE_WIDTH*(int)toolTipString.size()+GENERAL_GPE_PADDING*2;
        }

        render_rectangle(cRender,xPos-GENERAL_GPE_PADDING/2,yPos-GENERAL_GPE_PADDING/2,xPos2,yPos2,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);
        for( int i = 0; i < (int)toolTipLines.size(); i++)
        {
            render_new_text(cRender,xPos+GENERAL_GPE_PADDING,yPos+TEXTBOX_FONT_SIZE_HEIGHT*i, toolTipLines[i],GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_TOOLTIP,FA_LEFT,FA_TOP);
        }

        render_rectangle(cRender,xPos-GENERAL_GPE_PADDING/2,yPos-GENERAL_GPE_PADDING/2,xPos2,yPos2,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
    }
    tipTipJustUpdated = false;
}

void GPE_Gui_Engine::remove_project(std::string projectFileName )
{
    if( (int)projectFileName.size()>0 )
    {
        GPE_ProjectFolder * tPFolder = NULL;
        for( int i = (int)gpeProjects.size()-1; i>=0; i--)
        {
            tPFolder = gpeProjects[i];
            if( tPFolder!=NULL )
            {
                if( tPFolder->get_project_file_name().compare(projectFileName)==0 )
                {
                    GPE_Main_TabManager->close_tabs_from_project( projectFileName );
                    if(CURRENT_PROJECT!=NULL)
                    {
                        if( CURRENT_PROJECT->get_project_name()==tPFolder->get_project_name() )
                        {
                            CURRENT_PROJECT = NULL;
                            CURRENT_PROJECT_NAME = "";
                        }
                    }

                    if( GPE_MAIN_GUI!=NULL && GPE_MAIN_GUI->mainResourceBar!=NULL)
                    {
                        displayMessageTitle = "Closing Game Project";
                        displayMessageSubtitle = projectFileName;
                        displayMessageString = "Removing from Projects Menu";
                        display_user_messaage();
                        GPE_MAIN_GUI->mainResourceBar->remove_project_resources(projectFileName);

                        displayMessageTitle = "Closing Game Project";
                        displayMessageSubtitle = projectFileName;
                        displayMessageString = "Removing from Projects Menu";
                        display_user_messaage();
                    }

                    delete tPFolder;
                    tPFolder = NULL;
                    gpeProjects.erase(gpeProjects.begin()+i);

                    displayMessageTitle = "Closing Game Project";
                    displayMessageSubtitle = projectFileName;
                    displayMessageString = "Cache Cleared...";
                    display_user_messaage();

                    GPE_ClearFontCache();
                }
            }
        }
    }
}

void GPE_Gui_Engine::reset_gui_info()
{
    //update_tooltip("");
    if( GPE_Main_Statusbar!=NULL)
    {
        GPE_Main_Statusbar->reset_statusbar();
        /*GPE_Main_Statusbar->set_coords(0,SCREEN_HEIGHT-32);
        GPE_Main_Statusbar->set_width(SCREEN_WIDTH);
        GPE_Main_Statusbar->set_height(32);*/
    }
}

void GPE_Gui_Engine::save_all_projects()
{
    GPE_ProjectFolder * tPFolder = NULL;
    for( int i = 0; i < (int)gpeProjects.size(); i++ )
    {
        tPFolder = gpeProjects[i];
        if( tPFolder!=NULL)
        {
            tPFolder->save_project();
        }
    }

}

void GPE_Gui_Engine::export_current_project_html5(bool runGameOnCompile)
{
    GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
    if( fFolder!=NULL)
    {
        fFolder->save_project();
        fFolder->export_project_html5("",GPE_BUILD_HTML5,runGameOnCompile);
    }
}

void GPE_Gui_Engine::export_current_project_wiiu()
{
    /*
    //Not used for public build
    GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
    if( fFolder!=NULL)
    {
        fFolder->save_project();
        fFolder->export_project_wiiu();
    }
    */
}

void GPE_Gui_Engine::rum_current_project(std::string projectBuildDirectory, int buildMetaTemplate)
{
    GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
    if( fFolder!=NULL)
    {
        fFolder->run_project(projectBuildDirectory, buildMetaTemplate);
    }
}


void GPE_Gui_Engine::save_current_project()
{
    GPE_ProjectFolder * fFolder = find_project_from_filename(CURRENT_PROJECT_NAME);
    if( fFolder!=NULL)
    {
        fFolder->save_project();
    }
}

void GPE_Gui_Engine::save_settings()
{
    std::string newSaveDataFilename = get_user_settings_folder()+"gpe_ide_settings.txt";
    std::ofstream newSaveDataFile( newSaveDataFilename.c_str() );
    //If the scene file could be saved
    if( !newSaveDataFile.fail() )
    {
        //makes sure the file is open
        if (newSaveDataFile.is_open())
        {
            newSaveDataFile << "#    --------------------------------------------------  # \n";
            newSaveDataFile << "#     \n";
            newSaveDataFile << "#     \n";
            newSaveDataFile << "#    Game Pencil Engine Settings DataFile \n";
            newSaveDataFile << "#    Created automatically via the Game Pencil Engine Editor \n";
            newSaveDataFile << "#    Warning: Manually editing this file may cause unexpected bugs and errors. \n";
            newSaveDataFile << "#    If you have any problems reading this file please report it to debug@pawbyte.com . \n";
            newSaveDataFile << "#     \n";
            newSaveDataFile << "#     \n";
            newSaveDataFile << "#    --------------------------------------------------  # \n";
            newSaveDataFile << "Version=" << GPE_VERSION_DOUBLE_NUMBER << "\n";
            newSaveDataFile << "ResourceBarPosition=" <<RENDER_RESOURCEBAR_LEFT << "\n";

            if( mainResourceBar!=NULL)
            {
                newSaveDataFile << "ResourceBarVisible=" << mainResourceBar->is_visible() << "\n";
                newSaveDataFile << "ResourceBarWidth=" << mainResourceBar->get_width() << "\n";
            }
            newSaveDataFile << "ShowStartPageAtStart=" << showStartPageAtStartUp << "\n";
            newSaveDataFile << "ShowTipOfDayAtStart=" << showTipsAtStartUp <<  "\n";
            newSaveDataFile << "TextAreaViewLineCount=" << showTextEditorLineCount << "\n";
            newSaveDataFile << "TextAreaViewSynthaxHighlighting=" << showTextEditorSynthaxHightlight << "\n";
            if( GPE_MAIN_TEMPLATE!=NULL)
            {
                newSaveDataFile << "ColorTheme=" << GPE_MAIN_TEMPLATE->templateLocalLocation << "\n";
            }
            newSaveDataFile.close();
        }
    }
}

void GPE_Gui_Engine::setup_project_directory(std::string newProjectDir)
{
    if( (int)newProjectDir.size() > 3)
    {
        create_directory(newProjectDir);
        create_directory(newProjectDir+"/gpe_project");
        create_directory(newProjectDir+"/gpe_project/builds");

        create_directory(newProjectDir+"/gpe_project/data");

        create_directory(newProjectDir+"/gpe_project/gpebackups");

        create_directory(newProjectDir+"/gpe_project/resources");
        create_directory(newProjectDir+"/gpe_project/resources/achievements");
        create_directory(newProjectDir+"/gpe_project/resources/audio");
        create_directory(newProjectDir+"/gpe_project/resources/fonts");
        create_directory(newProjectDir+"/gpe_project/resources/functions");
        create_directory(newProjectDir+"/gpe_project/resources/objects");
        create_directory(newProjectDir+"/gpe_project/resources/paths");
        create_directory(newProjectDir+"/gpe_project/resources/scenes");
        create_directory(newProjectDir+"/gpe_project/resources/sprites");
        create_directory(newProjectDir+"/gpe_project/resources/textures");
        create_directory(newProjectDir+"/gpe_project/resources/tilesheets");
        create_directory(newProjectDir+"/gpe_project/resources/videos");
    }
}

std::string GPE_Gui_Engine::setup_build_folder(std::string buildDirectory,int buildType , int buildBits, bool inDebugMode, int nativeBuildType)
{
    if( GPE_Main_Logs!=NULL)
    {
        if( (int)buildDirectory.size() > 3)
        {
            /*if( buildType!=GPE_BUILD_HTML5 && buildType!=GPE_BUILD_WIIU)
            {
                if( buildBits==64)
                {
                    buildDirectory+="_64";
                }
                else
                {
                    buildDirectory+="_32";
                }
            }
            if( inDebugMode)
            {
                //buildDirectory+="_debug";
            }
            */
            std::string newBuildDirectory = buildDirectory;

            create_directory(buildDirectory);
            if( path_exists(buildDirectory) )
            {
                if( ( buildType==GPE_BUILD_WINDOWS || buildType==GPE_BUILD_LINUX ) && nativeBuildType==Native_Electron)
                {
                    create_directory(buildDirectory+"/locales");
                    create_directory(buildDirectory+"/resources");
                    create_directory(buildDirectory+"/resources/app");
                    if( path_exists( buildDirectory+"/resources/app") )
                    {
                        newBuildDirectory = buildDirectory+"/resources/app";
                    }
                    else
                    {
                        GPE_Main_Logs->log_build_line("Unable to access ["+buildDirectory+"/resources/app] folder...");
                    }
                }
                else if( buildType== GPE_BUILD_MAC && nativeBuildType==Native_Electron)
                {
                    create_directory(buildDirectory+"/Electron.app");
                    create_directory(buildDirectory+"/Electron.app/Contents");
                    create_directory(buildDirectory+"/Electron.app/Contents/Resources");
                    if( path_exists( buildDirectory+"/Electron.app/Contents/Resources") )
                    {
                        newBuildDirectory = buildDirectory+"/Electron.app/Contents/Resources";
                    }
                    else
                    {
                        GPE_Main_Logs->log_build_line("Unable to access ["+buildDirectory+"/Electron.app/Contents/Resources] folder...");
                    }
                }

                create_directory(newBuildDirectory+"/css");
                create_directory(newBuildDirectory+"/gamedata");
                create_directory(newBuildDirectory+"/js");
                create_directory(newBuildDirectory+"/js/lib");

                create_directory(newBuildDirectory+"/res");

                create_directory(newBuildDirectory+"/resources");
                create_directory(newBuildDirectory+"/resources/audio");
                create_directory(newBuildDirectory+"/resources/fonts");
                create_directory(newBuildDirectory+"/resources/sprites");
                create_directory(newBuildDirectory+"/resources/textures");
                create_directory(newBuildDirectory+"/resources/tilesheets");
                create_directory(newBuildDirectory+"/resources/videos");

                if( nativeBuildType ==Native_Electron )
                {
                    if( buildType == GPE_BUILD_WINDOWS)
                    {
                        displayMessageTitle = "Copying Electron-Windows Files";
                        displayMessageSubtitle = "Please wait";
                        displayMessageString = "Do NOT close";
                        display_user_messaage();
                        if( buildBits==64)
                        {
                            GPE_Main_Logs->log_build_line("Copying Electron-Windows 64Bit Files...");
                            displayMessageSubtitle = "Copying [game.exe] and [dlls] files";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/win64build_electron",buildDirectory);

                            displayMessageSubtitle = "Copying locales folder";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/win64build_electron/locales",buildDirectory+"/locales");


                            displayMessageSubtitle = "Copying [resources] folder";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/win64build_electron/resources",buildDirectory+"/resources", true);
                        }
                        else
                        {
                            GPE_Main_Logs->log_build_line("Copying Electron-Windows 32Bit Files...");
                            displayMessageSubtitle = "Copying [game.exe] and [dlls] files";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/win32build_electron",buildDirectory);

                            displayMessageSubtitle = "Copying [locales] folder";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/win32build_electron/locales",buildDirectory+"/locales");

                            displayMessageSubtitle = "Copying [resources] folder";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/win32build_electron/resources",buildDirectory+"/resources", true);
                        }
                    }
                    else if( buildType == GPE_BUILD_LINUX)
                    {
                        displayMessageTitle = "Copying Electron-Linux Files";
                        displayMessageSubtitle = "Please wait";
                        displayMessageString = "Do NOT close";
                        display_user_messaage();
                        if( buildBits==64)
                        {
                            GPE_Main_Logs->log_build_line("Copying Electron-Linux 64bit Files...");
                            displayMessageSubtitle = "Copying game and SO files";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/linux64build_electron",buildDirectory);

                            displayMessageSubtitle = "Copying locales folder";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/linux64build_electron/locales",buildDirectory+"/locales");


                            displayMessageSubtitle = "Copying [resources] folder";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/linux64build_electron/resources",buildDirectory+"/resources", true);
                        }
                        else
                        {
                            GPE_Main_Logs->log_build_line("Copying Electron-Linux 32Bit Files...");
                            displayMessageSubtitle = "Copying game and SO files";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/linux32build_electron",buildDirectory);

                            displayMessageSubtitle = "Copying [locales] folder";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/linux32build_electron/locales",buildDirectory+"/locales");

                            displayMessageSubtitle = "Copying [resources] folder";
                            display_user_messaage();
                            copy_folder(APP_DIRECTORY_NAME+"build_files/linux32build_electron/resources",buildDirectory+"/resources", true);
                        }
                    }
                    else if(buildType == GPE_BUILD_MAC)
                    {
                        GPE_Main_Logs->log_build_comment("Automatic Electron OSX building not supported yet...");
                    }
                }
                else
                {
                    if( buildType == GPE_BUILD_WINDOWS || buildType == GPE_BUILD_MAC || buildType == GPE_BUILD_LINUX)
                    {
                        GPE_Main_Logs->log_build_comment("Electron not copied, previous version if available will be used...");
                    }
                }
            }
            else
            {
                GPE_Main_Logs->log_build_error("Unable to create ["+buildDirectory+"] folder. Unable to access...");
            }
            return newBuildDirectory;
        }
        else
        {
            GPE_Main_Logs->log_build_error("Unable to create ["+buildDirectory+"] folder. Unallowed name.");
        }
    }
    return "";
}

void GPE_Gui_Engine::take_live_screenshor(GPE_Renderer * renderTarget)
{
    if( renderTarget==NULL)
    {
        renderTarget = MAIN_RENDERER;
    }
    if( renderTarget!=NULL)
    {
        if( MAIN_EDITOR_SETTINGS!=NULL && MAIN_EDITOR_SETTINGS->autoSaveScreenshots!=NULL && MAIN_EDITOR_SETTINGS->autoSaveScreenshots->is_clicked() )
        {
            if( MAIN_EDITOR_SETTINGS->makeMetaScreenshots!=NULL && MAIN_EDITOR_SETTINGS->makeMetaScreenshots->is_clicked() )
            {
                if( (int)CURRENT_PROJECT_NAME.size() > 0 )
                {
                    std::time_t rawtime;
                    std::tm* timeinfo;
                    char timeBuffer [80];

                    std::time(&rawtime);
                    timeinfo = std::localtime(&rawtime);

                    std::strftime(timeBuffer,80,"%y%m%d_%H%M%S",timeinfo);
                    std::puts(timeBuffer);

                    bool foundBlank = false;
                    std::string screenshotNewLocation  = "";


                    screenshotNewLocation = APP_DIRECTORY_NAME+"screenshots/"+get_file_noext( get_local_from_global_file( CURRENT_PROJECT_NAME) )+"_"+timeBuffer+".png";
                    if( file_exists( screenshotNewLocation) ==false )
                    {
                        foundBlank = true;
                        renderTarget->save_screenshot(screenshotNewLocation);
                    }
                    for(int i = 1; foundBlank == false && i <= 1000; i++)
                    {
                        screenshotNewLocation = APP_DIRECTORY_NAME+"screenshots/"+get_file_noext( get_local_from_global_file( CURRENT_PROJECT_NAME) )+"_"+timeBuffer+"_"+int_to_string(i)+".png";
                        if( file_exists( screenshotNewLocation) ==false )
                        {
                            foundBlank = true;
                            renderTarget->save_screenshot(screenshotNewLocation);
                            break;
                        }
                    }
                    if( foundBlank==false)
                    {
                        appendToFile(APP_DIRECTORY_NAME+"screenshots/screenshot_log.txt","Unable to save screenshot to "+screenshotNewLocation);
                        record_error("Unable to save screenshot to "+screenshotNewLocation);
                    }
                }
                else
                {
                    renderTarget->save_screenshot();
                }
            }
            else
            {
                renderTarget->save_screenshot();
            }
        }
    }
}
void GPE_Gui_Engine::take_frozen_screenshot(GPE_Renderer * renderTarget)
{
    if( renderTarget==NULL)
    {
        renderTarget = MAIN_RENDERER;
    }
    if( previousScreenshot==NULL)
    {
        previousScreenshot = new GPE_Texture();
    }
    if( previousScreenshot!=NULL && renderTarget!=NULL)
    {
        renderTarget->save_screenshot(APP_DIRECTORY_NAME+"frozen_screenshot.png");
        previousScreenshot->load_new_texture(renderTarget,APP_DIRECTORY_NAME+"frozen_screenshot.png");
    }
}

bool GPE_Gui_Engine::using_search()
{
    switch( textSearchMode)
    {
        case SEARCH_MODE_FIND:
            if( findTextStringBox->is_inuse() )
            {
                return true;
            }
        break;

        case SEARCH_MODE_GOTO:
            if( goToLineStringBox->is_inuse() )
            {
                return true;
            }
        break;
        case SEARCH_MODE_FINDALL:
            if( findTextStringBox->is_inuse() )
            {
                return true;
            }
            if( replaceTextStringBox->is_inuse() )
            {
                return true;
            }
        break;
        default:
            return false;
        break;
    }
    return false;
}

void GPE_Gui_Engine::update_tooltip(std::string newTip)
{
    if( newTip!=toolTipString)
    {
        toolTipString = newTip;
        if( toolTipTexture==NULL)
        {
            toolTipTexture = new GPE_Texture();
        }
        if( toolTipTexture!=NULL)
        {
            //toolTipTexture->loadFromRenderedText(MAIN_RENDERER,newTip,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT);
        }
        tipTipJustUpdated = true;
    }
}

void GPE_Gui_Engine::update_temporary_message(std::string mTitle, std::string mSubTitle, std::string mText, float messDuration, bool topLeftMessage)
{
    if( messDuration >0 &&  ( (int)mTitle.size()>0 || (int)mSubTitle.size()>0 || (int)mText.size()>0 ) )
    {
        tempUserMessageTitle = mTitle;
        tempUserMessageSubtitle = mSubTitle;
        tempUserMessageText = mText;
        tempTopLeftMessage = topLeftMessage;
        temporayMessageDisplayStartTimer = temporayMessageDisplayTimer = messDuration*FPS_CAP;
    }
    else
    {
        tempUserMessageTitle = "";
        tempUserMessageSubtitle = "";
        tempUserMessageText = "";
        temporayMessageDisplayStartTimer = temporayMessageDisplayTimer = 0;
    }
}

void GPE_Gui_Engine::update_recent_project_list(bool saveData)
{
    if( MAIN_TOOLBAR_RECENT_PROJECTS!=NULL)
    {
        MAIN_TOOLBAR_RECENT_PROJECTS->clear_menu();
        int iRPList = 0;
        int maxRPList = GPE_MAIN_GUI->get_recent_project_list_size();
        for( iRPList = 0; iRPList < maxRPList; iRPList++)
        {
            if( iRPList==maxRPList-1)
            {
                MAIN_TOOLBAR_RECENT_PROJECTS->add_menu_option(GPE_MAIN_GUI->get_recent_project_name(iRPList),-1,NULL,-1,NULL, true );
            }
            else
            {
                MAIN_TOOLBAR_RECENT_PROJECTS->add_menu_option(GPE_MAIN_GUI->get_recent_project_name(iRPList),-1,NULL,-1,NULL,false );
            }
        }
        MAIN_TOOLBAR_RECENT_PROJECTS->add_menu_option("Clear Recent Projects List");
    }
}

standardEditableGameResource::standardEditableGameResource(GPE_ResourceContainer * ppFolder)
{
    resourceName = "";
    globalResouceIdNumber = -1;
    commonButtonAlignment = 0;
    justOpenedThisFrame = false;
    parentProjectName = "";
    projectParentFolder = ppFolder;
    if( projectParentFolder!=NULL)
    {
        parentProjectName = projectParentFolder->get_name();
    }
    renameBox = new GPE_TextInputBasic("","Name");
    renameBox->set_label("Name");

    loadResourceButton = new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/folder.png","Load Resource","Load Resource FROM File",-1);
    exportResourceButton = new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/plane.png","Export Resource","Export Resource TO File",-1);
    saveResourceButton = new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/save.png","Save Resource","Save Resource to File",-1);

    confirmResourceButton = new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/check.png","Confirm","Confirm and Save Changes");
    cancelResourceButton =  new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/times.png","Cancel","Cancel Changes and Revert to previous settings");

    int maxSize = std::max(confirmResourceButton->get_width(),cancelResourceButton->get_width() );
    //confirmResourceButton->set_width(maxSize);
    //cancelResourceButton->set_width(maxSize);
    //makes it so the main button options are the same width along with the rename string box too for design purposes

    editorPaneList = new GPE_GuiElementList();
}

standardEditableGameResource::~standardEditableGameResource()
{
    if( confirmResourceButton!=NULL)
    {
        delete confirmResourceButton;
        confirmResourceButton = NULL;
    }
    if( cancelResourceButton!=NULL)
    {
        delete cancelResourceButton;
        cancelResourceButton = NULL;
    }
    if( loadResourceButton!=NULL)
    {
        delete loadResourceButton;
        loadResourceButton = NULL;
    }
    if( exportResourceButton!=NULL)
    {
        delete exportResourceButton;
        exportResourceButton = NULL;
    }
    if( saveResourceButton!=NULL)
    {
        delete saveResourceButton;
        saveResourceButton = NULL;
    }
    if( renameBox!=NULL)
    {
        delete renameBox;
        renameBox = NULL;
    }
    if( editorPaneList!=NULL)
    {
        delete editorPaneList;
        editorPaneList = NULL;
    }
}

std::string standardEditableGameResource::get_current_name()
{
    if( renameBox!=NULL)
    {
        if( is_alnum(renameBox->get_string(),false,true)==true)
        {
            return renameBox->get_string();
        }
        else if( GPE_Main_Logs!=NULL && resourceType!=RESOURCE_TYPE_PROJECT_SETTINGS && globalResouceIdNumber >=1000 )
        {
            GPE_Main_Logs->log_general_comment("Non-alphabetical resource ["+renameBox->get_string()+"] being renamed to "+resourceName+"." );
        }
    }
    return get_name();
}

GPE_GeneralGuiElement * standardEditableGameResource::add_gui_component(std::string componentData)
{
    if( (int)componentData.size() > 0)
    {
        int colonPos = componentData.find(":");
        int equalPos = componentData.find("==|||==");

        if( colonPos!=(int)std::string::npos && equalPos!=(int)std::string::npos && (equalPos>colonPos) )
        {
            std::string newComponentType = split_first_string(componentData,":");
            std::string newComponentName = split_first_string(componentData,"==|||==");

            GPE_GeneralGuiElement * newComponentField = NULL;
            if( newComponentType=="checkbox")
            {
                newComponentField = new GPE_CheckBoxBasic(newComponentName);
            }
            else if( newComponentType=="colorpicker")
            {
                GPE_Input_Field_Color * newColorField = new GPE_Input_Field_Color(0,0,256,-1,newComponentName);
                newColorField->set_label(newComponentName);
                newComponentField = newColorField;
            }
            else if( newComponentType=="dropdown")
            {
                newComponentField = new GPE_DropDown_Menu(0,0,newComponentName,false);
            }
            else if(newComponentType=="inputtext")
            {
                GPE_TextInputBasic * tempNewField = new GPE_TextInputBasic("");
                tempNewField->set_name(newComponentName);
                tempNewField->set_label(newComponentName);
                tempNewField->set_width(256);
                newComponentField = tempNewField;
            }
            else if(newComponentType=="inputnumber")
            {
                GPE_TextInputBasic * tempNewField = new GPE_TextInputNumber("");
                tempNewField->set_name(newComponentName);
                tempNewField->set_label(newComponentName);
                tempNewField->set_width(256);
                newComponentField = tempNewField;
            }
            else if(newComponentType=="radio")
            {
                GPE_RadioButtonControllerBasic * tempRadioButton = new GPE_RadioButtonControllerBasic();
                tempRadioButton->set_name(newComponentName);
                newComponentField = tempRadioButton;
            }
            else if(newComponentType=="labeltext")
            {
                newComponentField = new GPE_Label_Text(newComponentName,newComponentName);
            }
            else if(newComponentType=="texturl")
            {
                newComponentField = new GPE_TextURL(newComponentName,newComponentName);
            }
            else if( newComponentType=="resourcedropdown")
            {
                std::string dropdownType = split_first_string(componentData,"=");
                newComponentField = new GPE_DropDown_Resouce_Menu(0,0,newComponentName,NULL );
            }
            if( newComponentField!=NULL)
            {
                newComponentField->load_data(componentData);
            }
            //record_error("Returning ["+newComponentType+"] gui component named ["+newComponentName+"] using ["+componentData+"] data.");
            return newComponentField;
        }
    }
    record_error("Returning NULL gui component using ["+componentData+"] data.");
    return NULL;
}

void standardEditableGameResource::prerender_self(GPE_Renderer * cRender)
{
    if( loadResourceButton!=NULL)
    {
        loadResourceButton->prerender_self(cRender);
    }
    if( exportResourceButton!=NULL)
    {
        exportResourceButton->prerender_self(cRender);
    }
    if( saveResourceButton!=NULL)
    {
        saveResourceButton->prerender_self(cRender);
    }
    if( confirmResourceButton!=NULL)
    {
        confirmResourceButton->prerender_self(cRender);
    }
    if( cancelResourceButton!=NULL)
    {
        cancelResourceButton->prerender_self(cRender);
    }
}

void standardEditableGameResource::open_code( int lineNumb, int colNumb, std::string codeTitle )
{

}

void standardEditableGameResource::process_resource(SDL_Rect *viewedSpace ,SDL_Rect *cam )
{
    isModified = false;
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    process_self(viewedSpace,cam);
    process_export();
    /*
    if( confirmResourceButton!=NULL)
    {
        if( commonButtonAlignment==1)
        {
            cancelResourceButton->set_coords(viewedSpace->w-cancelResourceButton->get_width()-GENERAL_GPE_PADDING,viewedSpace->h-cancelResourceButton->get_height()-GPE_AVERAGE_LINE_HEIGHT);
            cancelResourceButton->process_self(viewedSpace,cam);
            if( confirmResourceButton!=NULL)
            {
                if( confirmResourceButton->is_enabled() )
                {
                    confirmResourceButton->set_coords(cancelResourceButton->get_xpos()-confirmResourceButton->get_width()-GENERAL_GPE_PADDING,cancelResourceButton->get_ypos());
                }
                else
                {
                    confirmResourceButton->set_coords(cancelResourceButton->get_xpos()-confirmResourceButton->get_width()-GENERAL_GPE_PADDING,cancelResourceButton->get_ypos());
                }
                confirmResourceButton->process_self(viewedSpace,cam);
                if( confirmResourceButton->is_clicked() && editorMode==0 )
                {
                    if( renameBox!=NULL)
                    {
                        set_name( renameBox->get_string() );
                    }
                }
            }
        }
        else
        {
            cancelResourceButton->set_coords(-1,viewedSpace->h-cancelResourceButton->get_height()-GPE_AVERAGE_LINE_HEIGHT);
            cancelResourceButton->process_self(viewedSpace,cam);
            if( confirmResourceButton!=NULL)
            {
                if( cancelResourceButton->is_enabled() )
                {
                    confirmResourceButton->set_coords(-1,cancelResourceButton->get_ypos()-confirmResourceButton->get_height()-GPE_AVERAGE_LINE_HEIGHT);
                }
                else
                {
                    confirmResourceButton->set_coords(-1,viewedSpace->h-confirmResourceButton->get_height()-GPE_AVERAGE_LINE_HEIGHT);
                }
                confirmResourceButton->process_self(viewedSpace,cam);
                if( confirmResourceButton->is_clicked() && editorMode==0 )
                {
                    if( renameBox!=NULL)
                    {
                        set_name( renameBox->get_string() );
                    }
                }
            }
        }
    }
    if( renameBox!=NULL)
    {
        renameBox->process_self(viewedSpace,cam);
        //set_name( renameBox->get_string() );
        if(resourceName!=renameBox->get_string() )
        {
            isModified = true;
        }
    }
    */
}

void standardEditableGameResource::process_export()
{
    bool exportCalled = false;
    if( exportResourceButton!=NULL && exportResourceButton->is_clicked() )
    {
        exportCalled = true;
    }
    else if( userInput->check_keyboard_down(kb_ctrl) && userInput->check_keyboard_pressed(kb_e) )
    {
        exportCalled = true;
        userInput->reset_all_input();
    }

    if( exportCalled )
    {
        if( resourceType >=0 && resourceType < res_type_count )
        {
            std::string fileToExportName = GPE_GetSaveFileName( "Export "+RESOURCE_TYPE_NAMES[resourceType]+" to file",".gpf", GPE_MAIN_GUI->fileSaveExportFileDir );
            if( (int)fileToExportName.size() > 0)
            {
                if(  get_file_ext(fileToExportName) !="gpf" )
                {
                    fileToExportName = get_file_noext(fileToExportName)+".gpf";
                }
                GPE_Main_Logs->log_general_line("Exporting "+RESOURCE_TYPE_NAMES[resourceType]+" resource to "+fileToExportName+".");
                save_resource(fileToExportName);
            }
            else
            {
                GPE_Main_Logs->log_general_comment("Export of ["+resourceName+"] canceled.");
            }
        }
        exportResourceButton->set_clicked( false );
    }
}

void standardEditableGameResource::integrate_into_synthax()
{
    if( CURRENT_PROJECT!=NULL)
    {
        if( resourceType >=0 && resourceType < res_type_count)
        {
            CURRENT_PROJECT->add_project_keyword(resourceName,"Project "+RESOURCE_TYPE_NAMES[resourceType]+" Resource",-1,"");
        }
    }
}

void standardEditableGameResource::preprocess_self(std::string alternatePath)
{

}

void standardEditableGameResource::process_self(SDL_Rect *viewedSpace ,SDL_Rect *cam )
{

}

void standardEditableGameResource::render_resource(GPE_Renderer * cRender,SDL_Rect *viewedSpace ,SDL_Rect *cam, bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if(cam!=NULL)
    {
        if( forceRedraw || justOpenedThisFrame )
        {
            //render_rectangle(cRender,0,0,viewedSpace->w,viewedSpace->h,GPE_MAIN_TEMPLATE->Program_Color,false);
            forceRedraw = true;
        }
        render_self(cRender,viewedSpace,cam,forceRedraw);
    }
    justOpenedThisFrame = false;
}

void standardEditableGameResource::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace ,SDL_Rect *cam,bool forceRedraw  )
{

}

void standardEditableGameResource::seek_parent_name()
{
    if( projectParentFolder!=NULL)
    {
        parentProjectName = projectParentFolder->get_name();
    }
}

void standardEditableGameResource::set_name(std::string newName)
{
    resourceName = newName;
    if(renameBox!=NULL)
    {
        renameBox->set_string(newName);
    }
}

void standardEditableGameResource::set_parent_name(std::string newName)
{
    parentProjectName = newName;
}

int standardEditableGameResource::search_for_string(std::string needle)
{
    return 0;
}

int standardEditableGameResource::search_and_replace_string(std::string needle, std::string newStr )
{
    return 0;
}
//



//

gamePencilStartPageResource::gamePencilStartPageResource(GPE_ResourceContainer * pFolder)
{
    resourceFileName = "";
    resourceName = "Start Page";
    parentProjectName = "";
    parentProjectDirectory = "";
    projectParentFolder = NULL;
    subViewedSpace.x = GENERAL_GPE_PADDING;
    subViewedSpace.x = GENERAL_GPE_PADDING;
    subViewedSpace.w = 400;
    subViewedSpace.h = 400;
    resourceType = -2;
    subResouceId = -2;
    renameBox->disable_self();
    confirmResourceButton->disable_self();
    cancelResourceButton->disable_self();
    loadResourceButton->disable_self();
    saveResourceButton->disable_self();

    startPageList = new GPE_GuiElementList();
    startPageList->set_horizontal_align(FA_CENTER);
    startPageList->barXPadding = GENERAL_GPE_PADDING;
    startPageList->barXMargin = 128;
    labelEditorShortcuts = new GPE_Label_Title("Editor Shortcuts","Editor Shortcuts");
    /*/Patreon Stuff
    labelPatreon = new GPE_Label_Title("Support Our Patreon Campaign","");
    labelPatreonLogo = new GPE_Label_Image(GPE_LOGO);
    labelPatreonLogo->load_label_image(APP_DIRECTORY_NAME+"resources/gfx/textures/patreon_banner.png");
    labelPatreonLogo->hasLineBreak = true;
    labelPatreonLogo->webUrl = "https://www.patreon.com/pawbyte?ty=h";

    labelPatreonDescription = new GPE_Label_Text("By donating a small amount you can keep this engine going!","");
    urlPatreonPage = new GPE_TextURL("Fund future exports and features","A few dollars can go a long way","https://www.patreon.com/pawbyte?ty=h");
    urlPatreonPage->hasLineBreak = true;
    */
    labelHelpfulLinks = new GPE_Label_Title("Helpful Links","Helpful Links");

    GPE_TextURL * tTempUrl = NULL;
    tTempUrl = new GPE_TextURL("Game Pencil Home Page","","http://gamepencil.pawbyte.com");
    tTempUrl->hasLineBreak = true;
    helpfulWebLinks.push_back(tTempUrl);
    tTempUrl = new GPE_TextURL("Documentation","","http://docs.pawbyte.com");
    tTempUrl->hasLineBreak = true;
    helpfulWebLinks.push_back(tTempUrl);

    tTempUrl = new GPE_TextURL("Official Forums","","http://forums.pawbyte.com");
    tTempUrl->hasLineBreak = true;
    helpfulWebLinks.push_back(tTempUrl);

    tTempUrl = new GPE_TextURL("itch.io Marketplace","","https://itch.io/game-assets/tag-gamepencil");
    tTempUrl->hasLineBreak = true;
    helpfulWebLinks.push_back(tTempUrl);

    tTempUrl = new GPE_TextURL("Discord Chat","","https://discord.gg/aNX3Fcx");
    tTempUrl->hasLineBreak = true;
    helpfulWebLinks.push_back(tTempUrl);

    tTempUrl = new GPE_TextURL("Official News","","http://gamepencil.pawbyte.com/category/news/");
    tTempUrl->hasLineBreak = true;
    helpfulWebLinks.push_back(tTempUrl);

    tTempUrl = new GPE_TextURL("PawByte","","http://www.pawbyte.com");
    tTempUrl->hasLineBreak = true;
    helpfulWebLinks.push_back(tTempUrl);

    projectBrowserButton = new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/binoculars.png","Project Browser","",-1,64);
    projectBrowserButton->enable_background(false);
    projectBrowserButton->enable_border(false);

    forumPageButton = new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/comments.png","Forums","",-1,64);
    forumPageButton->enable_background(false);
    forumPageButton->set_website("http://community.pawbyte.com");
    forumPageButton->enable_border(false);

    helpPageButton = new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/question.png","Help","",-1,64);
    helpPageButton->enable_background(false);
    helpPageButton->enable_border(false);

    tipOfTheDayButton = new GPE_ToolPushButton(0,0,APP_DIRECTORY_NAME+"resources/gfx/buttons/info.png","Tip of the Day","",-1,64);
    tipOfTheDayButton->enable_background(false);
    tipOfTheDayButton->enable_border(false);
    std::string copyRightInfoString = "";
    if( GPE_VERSION_UPDATE_NUMBER==0)
    {
        copyRightInfoString = float_to_string(GPE_VERSION_DOUBLE_NUMBER)+"0";
    }
    else
    {
        copyRightInfoString = float_to_string(GPE_VERSION_DOUBLE_NUMBER);
    }
    if( GPE_MAIN_GUI!=NULL)
    {
        if( GPE_MAIN_GUI->editorReleaseType==RELEASE_TYPE_ALPHA)
        {
            copyRightInfoString+="   - Alpha Version";
        }
        else if( GPE_MAIN_GUI->editorReleaseType==RELEASE_TYPE_BETA)
        {
            copyRightInfoString+="   - Beta Version";
        }
    }

    labelCopyrightInfo = new GPE_Label_Text("Game Pencil Engine - Version "+copyRightInfoString+".","");
    labelVersionInfo = new GPE_Label_Text("Copyright (c) 2016 PawByte | make.pawbyte.com","");
    labelImgGPELogo = new GPE_Label_Image(GPE_LOGO);
    labelImgGPELogo->hasLineBreak = true;
    labelImgGPELogo->resizeAspect = 0.667;
 }

gamePencilStartPageResource::~gamePencilStartPageResource()
{
    record_error("Starting to delete start page...");
    subViewedSpace.x = GENERAL_GPE_PADDING;
    subViewedSpace.x = GENERAL_GPE_PADDING;
    subViewedSpace.w = 400;
    subViewedSpace.h = 400;
    resourceType = -2;
    subResouceId = -2;
    parentProjectName = "";
    record_error("Deleting recent project lists...");
    GPE_TextURL * tUrlHolder = NULL;
    int i = 0;

    record_error("Deleting helpful website links..");
    for( i = 0; i <(int)helpfulWebLinks.size(); i++)
    {
       tUrlHolder = helpfulWebLinks[i];
       if( tUrlHolder!=NULL)
       {
           delete tUrlHolder;
           tUrlHolder = NULL;
           helpfulWebLinks[i] = NULL;
       }
    }
    helpfulWebLinks.clear();
    record_error("Deleting Project Browser....");
    if( projectBrowserButton!=NULL)
    {
        delete projectBrowserButton;
        projectBrowserButton = NULL;
    }
    if( startPageList!=NULL)
    {
        delete startPageList;
        startPageList = NULL;
    }
    record_error("Deleting editor shortcuts....");
    if( labelEditorShortcuts!=NULL)
    {
        delete labelEditorShortcuts;
        labelEditorShortcuts = NULL;
    }
    record_error("Deleting helpful links....");
    if( labelHelpfulLinks!=NULL)
    {
        delete labelHelpfulLinks;
        labelHelpfulLinks = NULL;
    }
    record_error("Deleting copyright info....");
    if( labelCopyrightInfo!=NULL)
    {
        delete labelCopyrightInfo;
        labelCopyrightInfo = NULL;
    }
    record_error("Deleting version info....");
    if( labelVersionInfo!=NULL)
    {
        delete labelVersionInfo;
        labelVersionInfo = NULL;
    }
    record_error("Deleting gpe img logo....");
    if( labelImgGPELogo!=NULL)
    {
        delete labelImgGPELogo;
        labelImgGPELogo = NULL;
    }
    record_error("Startpage successfully deleted....");
}

void gamePencilStartPageResource::prerender_self(GPE_Renderer * cRender)
{

}

void gamePencilStartPageResource::preprocess_self(std::string alternatePath)
{

}

void gamePencilStartPageResource::process_self(SDL_Rect * viewedSpace , SDL_Rect *cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( viewedSpace!=NULL && cam!=NULL && startPageList!=NULL)
    {
        subViewedSpace.x = 0;
        subViewedSpace.y = 0;
        subViewedSpace.w = viewedSpace->w;
        subViewedSpace.h = viewedSpace->h;

        startPageList->set_coords(subViewedSpace.x,subViewedSpace.y);
        startPageList->set_width(subViewedSpace.w);
        startPageList->set_height(subViewedSpace.h);
        startPageList->barXPadding = 0;
        startPageList->barXMargin = 0;

        startPageList->clear_list();
        //labelImgGPELogo->set_image(GPE_LOGO);
        startPageList->add_gui_element(labelImgGPELogo,true);
        startPageList->add_gui_element(labelCopyrightInfo,true);
        startPageList->add_gui_element(labelVersionInfo,true);
        startPageList->add_gui_element(labelEditorShortcuts,true);
        startPageList->add_gui_element(projectBrowserButton,false);
        startPageList->add_gui_element(forumPageButton,true);
        startPageList->add_gui_element(helpPageButton,false);
        startPageList->add_gui_element(tipOfTheDayButton,true);
        startPageList->yScroll->documentActions = true;

        startPageList->add_gui_element(labelHelpfulLinks,true);
        for( int i = 0 ; i < (int)helpfulWebLinks.size(); i++)
        {
            startPageList->add_gui_element( helpfulWebLinks[i] ,true);
        }
        /*Patreon Area
        startPageList->add_gui_element(labelPatreon,true);
        startPageList->add_gui_element(labelPatreonLogo,true);
        startPageList->add_gui_element(labelPatreonDescription,true);
        startPageList->add_gui_element(urlPatreonPage,true);
        */

        startPageList->process_self(viewedSpace,cam);

        //Get individual processes here
        if( projectBrowserButton->is_clicked() )
        {
            GPE_Main_TabManager->add_new_tab(PROJECT_BROWSER_PAGE);
        }
        else if( tipOfTheDayButton->is_clicked() )
        {
            GPE_Show_Tip_Of_Day();
        }
        else if( helpPageButton->is_clicked() )
        {
            GPE_Main_TabManager->add_new_tab(MAIN_HELP_PAGE);
        }
    }
}

void gamePencilStartPageResource::render_self(GPE_Renderer * cRender,SDL_Rect * viewedSpace, SDL_Rect * cam, bool forceRedraw )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( viewedSpace!=NULL && startPageList!=NULL)
    {
        //render_rect(cRender,&subViewedSpace,GPE_MAIN_TEMPLATE->Program_Header_Color,false);
        //render_new_text(cRender,subViewedSpace.x+GENERAL_GPE_PADDING,subViewedSpace.y+GENERAL_GPE_PADDING,"Recent Projects",GPE_MAIN_TEMPLATE->Main_Box_Font_Color,textboxFont,FA_LEFT,FA_TOP);
        if( forceRedraw)
        {
            render_rectangle(cRender,0,0,viewedSpace->w,viewedSpace->h,GPE_MAIN_TEMPLATE->Program_Color,false);
            startPageList->render_self(cRender,viewedSpace,cam,forceRedraw);
        }
    }
}

void gamePencilStartPageResource::save_resource(std::string alternatePath, int backupId)
{
    bool usingAltSaveSource = false;
    isModified = false;
}

bool gamePencilStartPageResource::write_data_into_projectfile(std::ofstream * fileTarget, int nestedFoldersIn)
{
    return true;
}

tilesheetPreviewer::tilesheetPreviewer()
{
    showGrid = true;
    tileSheetToPreview = NULL;
    tsRenderRect.x = 0;
    tsRenderRect.y = 0;
    tsRenderRect.w = 0;
    tsRenderRect.h = 0;
    tsSelectedArea.x = 0;
    tsSelectedArea.y = 0;
    tsSelectedArea.w = 0;
    tsSelectedArea.h = 0;
    tileToPrevX1 = 0;
    tileToPrevX2 = 0;
    tileToPrevY1 = 0;
    tileToPrevY2 = 0;
    xTileScroll = new GPE_ScrollBar_XAxis();
    yTileScroll = new GPE_ScrollBar_YAxis();
}

tilesheetPreviewer::~tilesheetPreviewer()
{
    tilesIdsInPreview.clear();
    if( xTileScroll!=NULL)
    {
        delete xTileScroll;
        xTileScroll = NULL;
    }
    if( yTileScroll!=NULL)
    {
        delete yTileScroll;
        yTileScroll = NULL;
    }
}

void tilesheetPreviewer::process_self(SDL_Rect *viewedSpace, SDL_Rect *cam )
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    GPE_GeneralGuiElement::process_self(viewedSpace,cam);
    if( isClicked && RESOURCE_TO_DRAG==NULL )
    {
        hasScrollControl = true;
        hasArrowkeyControl = true;
    }
    else if( clickedOutside)
    {
        hasScrollControl = false;
        hasArrowkeyControl = false;
    }
    if(tileSheetToPreview!=NULL && cam!=NULL && viewedSpace!=NULL )
    {
        if( tileSheetToPreview->tsImage!=NULL)
        {
            tsRenderRect.w = tileSheetToPreview->tsImage->get_width();
            tsRenderRect.h = tileSheetToPreview->tsImage->get_height();
            if( tileSheetToPreview->tsImage->get_width() > barBox.w-16)
            {
                tsRenderRect.w = barBox.w-16;
            }
            if( tileSheetToPreview->tsImage->get_height() > barBox.h-16)
            {
                tsRenderRect.h = barBox.h-16;
            }

            if( isHovered && RESOURCE_TO_DRAG==NULL && !userInput->check_keyboard_down(kb_ctrl) )
            {
                if( userInput->shiftKeyIsPressed )
                {
                    if( userInput->mouseScrollingUp > 0 )
                    {
                        tsRenderRect.x-=tsRenderRect.w/8;
                    }
                    else if( userInput->mouseScrollingDown > 0 )
                    {
                        tsRenderRect.x+=tsRenderRect.w/8;
                    }
                }
                else
                {
                    if( userInput->mouseScrollingUp > 0 )
                    {
                        tsRenderRect.y-= tsRenderRect.h/4;
                    }
                    else if( userInput->mouseScrollingDown > 0 )
                    {
                        tsRenderRect.y+=tsRenderRect.h/4;
                    }
                }
            }


            if( hasScrollControl && RESOURCE_TO_DRAG==NULL )
            {
                if( userInput->check_keyboard_down(kb_left) )
                {
                    tsRenderRect.x-=tsRenderRect.w/8;
                }
                else if( userInput->check_keyboard_down(kb_right)  )
                {
                    tsRenderRect.x+=tsRenderRect.w/8;
                }

                if( userInput->check_keyboard_down(kb_up) )
                {
                    tsRenderRect.y-=tsRenderRect.h/8;
                }
                else if( userInput->check_keyboard_down(kb_down)  )
                {
                    tsRenderRect.y+=tsRenderRect.h/8;
                }
            }

            //select tiles to place
            xTileScroll->barBox.x = barBox.x;
            xTileScroll->barBox.y = barBox.y+barBox.h-16;
            xTileScroll->barBox.w = barBox.w;
            xTileScroll->barBox.h = 16;

            xTileScroll->fullRect.x = 0;
            xTileScroll->fullRect.y = 0;
            xTileScroll->fullRect.w = tileSheetToPreview->tsImage->get_width();
            xTileScroll->fullRect.h = tileSheetToPreview->tsImage->get_height();

            xTileScroll->contextRect.x = tsRenderRect.x;
            xTileScroll->contextRect.y = tsRenderRect.y;
            xTileScroll->contextRect.w = tsRenderRect.w;
            xTileScroll->contextRect.h = tsRenderRect.h;

            xTileScroll->process_self(viewedSpace,cam,true);
            tsRenderRect.x = xTileScroll->contextRect.x;
            yTileScroll->barBox.x = barBox.x+barBox.w-16;

            yTileScroll->barBox.y = barBox.y;
            yTileScroll->barBox.w = 16;
            yTileScroll->barBox.h = barBox.h;

            yTileScroll->fullRect.x = 0;
            yTileScroll->fullRect.y = 0;
            yTileScroll->fullRect.w = tileSheetToPreview->tsImage->get_width();
            yTileScroll->fullRect.h = tileSheetToPreview->tsImage->get_height();

            yTileScroll->contextRect.x = tsRenderRect.x;
            yTileScroll->contextRect.y = tsRenderRect.y;
            yTileScroll->contextRect.w = tsRenderRect.w;
            yTileScroll->contextRect.h = tsRenderRect.h;

            yTileScroll->process_self(viewedSpace,cam,true);
            tsRenderRect.y = yTileScroll->contextRect.y;


            if( isHovered)
            {
                //Calculates the tile to select via the tilesheet
                if( xTileScroll->is_scrolling()==false && yTileScroll->is_scrolling()==false  && RESOURCE_TO_DRAG==NULL )
                {
                    if( point_between(userInput->mouse_x,userInput->mouse_y,
                                      viewedSpace->x-cam->x+barBox.x,
                                      viewedSpace->y-cam->y+barBox.y,
                                      viewedSpace->x-cam->x+barBox.x+tsRenderRect.w,
                                      viewedSpace->y-cam->y+barBox.y+tsRenderRect.h
                                      )
                    )
                    {
                        SDL_Rect foundTSRect;
                        int iTSX = 0;

                        if( userInput->check_mouse_pressed(0) )
                        {
                            tileToPrevX1 = userInput->mouse_x-viewedSpace->x+cam->x-barBox.x+tsRenderRect.x;
                            tileToPrevY1 = userInput->mouse_y-viewedSpace->y+cam->y-barBox.y+tsRenderRect.y;
                            for(  iTSX = 0; iTSX < (int)tileSheetToPreview->tsRects.size(); iTSX++)
                            {
                                foundTSRect = tileSheetToPreview->tsRects.at(iTSX);

                                if( point_between_rect(tileToPrevX1,tileToPrevY1,&foundTSRect) )
                                {
                                    tileToPrevX1 =tileToPrevX2 = foundTSRect.x;
                                    tileToPrevY1 =tileToPrevY2 = foundTSRect.y;
                                    break;
                                }
                            }

                        }
                        if( userInput->check_mouse_down(0) )
                        {
                            tileToPrevX2 = userInput->mouse_x-viewedSpace->x+cam->x-barBox.x+tsRenderRect.x;
                            tileToPrevY2 = userInput->mouse_y-viewedSpace->y+cam->y-barBox.y+tsRenderRect.y;
                            tsSelectedArea.w = tileSheetToPreview->tsWidth;
                            tsSelectedArea.h = tileSheetToPreview->tsHeight;
                            for(  iTSX = 0; iTSX < (int)tileSheetToPreview->tsRects.size(); iTSX++)
                            {
                                foundTSRect = tileSheetToPreview->tsRects.at(iTSX);

                                if( point_between_rect(tileToPrevX2,tileToPrevY2,&foundTSRect) )
                                {
                                    tileToPrevX2 = foundTSRect.x;
                                    tileToPrevY2 = foundTSRect.y;
                                    break;
                                }
                            }


                            if( tileToPrevX1!=tileToPrevX2)
                            {
                                tsSelectedArea.x = std::min(tileToPrevX1,tileToPrevX2);
                                tsSelectedArea.w += abs(tileToPrevX1-tileToPrevX2);
                            }
                            else
                            {
                                tsSelectedArea.x = tileToPrevX1;
                            }

                            if( tileToPrevY1!=tileToPrevY2)
                            {
                                tsSelectedArea.y = std::min(tileToPrevY1,tileToPrevY2);
                                tsSelectedArea.h += abs(tileToPrevY1-tileToPrevY2);

                            }
                            else
                            {
                                tsSelectedArea.y = tileToPrevY1;
                            }
                            //int tileRowItr = 0;
                            //int tilesItr= 0;
                            //int newTileX = 0, newTileY = 0;
                            tilesIdsInPreview.clear();
                            bool yValueChanged = false;
                            tilesToPlacePerRow = 0;
                            int firstY = -1;
                            for(  iTSX = 0; iTSX < (int)tileSheetToPreview->tsRects.size(); iTSX++)
                            {
                                foundTSRect = tileSheetToPreview->tsRects.at(iTSX);

                                if( check_collision(tsSelectedArea,foundTSRect) )
                                {
                                    if( firstY < 0)
                                    {
                                        firstY = foundTSRect.y;
                                    }
                                    else if( yValueChanged==false && firstY!=foundTSRect.y)
                                    {
                                        yValueChanged = true;
                                        tilesToPlacePerRow = (int)tilesIdsInPreview.size();
                                    }
                                    tilesIdsInPreview.push_back(iTSX);
                                }
                            }
                            if( yValueChanged==false)
                            {
                                tilesToPlacePerRow = (int)tilesIdsInPreview.size();
                            }
                        }
                        else if( isRightClicked)
                        {
                            GPE_open_context_menu();
                            MAIN_CONTEXT_MENU->set_width(256);
                            if( showGrid)
                            {
                                MAIN_CONTEXT_MENU->add_menu_option("Show Grid",1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/check.png"),-1,NULL,true,true,false);
                            }
                            else
                            {
                                MAIN_CONTEXT_MENU->add_menu_option("Show Grid",1,NULL,-1,NULL,true,true,false );
                            }
                            int menuSelection = get_popupmenu_result();
                            if( menuSelection==0 && GPE_Main_TabManager!=NULL && tileSheetToPreview!=NULL)
                            {
                                //GPE_Main_TabManager->add_new_tab(tileSheetToPreview);
                            }
                            else if( menuSelection==1)
                            {
                                showGrid = !showGrid;
                            }
                        }
                    }
                    else if( isHovered && userInput->check_mouse_released(-1) )
                    {
                        reset_preview(false);
                    }
                }
            }
            else if( userInput->check_mouse_released(1) || userInput->check_mouse_released(2) )
            {
                reset_preview(false);
            }
        }
        else
        {
            //reset tile preview data
            reset_preview(true);
        }
    }
}

void tilesheetPreviewer::render_self(GPE_Renderer * cRender,SDL_Rect *viewedSpace , SDL_Rect *cam , bool forceRedraw)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && tileSheetToPreview!=NULL && cam!=NULL && viewedSpace!=NULL )
    {
        if(tileSheetToPreview->tsImage!=NULL)
        {
            tileSheetToPreview->tsImage->render_tex(cRender,barBox.x-cam->x,barBox.y-cam->y,&tsRenderRect);
            if( showGrid)
            {
                SDL_Rect foundTSRect;
                int iTSX = 0;
                int bx1 = 0;
                int bx2 = 0;
                int by1 = 0;
                int by2 = 0;
                for(  iTSX = 0; iTSX < (int)tileSheetToPreview->tsRects.size(); iTSX++)
                {
                    foundTSRect = tileSheetToPreview->tsRects.at(iTSX);
                    bx1 =foundTSRect.x - tsRenderRect.x;
                    bx1 = bound_number(bx1,0, barBox.w);

                    by1 =foundTSRect.y - tsRenderRect.y;
                    by1 = bound_number(by1,0, barBox.h);

                    bx2 =foundTSRect.x+foundTSRect.w - tsRenderRect.x;
                    bx2 = bound_number(bx2,0, barBox.w);

                    by2 =foundTSRect.y+foundTSRect.h - tsRenderRect.y;
                    by2 = bound_number(by2,0, barBox.h);

                    render_rectangle(cRender,barBox.x+bx1-cam->x,barBox.y+by1-cam->y,barBox.x+bx2-cam->x,barBox.y+by2-cam->y,GPE_MAIN_TEMPLATE->Text_Box_Font_Color,true,255);
                }
            }
            if( tsSelectedArea.x >=0 && tsSelectedArea.y >=0)
            {
                double renderTSSelectX1 = tsSelectedArea.x;
                renderTSSelectX1+=barBox.x-tsRenderRect.x;
                renderTSSelectX1 = bound_number(renderTSSelectX1,barBox.x,barBox.x+barBox.w);

                double renderTSSelectY1 = tsSelectedArea.y;
                renderTSSelectY1+=barBox.y-tsRenderRect.y;
                renderTSSelectY1 = bound_number(renderTSSelectY1,barBox.y,barBox.y+barBox.h);

                double renderTSSelectX2 = tsSelectedArea.x+tsSelectedArea.w;
                renderTSSelectX2+=barBox.x-tsRenderRect.x;
                renderTSSelectX2 = bound_number(renderTSSelectX2,barBox.x,barBox.x+barBox.w);

                double renderTSSelectY2 = tsSelectedArea.y+tsSelectedArea.h;
                renderTSSelectY2+=barBox.y-tsRenderRect.y;
                renderTSSelectY2 = bound_number(renderTSSelectY2,barBox.y,barBox.y+barBox.h);

                render_rectangle(cRender,renderTSSelectX1,renderTSSelectY1,renderTSSelectX2,renderTSSelectY2,GPE_MAIN_TEMPLATE->Button_Box_Highlighted_Color,false,128);
            }
            if( xTileScroll!=NULL)
            {
                xTileScroll->render_self(cRender,viewedSpace,cam);
            }
            if( yTileScroll!=NULL)
            {
                yTileScroll->render_self(cRender,viewedSpace,cam);
            }
            //render_new_text(cRender,xTileScroll->barBox.x,xTileScroll->barBox.x)
        }
    }
}

void tilesheetPreviewer::render_selection(GPE_Renderer * cRender, int xPos, int yPos,SDL_Rect *viewedSpace , SDL_Rect *cam , bool forceRedraw, double scaleSize, GPE_Color * fColor)
{
    viewedSpace = GPE_find_camera(viewedSpace);
    cam = GPE_find_camera(cam);
    if( forceRedraw && tileSheetToPreview!=NULL && cam!=NULL && viewedSpace!=NULL && scaleSize!=0 )
    {
        if(tileSheetToPreview->tsImage!=NULL)
        {
            if( tsSelectedArea.x >=0 && tsSelectedArea.y >=0 && tsSelectedArea.w  >0 && tsSelectedArea.h > 0 )
            {
                if( tsSelectedArea.x+tsSelectedArea.w <= tileSheetToPreview->tsImage->get_width() && tsSelectedArea.y+tsSelectedArea.h <= tileSheetToPreview->tsImage->get_height()  )
                {
                    tileSheetToPreview->tsImage->render_tex_resized(cRender,xPos-cam->x,yPos-cam->y,tsSelectedArea.w*scaleSize,tsSelectedArea.h*scaleSize, &tsSelectedArea,NULL,fColor );
                }
            }
        }
    }
}

void tilesheetPreviewer::reset_preview(bool moveCamera)
{
    tilesIdsInPreview.clear();
    if( moveCamera)
    {
        tsRenderRect.x = 0;
        tsRenderRect.y = 0;
        tsRenderRect.w = 0;
        tsRenderRect.h = 0;
    }
    tsSelectedArea.x = 0;
    tsSelectedArea.y = 0;
    tsSelectedArea.w = 0;
    tsSelectedArea.h = 0;
    tileToPrevX1 = tileToPrevY1 = tileToPrevX2 = tileToPrevY2 = 0;
}

//
GPE_Editor_State::GPE_Editor_State()
{
    for(int rI = 0; rI < res_type_count; rI++)
    {
        RESOURCE_TYPE_NAMES[rI] = "";
    }

    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_SPRITE] = "Sprite";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_TEXTURE] = "Texture";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_TILESHEET] = "Tilesheet";

    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_AUDIO] = "Audio";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_VIDEO] = "Video";

    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_FUNCTION] = "Function";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_OBJECT] = "Object";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_SCENE] = "Scene";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_ACHIEVEMENT] = "Achievement";

    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_PATH] = "Path";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_DICTIONARY] = "Dictionary";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_FONT] = "Font";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_PLUGIN] = "Plugin";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_EVENT] = "Event";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_QUEST] = "Quest";
    RESOURCE_TYPE_NAMES[RESOURCE_TYPE_PROJECT_SETTINGS] = "Project Properties";

    for(int bI = 0; bI < GPE_BUILD_OPTIONS; bI++)
    {
        GPE_BUILD_NAMES[bI] = "";
    }
    GPE_BUILD_NAMES[GPE_BUILD_HTML5] = "HTML5";
    GPE_BUILD_NAMES[GPE_BUILD_WINDOWS] = "WINDOWS";
    GPE_BUILD_NAMES[GPE_BUILD_MAC] = "OSX";
    GPE_BUILD_NAMES[GPE_BUILD_LINUX] = "LINUX";
    GPE_BUILD_NAMES[GPE_BUILD_WIIU] = "WIIU";
    GPE_BUILD_NAMES[GPE_BUILD_XBOXONE] = "XBOXONE";
    GPE_BUILD_NAMES[GPE_BUILD_PS4] = "PS4";
    GPE_BUILD_NAMES[GPE_BUILD_PSVITA] = "PSVITA";
    GPE_BUILD_NAMES[GPE_BUILD_ANDROID] = "ANDROID";
    GPE_BUILD_NAMES[GPE_BUILD_IOS] = "IOS";
    GPE_BUILD_NAMES[GPE_BUILD_WINDOWS_PHONE] = "WINDOWS PHONE";
    //Gets SDL Version
    GPE_RadioButton_GFX = rsm->sprite_add(APP_DIRECTORY_NAME+"resources/gfx/sprites/spr_radio_button.png",3,true,0,0,false);
    GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
    SDL_compiled_version.major = 0;
    SDL_VERSION(&SDL_compiled_version);
    SDL_VersionText = "SDL Version: "+int_to_string(SDL_compiled_version.major)+"."+int_to_string(SDL_compiled_version.minor)+"."+int_to_string(SDL_compiled_version.patch);

    spriteDataLabels[sprFrameCount] = "Frame Count";
    spriteDataLabels[sprFrameWidth] = "Frame Width";
    spriteDataLabels[sprFrameHeight] = "Frame Height";
    spriteDataLabels[sprHPixelOffset] = "Horizontal Pixel  Offset";
    spriteDataLabels[sprVPixelOffset] = "Vertical Pixel Offset";
    spriteDataLabels[sprHPixelPadding] = "Horizontal Frame Padding";
    spriteDataLabels[sprVPixelPadding] = "Vertictal Frame Padding";

    tsDataLabels[0] = "Width";
    tsDataLabels[1] = "Height";
    tsDataLabels[2] = "X-Offset";
    tsDataLabels[3] = "Y-Offset";
    tsDataLabels[4] = "H-Padding";
    tsDataLabels[5] = "Y-Padding";

    spriteDataLabelWidth =  0;
    int hh=0; // the 8th position is the widest
    DEFAULT_FONT->get_metrics(spriteDataLabels[sprHPixelPadding].c_str(),&spriteDataLabelWidth,&hh);
    tsDataLabelWidth = 0;
    DEFAULT_FONT->get_metrics(tsDataLabels[5].c_str(),&tsDataLabelWidth,&hh);

    POPUP_FONT_SIZE_WIDTH = 12;
    POPUP_FONT_SIZE_HEIGHT = 12;
    if( FONT_POPUP!=NULL)
    {
         FONT_POPUP->get_metrics("A",&POPUP_FONT_SIZE_WIDTH,&POPUP_FONT_SIZE_HEIGHT);
    }
    spriteDataLabelWidth+=GENERAL_ICON_WIDTH_AND_PADDING; //add some extra padding for "just in case"
    for( int iLangName = 0; iLangName < PROJECT_LANGUAGE_MAX; iLangName++)
    {
        PROJECT_LANGUAGE_NAMES[iLangName] = "";
    }
    PROJECT_LANGUAGE_NAMES[PROJECT_LANGUAGE_JS] = "JS";
    PROJECT_LANGUAGE_NAMES[PROJECT_LANGUAGE_CS] = "CS";
    PROJECT_LANGUAGE_NAMES[PROJECT_LANGUAGE_CPP] = "CPP";
    PROJECT_LANGUAGE_NAMES[PROJECT_LANGUAGE_TST] = "TST";
    PROJECT_LANGUAGE_NAMES[PROJECT_LANGUAGE_LUA] = "LUA";

    DEFAULT_OBJECT_FUNCTIONS_NAMES[0] = "Constructor";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[1] = "Destructor";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[2] = "Start Frame";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[3] = "Main Logic";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[4] = "Sprite Done";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[5] = "End Frame";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[6] = "PRE-Render";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[7] = "Render";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[8] = "POST-Render";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[9] = "Render HUD";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[10] = "";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[11] = "";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[12] = "";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[13] = "";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[14] = "";
    DEFAULT_OBJECT_FUNCTIONS_NAMES[15] = "";

    DEFAULT_OBJECT_SPECIALS_NAMES[0] = "Scene Start";
    DEFAULT_OBJECT_SPECIALS_NAMES[1] = "Scene End";
    DEFAULT_OBJECT_SPECIALS_NAMES[2] = "Game Start";
    DEFAULT_OBJECT_SPECIALS_NAMES[3] = "Game Exit";
    DEFAULT_OBJECT_SPECIALS_NAMES[4] = "Player Died";
    DEFAULT_OBJECT_SPECIALS_NAMES[5] = "Game Over";


    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[0] = "Constructor";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[1] = "self_obliterate";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[2] = "start_frame_logic";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[3] = "perform_object_logic";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[4] = "animation_concluded";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[5] = "end_frame_logic";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[6] = "render_under";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[7] = "render_self";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[8] = "render_above";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[9] = "render_hud";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[10] = "";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[11] = "";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[12] = "";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[13] = "";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[14] = "";
    DEFAULT_OBJECT_FUNCTIONS_HTML5_NAMES[15] = "";

    DEFAULT_OBJECT_SPECIALS_HTML5_NAMES[0] = "scene_start";
    DEFAULT_OBJECT_SPECIALS_HTML5_NAMES[1] = "scene_end";
    DEFAULT_OBJECT_SPECIALS_HTML5_NAMES[2] = "game_start";
    DEFAULT_OBJECT_SPECIALS_HTML5_NAMES[3] = "game_exit";
    DEFAULT_OBJECT_SPECIALS_HTML5_NAMES[4] = "player_died";
    DEFAULT_OBJECT_SPECIALS_HTML5_NAMES[5] = "game_over";

    DEFAULT_SCENE_SUBEDITOR_NAMES[0] = "Settings";
    DEFAULT_SCENE_SUBEDITOR_NAMES[1] = "Layers";
    DEFAULT_SCENE_SUBEDITOR_NAMES[2] = "Extras";
    DEFAULT_SCENE_SUBEDITOR_NAMES[3] = "Extras";
    DEFAULT_SCENE_SUBEDITOR_NAMES[3] = "Extras";

    SUPPORTED_AUDIO_EXT[aacFileName] = "AAC";
    SUPPORTED_AUDIO_EXT[mp3FileName] = "MP3";
    SUPPORTED_AUDIO_EXT[oggFileName] = "OGG";
    SUPPORTED_AUDIO_EXT[wavFileName] = "WAV";


    SUPPORTED_VIDEO_EXT[0] = "MP4";
    SUPPORTED_VIDEO_EXT[1] = "WEBM";
    SUPPORTED_VIDEO_EXT[2] = "OGG";

    SUPPORTED_FONT_EXT[FONT_EOT]  = "EOT";
    SUPPORTED_FONT_EXT[FONT_SVG]  = "SVG";
    SUPPORTED_FONT_EXT[FONT_TTF]  = "TTF";
    SUPPORTED_FONT_EXT[FONT_WOFF] = "WOFF";
    SUPPORTED_FONT_EXT[FONT_WOFF2] = "WOFF2";

    mainToolBar = GPE_MAIN_GUI->init_toolbar();

    GPE_Sprite * mainExportOptionsSprite = rsm->sprite_add(APP_DIRECTORY_NAME+"resources/gfx/sprites/main_export_options_icons.png",12,true,0,0,false);
    mainButtonBar = new GPE_ToolIconButtonBar(0, mainToolBar->get_height(),24);
    mainButtonBar->widthAutoResizes = true;
    mainButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/binoculars.png","Project Browser",0,true );
    mainButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/file.png","New Project",1,true );
    mainButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/folder.png","Open Project",2,true );
    mainButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/save.png","Save Project",3,false );
    mainButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/book.png","Save All Projects",4,true );
    mainButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/cog.png","Build Project",5,false);
    mainButtonBar->adkb_dton(APP_DIRECTORY_NAME+"resources/gfx/buttons/play.png","Build & PLAY Project",6,false);

    GPE_PopUpMenu_Option * newOption = NULL;
    GPE_PopUpMenu_Option * newOptionLayer2 = NULL;
    GPE_PopUpMenu_Option * newOptionLayer3 = NULL;
    newOption = mainToolBar->add_menu_option("File");
    newOption->add_menu_option("New Project",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file.png"),-1,NULL,false,true,false,kb_ctrl,kb_n );
    newOption->add_menu_option("Open Project",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/folder.png"),-1,NULL,false,true,false,kb_ctrl,kb_o );
    newOption->add_menu_option("Browse Projects",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/binoculars.png") );
    newOptionLayer2 = MAIN_TOOLBAR_RECENT_PROJECTS = newOption->add_menu_option("Recent Projects",-1,NULL,-1,NULL,true);
    GPE_MAIN_GUI->update_recent_project_list(false);
    //Adds the recent projects to the list

    //Adds the recent files to the list
    newOption->add_menu_option("Save Project",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/save.png"),-1,NULL,false,true,false,kb_ctrl,kb_s  );
    newOption->add_menu_option("Save All Projects",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/save.png") ,-1,NULL,false,true,false,kb_ctrl,kb_s ,kb_shift );
    /*
    newOption->add_menu_option("Export",-1,-1,NULL,false);
    newOption->add_menu_option("Import Resources");
    newOption->add_menu_option("Export Resources");
    newOption->add_menu_option("Properties",-1,5,NULL,true);
    */
    newOption->add_menu_option("Quit Editor",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/truck.png"),76,NULL,false,true,false,kb_ctrl,kb_q);


    /*
    newOption = mainToolBar->add_menu_option("Edit");
    newOption->add_menu_option("Undo",-1,-1,NULL,false);
    newOption->add_menu_option("Redo",-1,-1,NULL,false);
    newOption->add_menu_option("Cut",-1,-1,NULL,false);
    newOption->add_menu_option("Copy",-1,-1,NULL,false,false);
    newOption->add_menu_option("Paste",-1,-1,NULL,false);
    */

    newOption = mainToolBar->add_menu_option("View");
    //newOption->add_menu_option("Reset View",-1,-1,NULL,false);

    newOption->add_menu_option("Toggle Fullscreen Mode",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/crop.png"),-1,NULL,false,true,false, kb_f11);

    newOptionLayer2 = newOption->add_menu_option("Resource Bar Settings",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/cogs.png"),-1,NULL,false,false);
    newOptionLayer2->add_menu_option("Left Align Resource Bar",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/align-left.png"),-1,NULL,false);
    newOptionLayer2->add_menu_option("Right Align Resource Bar",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/align-right.png"),-1,NULL,false);
    newOptionLayer2->add_menu_option("Toggle Resource Bar On/Off",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/toggle-on.png"),-1,NULL,false);
    newOptionLayer2 = newOption->add_menu_option("Text Area Settings",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/cogs.png"),-1,NULL,false,false);
    newOptionLayer2->add_menu_option("Toggle Line Count",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/toggle-on.png"),-1,NULL,false);
    newOptionLayer2->add_menu_option("Toggle Synthax Highlighting",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/toggle-on.png"),-1,NULL,false);
    //newOptionLayer2->add_menu_option("",-1,-1,NULL,false);

    newOptionLayer2 = newOption->add_menu_option("Editor Color Theme",-1,NULL,-1,NULL,false,false);
    newOptionLayer2->add_menu_option("Use Light Color Theme",-1,NULL,-1,NULL,false);
    /*
    newOptionLayer2->add_menu_option("Use Dark Color Theme",-1,NULL,-1,NULL,false);

    newOptionLayer2->add_menu_option("Use Red Color Theme",-1,NULL,-1,NULL,false);
    newOptionLayer2->add_menu_option("Use Green Color Theme",-1,NULL,-1,NULL,false);
    newOptionLayer2->add_menu_option("Use Blue Color Theme",-1,NULL,-1,NULL,false);*/
    newOptionLayer2->add_menu_option("Use Default Color Theme",-1,NULL,-1,NULL,false);

    newOptionLayer3 = newOptionLayer2->add_menu_option("Custom Themes",-1,NULL,-1,NULL,false,false);

    newOption->add_menu_option("Start Page",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/cube.png"),-1,NULL,false);
    newOption->add_menu_option("Tip of the Day",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/info.png"),-1,NULL,false);
    newOption->add_menu_option("Report Issue",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/bug.png"),-1,NULL,false);

    std::string customThemeFolder = APP_DIRECTORY_NAME+"themes/custom";

    //Used for searching directories
    int iFile;
    std::string fileToClick = "";
    GPE_FileDirectory * dir = new GPE_FileDirectory();
    GPE_File * file = NULL;
    if( dir!=NULL)
    {
        dir->open_directory(customThemeFolder);
        for (iFile = 0; iFile < (int)dir->get_count(); iFile++)
        {
            file = dir->get_file(iFile);
            if( file!=NULL)
            {
                fileToClick = file->get_name();
                if( fileToClick!="." && fileToClick!="..")
                {
                    if( file->is_directory()==false )
                    {
                        newOptionLayer3->add_menu_option(fileToClick,-1);
                    }
                }
            }
        }
        delete dir;
        dir = NULL;
    }

    newOptionLayer2->add_menu_option("Find Themes on itch.io",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/sun-o.png"),-1,NULL,false);

    //newOption = mainToolBar->add_menu_option("Tools");
    //newOption = mainToolBar->add_menu_option("Resources");

    newOption = mainToolBar->add_menu_option("Search");
    newOption->add_menu_option("Find...",-1,NULL,-1,NULL,false,true,false, kb_ctrl,kb_f);
    newOption->add_menu_option("Find in files...",-1,NULL,-1,NULL,false,true,false, kb_ctrl,kb_f,kb_shift);
    newOption->add_menu_option("Replace...",-1,NULL,-1,NULL,false,true,false, kb_ctrl,kb_r);
    newOption->add_menu_option("Replace in files....",-1,NULL,-1,NULL,false,true,false, kb_ctrl,kb_r,kb_shift);
    newOption->add_menu_option("Goto Line...",-1,NULL,-1,NULL,false,true,false, kb_ctrl,kb_g);
    newOption->add_menu_option("Find Project Resource...",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/search.png"),-1,NULL,false);

    newOption = mainToolBar->add_menu_option("Import");
    newOption->add_menu_option("Import Tilesheet");
    newOption->add_menu_option("Import Sprite");
    newOption->add_menu_option("Import Texture");
    newOption->add_menu_option("Import Audio");
    newOption->add_menu_option("Import Video");
    newOption->add_menu_option("Import Function");
    newOption->add_menu_option("Import Object");
    newOption->add_menu_option("Import Scene");
    newOption->add_menu_option("Import Font");

    newOption = mainToolBar->add_menu_option("Build");
    // HTML5/ Web platforms

    newOption->add_menu_option("Build HTML5 GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/html5.png"),-1,NULL,true,true,false,kb_ctrl,kb_f5);
    newOption->add_menu_option("RUN HTML5 GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/play-circle.png"),-1,NULL,true,true,false,kb_f8);
    newOption->add_menu_option("Build HTML5 GAME & RUN",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/play.png"),-1,NULL,true,true,false,kb_f5);
    //desktop / laptop platforms
    if( GPE_FOUND_OS==GPE_IDE_WINDOWS)
    {
        newOption->add_menu_option("Build WINDOWS GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/windows.png"),-1,NULL,false,true );
        newOption->add_menu_option("Build OSX GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/apple.png"),-1,NULL,false,true );
        newOption->add_menu_option("Build LINUX GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/linux.png"),-1,NULL,true,true );
    }
    else if( GPE_FOUND_OS==GPE_IDE_MAC)
    {
        newOption->add_menu_option("Build OSX GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/apple.png"),-1,NULL,false,true );
        newOption->add_menu_option("Build LINUX GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/linux.png"),-1,NULL,true,true );
        newOption->add_menu_option("Build WINDOWS GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/windows.png"),-1,NULL,false,true );
    }
    else
    {
        newOption->add_menu_option("ExpBuildort LINUX GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/linux.png"),-1,NULL,true,true );
        newOption->add_menu_option("Build WINDOWS GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/windows.png"),-1,NULL,false,true );
        newOption->add_menu_option("Build OSX GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/apple.png"),-1,NULL,false,true );
    }
    /*
    newOption->add_menu_option("Compile Current Tab",-1);
    newOption->add_menu_option("OUYA- P2",-1,5,mainExportOptionsSprite,false,false);
    */

    //console platforms
    /*newOptionLayer2 =newOption->add_menu_option("Build Nintendo WiiU GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/sprites/nintendo_wiiu_logo.png"),-1,NULL,true,true);
    newOptionLayer2->renderWhite = true;
    newOptionLayer2 =newOption->add_menu_option("Build Nintendo Switch GAME",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/sprites/nintendo_switch_logo.png"),-1,NULL,true,true);
    newOptionLayer2->renderWhite = true;*/
    /*
    newOption->add_menu_option("Build Xbox One GAME",-1,3,mainExportOptionsSprite,true,false);
    */

    /*
    //handheld consoles
    newOptionLayer2 = newOption->add_menu_option("Handheld Platforms (Coming Soon)",-1);
    newOptionLayer2->add_menu_option("GCW-Zero- P3",-1,8,mainExportOptionsSprite,false);
    newOptionLayer2->add_menu_option("Nintendo 3DS & New 3DS- P3",-1,9,mainExportOptionsSprite,false,false);
    newOptionLayer2->add_menu_option("Open Pandora- P3",-1,10,mainExportOptionsSprite,false,false);
    newOptionLayer2->add_menu_option("Playstation Vita- P3",-1,11,mainExportOptionsSprite,false,false);

    //mobile platforms
    newOptionLayer2 = newOption->add_menu_option("Mobile Platforms(Coming Soon)",-1);
    newOptionLayer2->add_menu_option("Android - P4",-1,11,NULL,false,false);
    newOptionLayer2->add_menu_option("Blackberry - P5",-1,11,NULL,false,false);
    newOptionLayer2->add_menu_option("iPhones - P5",-1,11,NULL,false,false);
    newOptionLayer2->add_menu_option("Tizen Phones - P6",-1,11,NULL,false,false);
    newOptionLayer2->add_menu_option("Ubuntu Phones - P6",-1,11,NULL,false,false);
    newOptionLayer2->add_menu_option("Windows Phones - P4",-1,11,NULL,false,false);
    */

    newOptionLayer2 = newOption->add_menu_option("Clean Build Folder",-1);
    newOptionLayer2->add_menu_option("Clean [HTML5] Build Folder",-1);
    if( GPE_MAIN_GUI->includeNintendoWiiUExport )
    newOptionLayer2->add_menu_option("Clean [WiiU] Build Folder",-1);
    newOptionLayer2->add_menu_option("Clean [Windows] Build Folder",-1);
    newOptionLayer2->add_menu_option("Clean [Linux] Build Folder",-1);
    newOptionLayer2->add_menu_option("Clean [OSX] Build Folder",-1);
    //newOptionLayer2->add_menu_option("Clean [HTML5] Build Folder",-1,-1,mainExportOptionsSprite,false);


    newOption = mainToolBar->add_menu_option("Settings");
    newOption->add_menu_option("User Settings",-1,NULL,-1,NULL,false,true,false,kb_f2);

    newOption = mainToolBar->add_menu_option("Help" );
    //newOption->add_menu_option("Online Documentation",-1,17,mainMenuSprite,false);
    //newOption->add_menu_option("Tips",-1,20,mainMenuSprite,false);
    //newOption->add_menu_option("Forums",-1);
    newOption->add_menu_option("General Help",-1,NULL,-1,NULL,false,true,false,kb_f1);
    newOption->add_menu_option("Online Documentation",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/book.png"),-1,NULL,false);
    newOption->add_menu_option("Online Forums",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/group.png"),-1,NULL,false);
    newOption->add_menu_option("Community Chat",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/comments.png"),-1,NULL,false);
    newOption->add_menu_option("Tip of the Day",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/infO.png"),-1,NULL,false);
    newOption->add_menu_option("Report Issue",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/bug.png"),-1,NULL,false);
    newOption->add_menu_option("Check Updates",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/question-circle.png"),-1,NULL,false);
    newOption->add_menu_option("License",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/file-text.png"),-1,NULL,false);
    newOption->add_menu_option("About Game Pencil Engine",-1,rsm->texture_add(APP_DIRECTORY_NAME+"resources/gfx/buttons/pencil.png"),-1,NULL,false,true,false,kb_ctrl,kb_b);
    //newOption->add_menu_option("Licenses",-1,27,mainMenuSprite,false);
    GPE_Main_TabManager->set_coords(-1,mainButtonBar->get_y2pos() );
    mainResourceBar = GPE_MAIN_GUI->init_resourcebar();
    //main resource bar elements

    country_language_image = new GPE_Texture();
    if(country_language_image!=NULL)
    {
        //country_language_image->load_new_texture(MAIN_RENDERER,APP_DIRECTORY_NAME+"resources/gfx/flags/24/us.png",-1,true);
    }

    //Load the background
    background = NULL;

    //Render the intro message
    message = NULL;
    if( GPE_MAIN_GUI!=NULL)
    {
        GPE_MAIN_GUI->load_settings();
        if( GPE_MAIN_GUI->showStartPageAtStartUp)
        {
            GPE_Main_TabManager->add_new_tab(MAIN_START_PAGE);
            MAIN_START_PAGE->set_name("Start Page");
        }

        /*if( GPE_MAIN_GUI->showTipsAtStartUp)
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
            userInput->handle(true);
            process_input();
            userInput->reset_all_input();
            apply_logic();
            render();
            MAIN_RENDERER->update_renderer();
            if( GPE_MAIN_GUI->showTipsAtStartUp)
            {
                GPE_Show_Tip_Of_Day();
            }
        }*/


        /*
        GPE_ProjectFolder * newProj = new GPE_ProjectFolder("New Project","here/","newproject.tgif");
        GPE_MAIN_GUI->gpeProjects.push_back(newProj);
        GPE_ProjectFolder * newExampleProj = new GPE_ProjectFolder("Examples","here/","examples.tgif");
        GPE_MAIN_GUI->gpeProjects.push_back(newExampleProj);
        */
    }
}

GPE_Editor_State::~GPE_Editor_State()
{
    //Free the surfaces
    delete background;
    delete message;
    if( GPE_MAIN_GUI!=NULL)
    {
        delete GPE_MAIN_GUI;
        GPE_MAIN_GUI = NULL;
    }
    if( GPE_RadioButton_GFX!=NULL)
    {
        delete GPE_RadioButton_GFX;
        GPE_RadioButton_GFX = NULL;
    }
}

void GPE_Editor_State::process_input()
{
    GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
    //if( MAIN_RENDERER->window_changed() )
    {
        //updates toolbars and whatnots info
        SCREEN_WIDTH = MAIN_RENDERER->get_window_width();
        SCREEN_HEIGHT= MAIN_RENDERER->get_window_height();
        reset_camera();
        mainToolBar->set_width(SCREEN_WIDTH);
        //mainButtonBar->set_width(SCREEN_WIDTH);
        mainButtonBar->set_coords( 0,32 );
        if( MAIN_EDITOR_SETTINGS!=NULL)
        {
            if( MAIN_EDITOR_SETTINGS->ideButtonBarSize!=NULL)
            {
                int foundButtonSize =  MAIN_EDITOR_SETTINGS->ideButtonBarSize->get_selected_value();
                mainButtonBar->set_height( foundButtonSize );
                if( MAIN_EDITOR_SETTINGS->ideButtonBarAlignment !=NULL && foundButtonSize > 0)
                {
                    int foundButtonBarAlignment = MAIN_EDITOR_SETTINGS->ideButtonBarAlignment->get_selected_value();
                    if( foundButtonBarAlignment==1)
                    {
                        mainButtonBar->set_coords( (SCREEN_WIDTH-mainButtonBar->get_width() )/2, 32 );
                    }
                    else if( foundButtonBarAlignment==2)
                    {
                        mainButtonBar->set_coords( (SCREEN_WIDTH-mainButtonBar->get_width() ), 32 );
                    }
                    else
                    {
                        mainButtonBar->set_coords( 0, 32 );
                    }
                }
                else
                {
                    mainButtonBar->set_coords( 0, 24 );
                }
            }
        }
        if( mainResourceBar->is_visible() )
        {
            GPE_Main_TabManager->set_width(SCREEN_WIDTH-mainResourceBar->get_width() );
        }
        else
        {
            GPE_Main_TabManager->set_width(SCREEN_WIDTH );
        }
        if( RENDER_RESOURCEBAR_LEFT)
        {
            mainResourceBar->set_coords( 0,mainButtonBar->get_y2pos()+GENERAL_GPE_PADDING );
            if( mainResourceBar->is_visible() )
            {
                GPE_Main_TabManager->set_coords(mainResourceBar->get_x2pos(),mainButtonBar->get_y2pos()+GENERAL_GPE_PADDING );
            }
            else
            {
                GPE_Main_TabManager->set_coords(0,mainButtonBar->get_y2pos() +GENERAL_GPE_PADDING);
            }
        }
        else
        {
            GPE_Main_TabManager->set_coords(0,mainButtonBar->get_y2pos() +GENERAL_GPE_PADDING);
            mainResourceBar->set_coords( GPE_Main_TabManager->get_x2pos(),mainButtonBar->get_y2pos()+GENERAL_GPE_PADDING );
        }

        GPE_Main_Statusbar->set_coords(0,SCREEN_HEIGHT-32);
        GPE_Main_Statusbar->set_height(32 );
        GPE_Main_Statusbar->set_width(SCREEN_WIDTH);

        if( GPE_Main_Logs->beingResized==false)
        {
            GPE_Main_Logs->set_coords(0,SCREEN_HEIGHT-GPE_Main_Statusbar->get_height()-GPE_Main_Logs->get_height() );
        }
        GPE_Main_Logs->set_width(SCREEN_WIDTH);

        mainResourceBar->set_height(SCREEN_HEIGHT-mainButtonBar->get_y2pos() -GPE_Main_Statusbar->get_height()-GPE_Main_Logs->get_height()-GENERAL_GPE_PADDING);
        GPE_Main_TabManager->set_height(SCREEN_HEIGHT-mainButtonBar->get_y2pos()-GPE_Main_Statusbar->get_height()-GPE_Main_Logs->get_height()- GENERAL_GPE_PADDING);
        /*
        mainResourceBar->set_height(SCREEN_HEIGHT-mainButtonBar->get_y2pos() -32-GENERAL_GPE_PADDING);
        GPE_Main_TabManager->set_height(SCREEN_HEIGHT-mainButtonBar->get_y2pos()-32- GENERAL_GPE_PADDING);
        */

    }

}

void GPE_Editor_State::apply_logic()
{
    GPE_MAIN_GUI->apply_logic();

    if( !mainToolBar->is_open() && !MAIN_CONTEXT_MENU->is_open() )
    {
        if( mainButtonBar!=NULL )
        {
            mainButtonBar->process_self();
            if( mainButtonBar->selectedOption>= 0 )
            {
                switch( mainButtonBar->selectedOption)
                {
                    case 0:
                        GPE_Main_TabManager->add_new_tab(PROJECT_BROWSER_PAGE);
                    break;
                    case 1:
                        GPE_MAIN_GUI->launch_new_project();
                    break;
                    case 2:
                        GPE_MAIN_GUI->open_new_project();
                    break;

                    case 3:
                        GPE_MAIN_GUI->save_current_project();
                    break;

                    case 4:
                        GPE_MAIN_GUI->save_all_projects();
                    break;

                    case 5:
                        if( CURRENT_PROJECT!=NULL && CURRENT_PROJECT->RESC_PROJECT_SETTINGS!=NULL )
                        {
                            GPE_Main_TabManager->add_new_tab(CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource() );
                            projectPropertiesResource * tProjectProps = (projectPropertiesResource *)CURRENT_PROJECT->RESC_PROJECT_SETTINGS->get_held_resource();
                            tProjectProps->projectSettingsTabBar->open_tab("Platforms");
                        }
                    break;

                    case 6:
                        if( CURRENT_PROJECT!=NULL && CURRENT_PROJECT->RESC_PROJECT_SETTINGS!=NULL )
                        {
                            CURRENT_PROJECT->export_and_play_native();
                        }
                    break;
                    default:

                    break;
                }
            }
        }
    }
    GPE_MAIN_GUI->process_cursor();
    /*
    //language tooltip
    //place elsewhere once language support is added
    if( point_between(userInput->mouse_x,userInput->mouse_y,SCREEN_WIDTH-32,0,SCREEN_WIDTH,32) )
    {
        GPE_MAIN_GUI->update_tooltip(userInput->mouse_x,userInput->mouse_y+GPE_AVERAGE_LINE_HEIGHT_WITH_PADDING,"Language Settings: American English! USA! ",FA_RIGHT);
    }
    */
}

void GPE_Editor_State::clean_up()
{

}

void GPE_Editor_State::render()
{
    bool forceRedraw = false;
    if( userInput->input_received() )
    {
        //render_rectangle(MAIN_RENDERER,0,0,SCREEN_WIDTH,SCREEN_HEIGHT,c_black,false,255);
        forceRedraw = true;
    }
    if( MAIN_EDITOR_SETTINGS!=NULL)
    {
        if( MAIN_EDITOR_SETTINGS->forceFrameRedraw!=NULL && MAIN_EDITOR_SETTINGS->forceFrameRedraw->is_clicked() )
        {
            forceRedraw = true;
        }
    }
    /*else if( GPE_FOUND_OS==GPE_IDE_LINUX )
    {
        render_rectangle(MAIN_RENDERER,0,0,SCREEN_WIDTH,SCREEN_HEIGHT,c_black,false,255);
         forceRedraw = true;
    }*/

    if( forceRedraw )
    {
        if( mainButtonBar!=NULL  )
        {
            render_rectangle(MAIN_RENDERER,0,0,SCREEN_WIDTH,GPE_Main_TabManager->get_ypos(),GPE_MAIN_TEMPLATE->Program_Header_Color,false);
            mainButtonBar->render_self(MAIN_RENDERER,&camera,&camera,forceRedraw);
        }
    }
    GPE_MAIN_GUI->render_foreground_engine(MAIN_RENDERER,forceRedraw);
    //MAIN_RENDERER->update_renderer();
    /*
    //Pending language support
    if(country_language_image!=NULL)
    {
        render_texture(MAIN_RENDERER,country_language_image,SCREEN_WIDTH-32,0,NULL,NULL);
    }
    */
    /*
    std::string bottomRightText = SDL_VersionText+" |  Language:";
    if( userInput->check_mouse_doubleclicked(0) )
    {
        bottomRightText = "Double Click Found";
    }
    render_new_text(MAIN_RENDERER,SCREEN_WIDTH-60,SCREEN_HEIGHT-16,bottomRightText,GPE_MAIN_TEMPLATE->Main_Box_Font_Color,LAST_USED_FONT,FA_RIGHT,FA_MIDDLE);
    */
    userInput->forceRedrawNeeded  = false;
}



void GPE_open_context_menu(int menuXPos,int menuYPos)
{
    if( menuXPos<0)
    {
        menuXPos = userInput->mouse_x;
    }
    if( menuYPos<0)
    {
        menuYPos = userInput->mouse_y;
    }
    if( MAIN_CONTEXT_MENU!=NULL)
    {
        MAIN_CONTEXT_MENU->clear_menu();
        MAIN_CONTEXT_MENU->subMenuIsOpen = true;
        MAIN_CONTEXT_MENU->set_position(menuXPos, menuYPos);
    }
}

void GPE_close_context_menu()
{
    if( MAIN_CONTEXT_MENU!=NULL && MAIN_CONTEXT_MENU->subMenuIsOpen)
    {
        MAIN_CONTEXT_MENU->clear_menu();
        MAIN_CONTEXT_MENU->subMenuIsOpen = false;
        userInput->reset_all_input();
        if( GPE_MAIN_GUI!=NULL)
        {
            GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
        }
    }
}

int get_popupmenu_result(SDL_Rect * cam, bool redrawScreen)
{
    RESOURCE_TO_DRAG = NULL;
    GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
    GPE_MAIN_GUI->process_cursor();
    GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);
    userInput->reset_all_input();
    int returnValue = -1;
    bool exitOperation = false;
    if( MAIN_CONTEXT_MENU!=NULL)
    {
        MAIN_CONTEXT_MENU->hoverOption = MAIN_CONTEXT_MENU->selectedOption = 0;
    }
    while(exitOperation==false)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
        //Start the frame timer
        capTimer->start();
        //gets user input
        userInput->handle(true,true);

        if( userInput->windowEventHappendInFrame)
        {
            exitOperation = true;
            returnValue = -1;
        }
        else
        {
            if( MAIN_CONTEXT_MENU!=NULL)
            {
                if( MAIN_CONTEXT_MENU->is_open() )
                {
                    returnValue = POPUP_MENU_VALUE = MAIN_CONTEXT_MENU->process_menu_option();
                    if( userInput->check_mouse_released(kb_anykey) || WINDOW_WAS_JUST_RESIZED || userInput->released[kb_esc] || userInput->released[kb_enter] )
                    {
                        GPE_close_context_menu();
                        exitOperation = true;
                    }
                }
                else
                {
                    exitOperation = true;
                }
                calculate_avg_fps();
                if( !WINDOW_WAS_JUST_RESIZED)
                {
                    //if( redrawScreen)
                    {
                        GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
                    }
                    //Update screen
                    MAIN_CONTEXT_MENU->render_self(MAIN_RENDERER,cam);
                    MAIN_RENDERER->update_renderer();
                }
                cap_fps();
            }
            else
            {
                exitOperation = true;
                returnValue = -1;
            }
        }
        GPE_MAIN_GUI->process_cursor();
    }
    GPE_close_context_menu();
    userInput->reset_all_input();
    return returnValue;
}

void display_user_messaage()
{
    //if( userInput->input_received() )
    {
        //Update screen
        render_rectangle(MAIN_RENDERER,0,0,256,96,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);
        render_rectangle(MAIN_RENDERER,0,0,256,96,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
        render_new_text(MAIN_RENDERER,GENERAL_GPE_PADDING,GENERAL_GPE_PADDING,displayMessageTitle,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP);
        render_new_text(MAIN_RENDERER,GENERAL_GPE_PADDING,GENERAL_GPE_PADDING*2+GPE_AVERAGE_LINE_HEIGHT,displayMessageSubtitle,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP);
        render_new_text(MAIN_RENDERER,GENERAL_GPE_PADDING,GENERAL_GPE_PADDING*3+GPE_AVERAGE_LINE_HEIGHT*2,displayMessageString,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,DEFAULT_FONT,FA_LEFT,FA_TOP);
        MAIN_RENDERER->update_renderer();
    }

}

void display_user_alert(std::string messageTitle, std::string messageContent, int messageType ,SDL_Rect * cam)
{
    RESOURCE_TO_DRAG = NULL;
    GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
    GPE_MAIN_GUI->process_cursor();
    GPE_MAIN_GUI->reset_gui_info();
    GPE_MAIN_GUI->update_tooltip("");
    GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);
    userInput->reset_all_input();
    bool exitOperation = false;
    bool windowBeingDragged = false;

    SDL_Rect barBox;

    barBox.w = SCREEN_WIDTH*3/4 -128 - GENERAL_GPE_PADDING*4;
    barBox.h = SCREEN_HEIGHT*3/4 - 64 - GENERAL_GPE_PADDING*4;
    barBox.x = SCREEN_WIDTH - barBox.w;
    barBox.y = SCREEN_HEIGHT - barBox.h;
    int maxMessageWidth = 0;
    int maxMessageHeight = 0;
    int defaultFontWidth = 0;;
    int defaultFontHeight = 0;
    int iSubMessage = 0;
    if( FONT_DEFAULT_PROMPT!=NULL)
    {
        FONT_DEFAULT_PROMPT->get_metrics("A",&defaultFontWidth, &defaultFontHeight);
    }

    std::vector < std::string > messageSubTitles;

    GPE_ToolLabelButton * okButton = new GPE_ToolLabelButton(0,0,"Okay","");
    if( defaultFontWidth > 0 && defaultFontHeight > 0)
    {
        maxMessageWidth = (barBox.w-64) / defaultFontWidth;
        maxMessageHeight = (barBox.h-64) / (defaultFontHeight+GENERAL_GPE_PADDING);
        if( (int)messageTitle.size() > 0)
        {
            if((int)messageTitle.size() > maxMessageWidth )
            {
                messageTitle = messageTitle.substr(0,maxMessageWidth-3)+"...";
            }
        }
        else
        {
            messageTitle = "Alert";
        }

        if( (int)messageContent.size() > 0)
        {
            wrap_string(messageContent,messageSubTitles,maxMessageWidth,maxMessageHeight);
        }
        else
        {
            messageContent = "...";
            messageSubTitles.push_back(messageContent);
        }

        if( (int) messageSubTitles.size() < maxMessageHeight )
        {
            barBox.h = messageSubTitles.size()*(defaultFontHeight+GENERAL_GPE_PADDING)+GENERAL_GPE_PADDING*4+64;
            barBox.y = (SCREEN_HEIGHT - barBox.h)/2;
        }
        else
        {
            barBox.h = maxMessageHeight*(defaultFontHeight+GENERAL_GPE_PADDING)+GENERAL_GPE_PADDING*4+64;
            barBox.y = (SCREEN_HEIGHT - barBox.h)/2;
        }

        maxMessageWidth = (int)messageTitle.size();
        for( iSubMessage = 0; iSubMessage < (int)messageSubTitles.size(); iSubMessage++)
        {
            if( (int)messageSubTitles.at(iSubMessage).size()  > maxMessageWidth )
            {
                maxMessageWidth = (int)messageSubTitles.at(iSubMessage).size();
            }
        }

        barBox.w = (maxMessageWidth*defaultFontWidth)+128 + GENERAL_GPE_PADDING*4;
        barBox.x = (SCREEN_WIDTH - barBox.w)/2;

        while(exitOperation==false)
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
            //Start the frame timer
            capTimer->start();
            //gets user input
            userInput->handle(true,true);
            GPE_MAIN_GUI->reset_gui_info();

            if( windowBeingDragged )
            {
                GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZEALL);
                if( userInput->check_mouse_down(0) )
                {
                    barBox.x = userInput->mouse_x-barBox.w/2;
                    barBox.y = userInput->mouse_y;
                }
                else
                {
                    windowBeingDragged = false;
                }

                if( barBox.x+barBox.w > SCREEN_WIDTH )
                {
                    barBox.x = SCREEN_WIDTH - barBox.w;
                }

                if( barBox.y+barBox.h > SCREEN_HEIGHT )
                {
                    barBox.y = SCREEN_HEIGHT - barBox.h;
                }

                if( barBox.x < 0)
                {
                    barBox.x = 0;
                }

                if( barBox.y < 0)
                {
                    barBox.y = 0;
                }
            }
            else
            {
                if( userInput->check_mouse_released(0) )
                {
                    if( point_between(userInput->mouse_x,userInput->mouse_y,barBox.x+barBox.w-32,barBox.y,barBox.x+barBox.w,barBox.y+30) )
                    {
                        exitOperation = true;
                    }
                }
                else if( userInput->check_mouse_down(0) )
                {
                    if( point_between(userInput->mouse_x,userInput->mouse_y,barBox.x,barBox.y,barBox.x+barBox.w-32,barBox.y+32) )
                    {
                        windowBeingDragged = true;
                    }
                }
            }
            if( okButton!=NULL)
            {
                okButton->set_coords(barBox.x+( barBox.w-okButton->get_width() )/2,barBox.y+barBox.h-GENERAL_GPE_PADDING-okButton->get_height() );
                okButton->process_self( NULL, NULL);
                if( okButton->is_clicked() && !windowBeingDragged )
                {
                    exitOperation = true;
                }
            }
            if( userInput->check_keyboard_released(kb_esc) || userInput->check_keyboard_released(kb_space) || userInput->check_keyboard_released(kb_enter) || WINDOW_WAS_JUST_RESIZED)
            {
                exitOperation = true;
            }

            calculate_avg_fps();
            SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
            //if( WINDOW_WAS_JUST_RESIZED )
            {
                render_rectangle(MAIN_RENDERER,0,0,SCREEN_WIDTH,SCREEN_HEIGHT,GPE_MAIN_TEMPLATE->Program_Color, false, 255);
                GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
            }
            //Update screen
            render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);

            render_rectangle(MAIN_RENDERER,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+32,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);

            render_new_text(MAIN_RENDERER,barBox.x+barBox.w/2,barBox.y+GENERAL_GPE_PADDING,messageTitle,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,DEFAULT_FONT,FA_CENTER,FA_TOP);
            render_new_text(MAIN_RENDERER,barBox.x+barBox.w-GENERAL_GPE_PADDING,barBox.y+GENERAL_GPE_PADDING,"X",GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,DEFAULT_FONT,FA_RIGHT,FA_TOP);

            for( iSubMessage = 0; iSubMessage < (int)messageSubTitles.size(); iSubMessage++)
            {
                render_new_text(MAIN_RENDERER,barBox.x+32,barBox.y+GENERAL_GPE_PADDING+32+iSubMessage*(defaultFontHeight+GENERAL_GPE_PADDING),messageSubTitles.at(iSubMessage),GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_DEFAULT_PROMPT,FA_LEFT,FA_TOP);
            }
            if( okButton!=NULL)
            {
                okButton->render_self(MAIN_RENDERER, NULL, NULL, true);
            }
            if( point_within_rect(userInput->mouse_x,userInput->mouse_y,&barBox) )
            {
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Alt_Color,true);
            }
            else
            {
                render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
            }
            GPE_MAIN_GUI->process_cursor();
            MAIN_RENDERER->update_renderer();

            cap_fps();
        }
    }
    if( okButton!=NULL )
    {
        delete okButton;
        okButton = NULL;
    }
    userInput->reset_all_input();
}

int display_get_prompt(std::string messageTitle, std::string messageContent, bool showCancelButton )
{
    RESOURCE_TO_DRAG = NULL;
    int maxMessageWidth = 0;
    int maxMessageHeight = 0;
    int defaultFontWidth = 12;
    int defaultFontHeight = 12;
    std::vector < std::string > messageSubTitles;
    int iSubMessage = 0;
    GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
    GPE_MAIN_GUI->process_cursor();
    GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);
    userInput->reset_all_input();
    bool exitOperation = false;
    int returnVal = DISPLAY_QUERY_CANCEL;
    GPE_ToolLabelButton * yesButton = new GPE_ToolLabelButton(0,32,"Yes[ENTER]","");
    yesButton->set_width(96);
    GPE_ToolLabelButton * noButon = NULL;
    GPE_ToolLabelButton * cancelButton = NULL;
    if( showCancelButton)
    {
        cancelButton = new GPE_ToolLabelButton(0,32,"Cancel[ESC]","");
        cancelButton->set_width(96);
        noButon = new GPE_ToolLabelButton(0,32,"No[N]","");
        noButon->set_width(96);
    }
    else
    {
        noButon = new GPE_ToolLabelButton(0,32,"No[ESC]","");
        noButon->set_width(96);
    }

    bool boxIsMoving = false;
    bool boxWasResized = true;
    bool boxBeingResized  = false;

    if( FONT_DEFAULT_PROMPT!=NULL)
    {
        FONT_DEFAULT_PROMPT->get_metrics("A",&defaultFontWidth, &defaultFontHeight);
    }

    SDL_Rect barBox;
    barBox.w = 528;
    barBox.h = 320;
    barBox.x = (SCREEN_WIDTH - barBox.w)/2;
    barBox.y = 72;
    barBox.x = (SCREEN_WIDTH - barBox.w)/2;
    barBox.y = 72;
    maxMessageWidth = (barBox.w-32) / defaultFontWidth;
    maxMessageHeight = (barBox.h-64) / (defaultFontHeight+GENERAL_GPE_PADDING);
    int newBarX2Pos = barBox.x+barBox.w;
    int newBarY2Pos = barBox.w+barBox.h;
    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);

    if( defaultFontWidth > 0 && defaultFontHeight > 0)
    {
        maxMessageWidth = (barBox.w-32) / defaultFontWidth;
        maxMessageHeight = (barBox.h-64) / (defaultFontHeight+GENERAL_GPE_PADDING);

        messageSubTitles.clear();
        if( (int)messageTitle.size() > 0)
        {
            if((int)messageTitle.size() > maxMessageWidth )
            {
                messageTitle = messageTitle.substr(0,maxMessageWidth-3)+"...";
            }
        }
        else
        {
            messageTitle = "Alert";
        }

        if( (int)messageContent.size() > 0)
        {
            wrap_string(messageContent,messageSubTitles,maxMessageWidth,maxMessageHeight);
        }
        else
        {
            messageContent = "...";
            messageSubTitles.push_back(messageContent);
        }

        if( (int) messageSubTitles.size() < maxMessageHeight )
        {
            barBox.h = messageSubTitles.size()*(defaultFontHeight+GENERAL_GPE_PADDING)+GENERAL_GPE_PADDING*4+64;
        }
        else
        {
            barBox.h = maxMessageHeight*(defaultFontHeight+GENERAL_GPE_PADDING)+GENERAL_GPE_PADDING*4+64;
        }

        maxMessageWidth = (int)messageTitle.size();
        for( iSubMessage = 0; iSubMessage < (int)messageSubTitles.size(); iSubMessage++)
        {
            if( (int)messageSubTitles.at(iSubMessage).size()  > maxMessageWidth )
            {
                maxMessageWidth = (int)messageSubTitles.at(iSubMessage).size();
            }
        }

        barBox.x = (SCREEN_WIDTH-barBox.w)/2;
        newBarX2Pos = barBox.x+barBox.w;
        newBarY2Pos = barBox.w+barBox.h;
        int barBoxMinWidth = 64;
        int barBoxMinHeight = barBox.h;

        while(exitOperation==false )
        {
            GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
            //Start the frame timer
            capTimer->start();
            //gets user input
            userInput->handle(true,true);
            GPE_MAIN_GUI->reset_gui_info();

            if( userInput->check_mouse_down(0) && !userInput->check_mouse_pressed(0) )
            {
                if( boxIsMoving)
                {
                    GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZEALL);
                    barBox.x = userInput->mouse_x-barBox.w/2;
                    barBox.y = userInput->mouse_y;
                }
                else if( boxBeingResized)
                {
                    GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZENWSE);
                    newBarX2Pos = userInput->mouse_x;
                    if( newBarX2Pos > barBox.x+barBoxMinWidth && newBarX2Pos < SCREEN_WIDTH-32 && newBarX2Pos> 0 )
                    {
                        barBox.w = newBarX2Pos-barBox.x;
                        boxWasResized = true;
                    }
                    newBarY2Pos = userInput->mouse_y;
                    if( newBarY2Pos > barBox.y+barBoxMinHeight && newBarY2Pos < SCREEN_HEIGHT-32 && newBarY2Pos > 0 )
                    {
                        barBox.h = newBarY2Pos-barBox.y;
                        boxWasResized = true;
                    }
                }
            }

            if( point_between(userInput->mouse_x,userInput->mouse_y,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+32) )
            {
                GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZEALL);
                if( userInput->check_mouse_pressed(0) )
                {
                    boxIsMoving = true;
                }
            }
            else if( point_between(userInput->mouse_x,userInput->mouse_y,barBox.x+barBox.w-32,barBox.y+barBox.h-32,barBox.x+barBox.w,barBox.y+barBox.h) )
            {
                GPE_change_cursor(SDL_SYSTEM_CURSOR_SIZENWSE);
                if( userInput->check_mouse_pressed(0) )
                {
                    boxBeingResized = true;
                }
            }

            if( userInput->check_mouse_released(-1) )
            {
                boxIsMoving = false;
                boxBeingResized = false;
                GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
            }
            if( barBox.w < barBoxMinWidth)
            {
                barBox.w = barBoxMinWidth;
            }
            if( barBox.h < barBoxMinHeight)
            {
                barBox.h = barBoxMinHeight;
            }
            if(  barBox.x+barBox.w > SCREEN_WIDTH)
            {
                barBox.x = SCREEN_WIDTH-barBox.w;
                boxWasResized = true;
            }
            if( barBox.x < 0 )
            {
                barBox.x = 0;
                boxWasResized = true;
            }

            if(  barBox.y+barBox.h > SCREEN_HEIGHT )
            {
                barBox.y = SCREEN_HEIGHT-barBox.h;
                boxWasResized = true;
            }
            if( barBox.y < 0 )
            {
                barBox.y = 0;
                boxWasResized = true;
            }

            if( boxWasResized)
            {
                maxMessageWidth = (barBox.w-32) / defaultFontWidth;
                maxMessageHeight = (barBox.h-64) / (defaultFontHeight+GENERAL_GPE_PADDING);

                messageSubTitles.clear();
                /*if( (int)messageTitle.size() > 0)
                {
                    if((int)messageTitle.size() > maxMessageWidth )
                    {
                        messageTitle = messageTitle.substr(0,maxMessageWidth-3)+"...";
                    }
                }
                else
                {
                    messageTitle = "Alert";
                }*/

                if( (int)messageContent.size() > 0)
                {
                    wrap_string(messageContent,messageSubTitles,maxMessageWidth,maxMessageHeight);
                }
                else
                {
                    messageContent = "...";
                    messageSubTitles.push_back(messageContent);
                }
                /*if( (int) messageSubTitles.size() < maxMessageHeight )
                {
                    barBox.h = messageSubTitles.size()*(defaultFontHeight+GENERAL_GPE_PADDING)+GENERAL_GPE_PADDING*4+64;
                }
                else
                {
                    barBox.h = maxMessageHeight*(defaultFontHeight+GENERAL_GPE_PADDING)+GENERAL_GPE_PADDING*4+64;
                }*/

                maxMessageWidth = (int)messageTitle.size();
                for( iSubMessage = 0; iSubMessage < (int)messageSubTitles.size(); iSubMessage++)
                {
                    if( (int)messageSubTitles.at(iSubMessage).size()  > maxMessageWidth )
                    {
                        maxMessageWidth = (int)messageSubTitles.at(iSubMessage).size();
                    }
                }
                boxWasResized = false;
            }

            yesButton->set_coords( GENERAL_GPE_PADDING+64,barBox.h-32);
            noButon->set_coords(yesButton->get_xpos()+yesButton->get_width()+GENERAL_GPE_PADDING,yesButton->get_ypos() );
            if( cancelButton!=NULL)
            {
                cancelButton->set_coords( noButon->get_xpos()+noButon->get_width()+GENERAL_GPE_PADDING,noButon->get_ypos() );
                cancelButton->process_self(&barBox,&camera);
            }
            yesButton->process_self(&barBox,&camera);
            noButon->process_self(&barBox,&camera);


            if( userInput->check_keyboard_released(kb_esc) || MAIN_RENDERER->windowClosed )
            {
                if( cancelButton!=NULL)
                {
                    exitOperation = true;
                    returnVal = DISPLAY_QUERY_CANCEL;
                }
                else
                {
                    exitOperation = true;
                    returnVal = DISPLAY_QUERY_NO;
                }
            }
            else if( userInput->check_keyboard_released(kb_n) )
            {
                exitOperation = true;
                returnVal = DISPLAY_QUERY_NO;
            }
            else if( noButon->is_clicked() )
            {
                exitOperation = true;
                returnVal = DISPLAY_QUERY_NO;
            }
            else if( cancelButton!=NULL &&  cancelButton->is_clicked() )
            {
                exitOperation = true;
                returnVal = DISPLAY_QUERY_CANCEL;
            }
            else if( userInput->check_keyboard_released(kb_enter) || yesButton->is_clicked() )
            {
                exitOperation = true;
                returnVal = DISPLAY_QUERY_YES;
            }
            calculate_avg_fps();
            if( !WINDOW_WAS_JUST_RESIZED)
            {
                SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
                //Update screen
                //if( userInput->windowEventHappendInFrame )
                {
                    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
                }
                SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),&barBox );

                render_rectangle(MAIN_RENDERER,0,0,barBox.w,barBox.h,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);
                render_rectangle(MAIN_RENDERER,0,0,barBox.w,32,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);

                render_new_text(MAIN_RENDERER,GENERAL_GPE_PADDING*2,GENERAL_GPE_PADDING,messageTitle,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,FONT_DEFAULT_PROMPT,FA_LEFT,FA_TOP);
                //render_new_text(MAIN_RENDERER,barBox.x+GENERAL_GPE_PADDING+32,barBox.y+64,messageContent,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_DEFAULT_PROMPT,FA_LEFT,FA_TOP);
                for( iSubMessage = 0; iSubMessage < (int)messageSubTitles.size(); iSubMessage++)
                {
                    render_new_text(MAIN_RENDERER,32,GENERAL_GPE_PADDING+32+iSubMessage*(defaultFontHeight+GENERAL_GPE_PADDING),messageSubTitles.at(iSubMessage),GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_DEFAULT_PROMPT,FA_LEFT,FA_TOP);
                }

                yesButton->render_self(MAIN_RENDERER,&barBox,&camera);
                noButon->render_self(MAIN_RENDERER,&barBox,&camera);
                if( cancelButton!=NULL)
                {
                    cancelButton->render_self(MAIN_RENDERER,&barBox,&camera);
                }
                render_rectangle(MAIN_RENDERER,1,1,barBox.w-1,barBox.h-1,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
                render_rectangle(MAIN_RENDERER,0,0,barBox.w,barBox.h,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,true);
                //GPE_MAIN_GUI-render_gui_info(MAIN_RENDERER, true);
                GPE_MAIN_GUI->process_cursor();
                MAIN_RENDERER->update_renderer();
            }
            cap_fps();
        }
    }
    SDL_RenderSetViewport(MAIN_RENDERER->get_renderer(),NULL);
    GPE_MAIN_GUI->render_gui_info(MAIN_RENDERER, true);
    if( FONT_DEFAULT_PROMPT!=NULL)
    {
        FONT_DEFAULT_PROMPT->clear_cache();
    }
    if( yesButton!=NULL)
    {
        delete yesButton;
        yesButton = NULL;
    }
    if( noButon!=NULL)
    {
        delete noButon;
        noButon = NULL;
    }
    if( cancelButton!=NULL)
    {
        delete cancelButton;
        cancelButton = NULL;
    }
    userInput->reset_all_input();
    messageSubTitles.clear();
    return returnVal;
}

std::string get_string_from_popup(std::string messageTitle, std::string messageContent, std::string startName)
{
    RESOURCE_TO_DRAG = NULL;
    GPE_MAIN_GUI->update_tooltip("");
    GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
    GPE_MAIN_GUI->process_cursor();
    GPE_MAIN_GUI->take_frozen_screenshot(MAIN_RENDERER);
    userInput->reset_all_input();
    bool exitOperation = false;
    int frame = 0;
    int TEXTBOX_FONT_SIZE_WIDTH = 12;
    int TEXTBOX_FONT_SIZE_HEIGHT = 12;
    if( FONT_DEFAULT_PROMPT!=NULL)
    {
         FONT_DEFAULT_PROMPT->get_metrics("A",&TEXTBOX_FONT_SIZE_WIDTH,&TEXTBOX_FONT_SIZE_HEIGHT);
    }
    int titleWidth = TEXTBOX_FONT_SIZE_WIDTH * (int)messageTitle.size();
    int messageWidth = TEXTBOX_FONT_SIZE_WIDTH * (int)messageContent.size();
    int biggestStringWidth = std::max(titleWidth, messageWidth);
    std::string returnVal = startName;
    GPE_ToolLabelButton * yesButton = new GPE_ToolLabelButton(0,32,"Okay","");
    GPE_ToolLabelButton * cancelButton = new GPE_ToolLabelButton(0,32,"Cancel","");
    GPE_TextInputBasic * newStringBox = new GPE_TextInputBasic(startName);
    newStringBox->switch_inuse(true);
    int buttonsWidth = yesButton->get_width()+cancelButton->get_width();
    int promptBoxWidth = buttonsWidth;
    if( promptBoxWidth < biggestStringWidth)
    {
        promptBoxWidth =biggestStringWidth;
    }
    promptBoxWidth+=GENERAL_GPE_PADDING*3;
    SDL_Rect barBox;
    barBox.x = (SCREEN_WIDTH-promptBoxWidth)/2-GENERAL_GPE_PADDING;
    barBox.y = SCREEN_HEIGHT/2-64-GENERAL_GPE_PADDING;
    barBox.w = promptBoxWidth+128;
    barBox.h = 192;
    GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
    while(exitOperation==false)
    {
        GPE_change_cursor(SDL_SYSTEM_CURSOR_ARROW);
        //Start the frame timer
        capTimer->start();
        //gets user input
        userInput->handle(true,true);

        GPE_MAIN_GUI->reset_gui_info();

        barBox.x = (SCREEN_WIDTH-promptBoxWidth)/2-GENERAL_GPE_PADDING;
        barBox.y = SCREEN_HEIGHT/2-64-GENERAL_GPE_PADDING;

        newStringBox->set_coords( barBox.x+GENERAL_GPE_PADDING,barBox.y+64);
        newStringBox->set_width(barBox.w - 64);

        yesButton->set_coords( barBox.x+GENERAL_GPE_PADDING,newStringBox->get_ypos()+newStringBox->get_height() + GENERAL_GPE_PADDING);
        cancelButton->set_coords( yesButton->get_xpos()+yesButton->get_width()+GENERAL_GPE_PADDING,yesButton->get_ypos() );

        newStringBox->process_self(&camera,&camera);
        yesButton->process_self(&camera,&camera);
        cancelButton->process_self(&camera,&camera);

        if( userInput->check_keyboard_released(kb_esc) || cancelButton->is_clicked() )
        {
            exitOperation = true;
            returnVal = "";
        }
        else if( userInput->check_keyboard_released(kb_enter) || yesButton->is_clicked() )
        {
            exitOperation = true;
            if( newStringBox!=NULL)
            {
                returnVal = newStringBox->get_string();
            }
        }

        calculate_avg_fps();

        //Update screen
        //if( userInput->windowEventHappendInFrame )
        {
            GPE_MAIN_GUI->render_frozen_screenshot(MAIN_RENDERER);
        }
        render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Color,false);
        render_rectangle(MAIN_RENDERER,barBox.x,barBox.y,barBox.x+barBox.w,barBox.y+32,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Color,false);

        render_new_text(MAIN_RENDERER,(SCREEN_WIDTH-promptBoxWidth)/2+GENERAL_GPE_PADDING,SCREEN_HEIGHT/2-64,messageTitle,GPE_MAIN_TEMPLATE->PopUp_Box_Highlight_Font_Color,FONT_DEFAULT_PROMPT,FA_LEFT,FA_TOP);
        render_new_text(MAIN_RENDERER,(SCREEN_WIDTH-promptBoxWidth)/2+GENERAL_GPE_PADDING,SCREEN_HEIGHT/2-32,messageContent,GPE_MAIN_TEMPLATE->PopUp_Box_Font_Color,FONT_DEFAULT_PROMPT,FA_LEFT,FA_TOP);
        yesButton->render_self(MAIN_RENDERER,&camera,&camera);
        cancelButton->render_self(MAIN_RENDERER,&camera,&camera);
        newStringBox->render_self(MAIN_RENDERER,&camera, &camera);
        render_rect(MAIN_RENDERER,&barBox,GPE_MAIN_TEMPLATE->PopUp_Box_Border_Color,true);
        //GPE_MAIN_GUI-render_gui_info(MAIN_RENDERER, true);
        GPE_MAIN_GUI->process_cursor();
        GPE_MAIN_GUI->render_gui_info(MAIN_RENDERER, true);
        MAIN_RENDERER->update_renderer();

        cap_fps();
    }
    if( yesButton!=NULL)
    {
        delete yesButton;
        yesButton = NULL;
    }
    if( cancelButton!=NULL)
    {
        delete cancelButton;
        cancelButton = NULL;
    }
    if( newStringBox!=NULL)
    {
        delete newStringBox;
        newStringBox = NULL;
    }

    userInput->reset_all_input();
    return returnVal;
}

int modify_folder_images(std::string folderLocation, int modifcationType)
{
    int imagesModifiedCount = -1;
    if( path_exists(folderLocation) && modifcationType >=0 && modifcationType < 3)
    {
        GPE_FileDirectory * foundFolder = new GPE_FileDirectory();
        foundFolder->open_directory_sorted(folderLocation);

        GPE_Color * colorToRemove = NULL;
        bool continueWithAction = false;
        imagesModifiedCount = 0;
        if( foundFolder->get_count() > 0 )
        {
            if( modifcationType==0)
            {
                colorToRemove = GPE_Get_Color_PopUp("Image Background Color To Remove",c_fuchsia);
                if( colorToRemove!=NULL)
                {
                    if( display_get_prompt("Are you sure you want to erase this Color from all images in this folder?","This action is irreversible and will change your image's format to a .png file!")==DISPLAY_QUERY_YES)
                    {
                        continueWithAction = true;
                    }
                }
            }
            else if( modifcationType==1 )
            {
                if( display_get_prompt("Are you sure you want to invert your all images in this folder?","This action is irreversible and will change your image's format to a .png file!")==DISPLAY_QUERY_YES)
                {
                    continueWithAction = true;
                }
            }
            else if( modifcationType==2 )
            {
                if( display_get_prompt("Are you sure you want to grayscale all images in this folder?","This action is irreversible and will change your image's format to a .png file!")==DISPLAY_QUERY_YES)
                {
                    continueWithAction = true;
                }
            }
            if( continueWithAction)
            {
                std::string newImageName = "";
                GPE_File * tempFile = NULL;
                SDL_Surface * oTempSurface = NULL;
                SDL_Surface *nTempSurface = NULL;
                for( int i = 0; i < foundFolder->get_count(); i++)
                {
                    tempFile = foundFolder->get_file(i);
                    if( tempFile!=NULL)
                    {
                        if( tempFile->get_type()=="bmp" || tempFile->get_type()=="png")
                        {
                            newImageName = folderLocation+"/"+tempFile->get_name();
                            oTempSurface = load_surface_image( newImageName );
                            if( oTempSurface->w > 0 && oTempSurface->h > 0)
                            {
                                nTempSurface = NULL;
                                if( oTempSurface!=NULL)
                                {
                                    record_error("Modifying image at: "+newImageName+".");

                                    displayMessageTitle = "Modifying Image";
                                    displayMessageSubtitle = tempFile->get_name();;
                                    displayMessageString = "...";
                                    display_user_messaage();
                                    if( modifcationType==0)
                                    {
                                        nTempSurface=surface_remove_color(oTempSurface,colorToRemove->get_sdl_color() );
                                    }
                                    else if( modifcationType==1 )
                                    {
                                        nTempSurface=surface_invert(oTempSurface);
                                    }
                                    else if( modifcationType==2 )
                                    {
                                        nTempSurface=surface_grayscale(oTempSurface);
                                    }
                                    if( nTempSurface!=NULL)
                                    {
                                        if( tempFile->get_type()=="bmp" || tempFile->get_type()=="png")
                                        {
                                            SDL_SaveBMP(nTempSurface,newImageName.c_str() );
                                        }
                                        else if( tempFile->get_type()=="png")
                                        {
                                            IMG_SavePNG(nTempSurface,newImageName.c_str() );
                                        }
                                        SDL_FreeSurface(nTempSurface);
                                        nTempSurface = NULL;
                                        imagesModifiedCount++;
                                    }
                                    SDL_FreeSurface(oTempSurface);
                                    oTempSurface = NULL;
                                }
                            }
                        }
                    }
                }
            }
        }
        foundFolder->close_directory();
        delete foundFolder;
    }
    return imagesModifiedCount;
}


int clean_folder(std::string folderName)
{
    GPE_FileDirectory * dir = new GPE_FileDirectory();
    GPE_File * file = NULL;
    int iFile = 0;
    int iDirectory = 0;

    std::string fileToClick = "";
    std::vector< std::string > foldersToDelete;
    foldersToDelete.push_back(folderName);
    std::string currentFolderToClear = folderName;
    int filesDeletedCount = 0;
    if( dir!=NULL)
    {
        while( (int)foldersToDelete.size() > 0 )
        {
            currentFolderToClear = foldersToDelete[0];
            dir->open_directory(currentFolderToClear);
            for (iFile = (int)dir->get_count()-1; iFile>=0; iFile--)
            {
                file = dir->get_file(iFile);
                if( file!=NULL)
                {
                    fileToClick = file->get_name();
                    if( fileToClick!="." && fileToClick!="..")
                    {
                        fileToClick = currentFolderToClear+"/"+fileToClick;
                        if( file->is_directory() )
                        {
                            foldersToDelete.push_back(fileToClick );
                        }
                        else
                        {
                            remove(fileToClick.c_str() );
                            filesDeletedCount++;
                        }
                    }
                }
            }
            for( iDirectory = (int)foldersToDelete.size()-1; iDirectory >=0; iDirectory--)
            {
                if( currentFolderToClear==foldersToDelete.at(iDirectory) )
                {
                    foldersToDelete.erase( foldersToDelete.begin()+iDirectory);
                }
            }
        }
        delete dir;
        dir = NULL;
        return filesDeletedCount;
    }
    return 0;
}

bool copy_folder(std::string folderName, std::string targetFolder, bool copySubFolders)
{
    if( path_exists(folderName) && path_exists(targetFolder) )
    {
        GPE_FileDirectory * dir = new GPE_FileDirectory();
        GPE_File * file = NULL;
        std::string currentFileName = "";
        int iFile = 0;
        int iDirectory = 0;
        if( dir!=NULL)
        {
            dir->open_directory(folderName);
            for (iFile = 0; iFile < (int)dir->get_count(); iFile++)
            {
                file = dir->get_file(iFile);
                if( file!=NULL)
                {
                    currentFileName = file->get_name();
                    if( currentFileName!="." && currentFileName!="..")
                    {
                        displayMessageString = "Copying "+currentFileName;
                        display_user_messaage();
                        currentFileName = folderName+"/"+currentFileName;
                        if( file->is_directory() )
                        {
                            if( copySubFolders)
                            {
                                create_directory(currentFileName);
                                copy_folder( currentFileName, targetFolder+"/"+ file->get_name(), true );
                            }
                        }
                        else
                        {

                            copy_file(currentFileName,targetFolder+"/"+ file->get_name() );
                        }
                    }
                }
            }
            delete dir;
            dir = NULL;
            return true;
        }
    }
    return false;
}


std::string get_user_settings_folder()
{
    char* homeDir = getenv("%UserProfile%");
    std::string foundPath = "";
    bool useProgramFolder = false;
    if( homeDir==NULL)
    {
        homeDir = getenv("home");
        if( homeDir==NULL)
        {
            homeDir = getenv("HOME");
            if( homeDir==NULL)
            {
                homeDir = getenv("homepath");
                if( homeDir==NULL)
                {
                    foundPath = APP_DIRECTORY_NAME;
                }
                else
                {
                    foundPath = homeDir;
                }
            }
            else
            {
                foundPath = homeDir;
            }
        }
        else
        {
            foundPath = homeDir;
        }
    }
    else
    {
        foundPath = homeDir;
    }

    if( path_exists(foundPath) )
    {
        std::string appDataPath = foundPath;
        if( GPE_FOUND_OS==GPE_IDE_WINDOWS)
        {
            appDataPath = foundPath+"/AppData";
            if( create_directory(appDataPath)!=-1)
            {
                foundPath = appDataPath;
                appDataPath = foundPath+"/Roaming";
                if( create_directory(appDataPath)!=-1)
                {
                    foundPath = appDataPath;
                    appDataPath = foundPath+"/PawByte";
                    if( create_directory(appDataPath)!=-1)
                    {
                        foundPath = appDataPath;
                        appDataPath = foundPath+"/GPE_Editor";
                        if( create_directory(appDataPath)!=-1)
                        {
                            foundPath = appDataPath;
                        }
                    }
                    else
                    {
                        useProgramFolder = true;
                    }
                }
                else
                {
                    useProgramFolder = true;
                }
            }
            else
            {
                useProgramFolder = true;
            }
        }
        else if( GPE_FOUND_OS==GPE_IDE_LINUX)
        {
            appDataPath = foundPath+"/.PawByte";
            if( create_directory(appDataPath)!=-1)
            {
                foundPath = appDataPath;
                appDataPath = foundPath+"/GPE_Editor";
                if( create_directory(appDataPath)!=-1)
                {
                    foundPath = appDataPath;
                }
            }
        }
        else if( GPE_FOUND_OS==GPE_IDE_MAC)
        {
            appDataPath = foundPath+"/~/Library/Preferences";
            if( create_directory(appDataPath)!=-1)
            {
                foundPath = appDataPath;
                appDataPath = foundPath+"/PawByte";
                if( create_directory(appDataPath)!=-1)
                {
                    foundPath = appDataPath;
                    appDataPath = foundPath+"/GPE_Editor";
                    if( create_directory(appDataPath)!=-1)
                    {
                        foundPath = appDataPath;
                    }
                }
            }
        }
        else
        {
            foundPath = APP_DIRECTORY_NAME.c_str();
            useProgramFolder = true;
        }
    }
    else
    {
        useProgramFolder = true;
    }
    if( useProgramFolder)
    {
        foundPath = APP_DIRECTORY_NAME.c_str();
    }
    else
    {
        foundPath = foundPath+"/";
    }
    return foundPath;
}

std::string get_user_temp_folder()
{
    std::string foundPath = get_user_settings_folder();
    std::string tempFolderString = foundPath;
    foundPath = foundPath+"/temp_files";
    if( create_directory(foundPath)!=-1)
    {
        tempFolderString = foundPath+"/";
    }
    return tempFolderString;
}

std::string get_user_screenshot_folder()
{
    std::string foundPath = get_user_settings_folder();
    std::string tempScreenshotString = foundPath;
    foundPath = foundPath+"/screenshots";
    if( create_directory(foundPath)!=-1)
    {
        tempScreenshotString = foundPath+"/";
    }
    return tempScreenshotString;
}

bool has_early_tab(std::string strIn)
{
    if( MAIN_EDITOR_SETTINGS!=NULL && MAIN_EDITOR_SETTINGS->tabSpaceCount > 0 )
    {
        if( (int)strIn.size() > MAIN_EDITOR_SETTINGS->tabSpaceCount )
        {
            for( int ii= 0; ii < MAIN_EDITOR_SETTINGS->tabSpaceCount; ii++ )
            {
                if( strIn[ii]!=' ')
                {
                    return false;
                }
            }
            return true;
        }
    }
    else if( strIn.size() >= 4 )
    {
        if( strIn[0]==' ' && strIn[1]==' ' && strIn[2]==' ' && strIn[3]==' ')
        {
            return true;
        }
    }
    return false;
}

std::string untab_string(std::string strIn)
{
    if( has_early_tab(strIn) )
    {
        if( MAIN_EDITOR_SETTINGS!=NULL && MAIN_EDITOR_SETTINGS->tabSpaceCount > 0 )
        {
            strIn = get_substring(strIn, MAIN_EDITOR_SETTINGS->tabSpaceCount );
        }
        else
        {
            strIn = get_substring(strIn,  4 );
        }
    }
    return strIn;
}

std::string generate_tabs(int tabCount)
{
    if( tabCount > 0)
    {
        if( MAIN_EDITOR_SETTINGS!=NULL && MAIN_EDITOR_SETTINGS->tabSpaceCount > 0)
        {
            return string_repeat(" ", tabCount * MAIN_EDITOR_SETTINGS->tabSpaceCount );
        }
        else
        {
            return string_repeat("    ", tabCount);
        }
    }
    //record_error("0 tabs detected...");
    return "";
}

int get_tab_space_count()
{
    if( MAIN_EDITOR_SETTINGS!=NULL && MAIN_EDITOR_SETTINGS->tabSpaceCount > 0)
    {
        return MAIN_EDITOR_SETTINGS->tabSpaceCount;
    }
    return 4;
}

void record_error(std::string stringIn,std::string stringIn2,std::string stringIn3,std::string stringIn4, std::string stringIn5, std::string stringIn6, std::string stringIn7, std::string stringIn8, std::string stringIn9)
{
    std::string errorFileName = get_user_settings_folder()+"gpe_error_log.txt";
    stringIn+=stringIn2;
    stringIn+=stringIn3;
    stringIn+=stringIn4;
    stringIn+=stringIn5;
    stringIn+=stringIn6;
    stringIn+=stringIn7;
    stringIn+=stringIn8;
    stringIn+=stringIn9;

    std::cout << stringIn+" \n";
    std::ofstream filestr(errorFileName.c_str(), std::ios::out | std::ios::app);
    if( filestr.is_open() )
    {
        filestr << stringIn+" \n";
        filestr.close();
    }
}


GPE_IDE_Audio * GPE_Audio = NULL;

GPE_IDE_Audio::GPE_IDE_Audio()
{
    std::string startUpAudioName = APP_DIRECTORY_NAME+"resources/audio/startup1.ogg";
    startUpAudio = Mix_LoadWAV( startUpAudioName.c_str() );
    playGPEAudio = true;
    gpeAudioVolume = 100;
}

GPE_IDE_Audio::~GPE_IDE_Audio()
{

    if( startUpAudio!=NULL)
    {
        Mix_FreeChunk(startUpAudio);
        startUpAudio = NULL;
    }
}

void GPE_IDE_Audio::load_audio_settings(std::string settingsFileName)
{
    if( file_exists(settingsFileName) )
    {
        std::ifstream settingsFile (settingsFileName.c_str() );
        if (settingsFile.is_open())
        {
            std::string currLineToBeProcessed = "";
            std::string keyString = "";
            std::string valString = "";
            int equalPos = 0;
            while( settingsFile.good() )
            {
                getline (settingsFile,currLineToBeProcessed); //gets the next line of the file
                currLineToBeProcessed  = trim_left_inplace(currLineToBeProcessed);
                currLineToBeProcessed  = trim_right_inplace(currLineToBeProcessed);
                equalPos = currLineToBeProcessed.find_first_of("=");
                if(equalPos!=(int)std::string::npos)
                {
                    //if the equalPos is present, then parse on through and carryon
                    keyString = currLineToBeProcessed.substr(0,equalPos);
                    valString = currLineToBeProcessed.substr(equalPos+1,currLineToBeProcessed.length());
                    if( keyString=="Version")
                    {

                    }
                    else if( keyString=="MasterVolume")
                    {
                        gpeAudioVolume = string_to_int(valString);
                    }
                    else if( keyString=="AudioOn")
                    {
                        playGPEAudio = is_bool(valString);
                    }
                }
            }
            settingsFile.close();
        }

    }
}

void GPE_IDE_Audio::save_audio_settings(std::string settingsFileName)
{

}
